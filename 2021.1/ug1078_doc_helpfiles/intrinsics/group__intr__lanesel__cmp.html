<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: Reduced Lane Addressing Scheme</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<style type="text/css"> .tg  {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle} .tg .tg-llyw{background-color:#c0c0c0;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-fymr{font-weight:bold;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} .tg .tg-t5pq{background-color:#cbcefb;color:#000000;border-color:inherit;text-align:left;vertical-align:top} </style><style type="text/css"> .tg  {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle} .tg .tg-llyw{background-color:#c0c0c0;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-fymr{font-weight:bold;border-color:inherit;text-align:left;vertical-align:top} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} .tg .tg-t5pq{background-color:#cbcefb;color:#000000;border-color:inherit;text-align:left;vertical-align:top} </style></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intr__lanesel__cmp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Reduced Lane Addressing Scheme<div class="ingroups"><a class="el" href="group__intr__gpvectorop.html">Vector Operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p><a class="anchor" id="data_selection_cmp"></a> Intrinsics that operate on vectors but don't perform a multiplication follow a reduced or modified lane selection scheme with respect to macs/muls. Such operations are adds, subs, abs, vector compares or vector selections/shuffles. Since those instructions share the initial part of the integer macs/mults datapath, they operate mostly on fixed point numbers. The only exception are float select and shuffles because no arithmetic is performed. Floating point arithmetic is always done in the floating point datapath, more information <a class="el" href="group__intr__gpvectorfpop.html#fpops_explained">here</a>. The next table summarizes the lane selection scheme.</p>
<h3>Legend</h3>
<p><a class="el" href="group__intr__lanesel__cmp.html#regular">RA</a>: Regular selection scheme.</p>
<p><a class="el" href="group__intr__lanesel__cmp.html#regular16">RA_16</a>: Selection scheme used for 16 bits numbers.</p>
<p>na: Not implemented at intrinsics level.</p>
<p>fpdp: Floating point datapath.</p>
<table  class="tg">
<tr>
<th class="tg-lboi"></th><th class="tg-fymr">i32 </th><th class="tg-fymr">i16 </th><th class="tg-fymr">ci32 </th><th class="tg-fymr">ci16 </th><th class="tg-fymr">float </th><th class="tg-fymr">cfloat  </th></tr>
<tr>
<td class="tg-fymr">select/shuffle </td><td class="tg-0pky">RA </td><td class="tg-0pky">RA_16. <br/>
Offsets are relative to 32 bit.<br/>
Start is relative to 16 bit <br/>
but must be multiple of 2.<br/>
Square relative to 16 bits.  </td><td class="tg-0pky">RA. Start and offsets are <br/>
relative to a full ci32 (64bits).  </td><td class="tg-0pky">RA. Real and Imag <br/>
are never split. </td><td class="tg-0pky">RA </td><td class="tg-0pky">RA. Start and offsets are <br/>
relative to full cfp32 (64 bits)  </td></tr>
<tr>
<td class="tg-fymr">add/sub </td><td class="tg-0pky">RA </td><td class="tg-0pky">RA_16. <br/>
Offsets are relative to 32 bit.<br/>
Start is relative to 16 bit <br/>
but must be multiple of 2.<br/>
Square relative to 16 bits.<br/>
 </td><td class="tg-0pky">RA. Start and offsets are <br/>
relative to a full ci32. (64bits). </td><td class="tg-0pky">RA_16 modified. Start is doubled<br/>
to represent a full ci16. (32bits).<br/>
Offset follows the<br/>
RA_16 scheme.<br/>
16 bits permute is disabled.<br/>
 </td><td class="tg-t5pq">fpdp </td><td class="tg-t5pq">fpdp  </td></tr>
<tr>
<td class="tg-fymr">abs </td><td class="tg-0pky">RA </td><td class="tg-0pky">RA_16. <br/>
Offsets are relative to 32 bit.<br/>
Start is relative to 16 bit <br/>
but must be multiple of 2.<br/>
Square relative to 16 bits.<br/>
 </td><td class="tg-llyw">na </td><td class="tg-llyw">na </td><td class="tg-t5pq">fpdp </td><td class="tg-t5pq">fpdp  </td></tr>
<tr>
<td class="tg-fymr">cmp  </td><td class="tg-0pky">RA </td><td class="tg-0pky">RA_16. <br/>
Offsets are relative to 32 bit.<br/>
Start is relative to 16 bit <br/>
but must be multiple of 2.<br/>
Square relative to 16 bits.<br/>
 </td><td class="tg-llyw">na </td><td class="tg-llyw">na </td><td class="tg-t5pq">fpdp </td><td class="tg-t5pq">fpdp  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The bit width of the datatype does not imply directly the selection scheme used i.e. with cint16, where the real and imaginary parts are always moved together and hence the addressing follow a general scheme.</dd></dl>
<p>The basic functionality of these intrinsics performs vector comparisons between data from two buffers, the X and Y buffers, with the other parameters and options allowing flexibility (data selection within the vectors). When a single input buffer is used both X and Y inputs are obtained (with the respective start/offsets/square parameters) from the input buffer.</p>
<h2>Regular Lane Selection Scheme (RA) </h2>
<p><a class="anchor" id="regular"></a> Doing "+1" always mean to advance by one lane in the input buffer. The bit width of the datatype is irrelevant.</p>
<pre class="fragment">for i in 0,rows:
    id[i] = start + offset[i]  %input samples
    out[i] = f( in[id[i]] ) //f can be add, abs, sel ...
</pre><h2>16bits Lane Selection Scheme (RA_16) </h2>
<p><a class="anchor" id="regular16"></a> </p>
<pre class="fragment">//in and out are always treated as 16bits vectors, in[i] and in[i+1] are 16bits apart

// First permutation stage

The concepts are simple:

  - output_lanes = N
  -  N/2 offsets covers N output lanes -&gt; 2*idx
  - This means that each offset is used to move two adjacent values -&gt; perm_idx + 1
  - The parity of the idx selects the perm_idx formula

for (idx = 0 ; idx &lt; N/2; idx += 1)

  if even idx:
    perm_idx = start + 2*offset[idx]

  else //odd idx
    perm_idx = start + 2*offset[idx] + 2*(offset[idx – 1] + 1 )

  data[2*idx  ]  =  input[ perm_idx    ]
  data[2*idx+1]  =  input[ perm_idx + 1] //This is just the adjacent one


// Second permutation stage
for ( idx = 0 ; idx &lt; N; idx += 4)

  // Square is used to permute on a smaller granularity
  output[idx]    =  data[ idx + square [ 0 ] ]
  output[idx+1]  =  data[ idx + square [ 1 ] ]
  output[idx+2]  =  data[ idx + square [ 2 ] ]
  output[idx+3]  =  data[ idx + square [ 3 ] ]
</pre><p>Visually, what happens is the following (example for the first two idx):</p>
<pre class="fragment">- Assume that the even offset selects [c,d] and the odd offsets selets [g,h] (as an example)

  in =    | a | b [ c | d ] e | f [ g | h ] i | l | m |
  f(offset_[idx0])--^               ^
  g(offset_[idx1])------------------|

  Here the functions f,g represents the ones described in the previous pseudocode.

- Then, data is shaped like this
  data = | c | d | g | h | ..... The next ones are selected by idx2, idx3 ...

- The square parameter finalizes the permutations, assume square 0x0123

  out[0] = data[ square[0] ] = data[ 3 ] = h
  out[1] = data[ square[1] ] = data[ 2 ] = g
  out[2] = data[ square[2] ] = data[ 1 ] = d
  out[3] = data[ square[3] ] = data[ 0 ] = c
    ..

- And hence

  out = | h | g | d | c | .....</pre><dl class="section note"><dt>Note</dt><dd>The first permuation only accepts 32bit aligned indexes, hence start must be a multiple of 2.</dd></dl>
<h1>Integer intrinsic naming convention</h1>
<p>The general naming convention for the integer vector intrinsics is shown below:</p>
<pre class="fragment">  {ge|gt|le|lt|max|maxdiff|min}{16|32}
</pre><dl class="section note"><dt>Note</dt><dd>The 16 or 32 in the intrinsic name refers to the number of lanes returned in the output. For the intrinsics under <a class="el" href="group__intr__gpvectorop__bit__cmp.html">Vector Comparison</a> "lane" is a bit in the return word while for all others it is a word of either 16 or 32 bit (according to input size).</dd></dl>
<h1>Floating-point intrinsic naming convention</h1>
<p>The general naming convention for the floating vector compare intrinsics is shown below:</p>
<pre class="fragment">  fp{ge|gt|le|lt|max|min}
</pre><h3>Data offsetting for more than 8 output lanes</h3>
<p>When the output has more than 8 lanes (e.g. 16) there are extra offset parameters. Apart from the usual 'offsets' parameter there is an additional 'offsets_hi' parameter for the extra lanes. This extra parameter allows selecting the data that will be placed into the upper input lanes (8-16) of the multiplier.</p>
<h1>Examples</h1>
<p>Here is an example of Matrix Transpose. Input Matrix: </p>
<div class="fragment"><div class="line">00 01 02 03 04 05 06 07</div>
<div class="line">10 11 12 13 14 15 16 17</div>
<div class="line">20 21 22 23 24 25 26 27</div>
<div class="line">30 31 32 33 34 35 36 37</div>
<div class="line">40 41 42 43 44 45 46 47</div>
<div class="line">50 51 52 53 54 55 56 57</div>
<div class="line">60 61 62 63 64 65 66 67</div>
<div class="line">70 71 72 73 74 75 76 77</div>
</div><!-- fragment --><p> This matrix is loaded in to v64int16 to compute its transpose in 2x2 tiles. </p>
<div class="fragment"><div class="line">00 01     02 03</div>
<div class="line">10 11     12 13</div>
</div><!-- fragment --><p> Note this is real 16-bit so we will use the <a class="el" href="group__intr__lanesel__cmp.html#regular16">real data scheme</a> described above with the select32 intrinsic (<a class="el" href="group__intr__gpvectorop__vec__sel.html">Vector Lane Selection</a>). <br/>
 Our input data is packed as 2x2 tiles in vector registers and we would also like to output in this same format. Input: </p>
<pre class="fragment">Data               : 00 01 10 11 02 03 12 13 04 05 14 15 06 07 16 17 20 21 30 31 22 23 32 33 24 25 34 35 26 27 36 37
Index into v64int16: 0                       8                       16                      24
Data               : 40 41 50 51 42 43 52 53 44 45 54 55 46 47 56 57 60 61 70 71 62 63 72 73 64 65 74 75 66 67 76 77
Index into v64int16: 32                      40                      48                      56
</pre><p>In this case we would use the following indexing for the matrix transpose in “2x2 tiles” </p>
<pre class="fragment">select32 Intrinsic settings
// -- are used to show dont cares
// For offsets,
// xoffset and yoffset are used for first 16 output lanes (out[15:0]).xoffset_hi and yoffset_hi are used for last 16 output lanes (out[31:16])
// 4 bits would chose 2 output lanes since it is 16 bit output lane.
// For even position in xoffset (bits 0:3 or nibble=0, bits 8:11 or nibble=2 etc) each 4 bits value is mutiplied by 2 (nibble*2)
// For odd position in xoffset (bits 4:7 or nibble=1, bits 12:15 or nibble=3 etc) add two adjacent nibbles. Increment it by 1 and mutiply by 2. (ex.(nibble0+nibble1+1)*2
xstart=0,              // Since the 1st element at the output is located at index 0
xsquare=0x3120,
xoffset=0x----0800,    // bits[7:0] would select 00 01 10 11 from input buffer.xsquare would flip these 4 samples to 00 10 01 11.
                       // bits[15:7] would select 20 21 30 31 from input buffer.xsquare would flip these 4 samples to 30 40 31 41.
xoffset_hi=0x----0a02, // bits[7:0] would select 02 03 12 13 from input buffer.xsquare would flip these 4 samples to 02 12 03 13.
                       // bits[15:7] would select 22 23 32 33 from input buffer.xsquare would flip these 4 samples to 22 32 23 33.
ystart=32,             // since ystart is 32, yoffset values would have +32
ysquare=0x3120,
yoffset=0x0800----,    // bits[7:0] would select 40 41 50 51 from input buffer.xsquare would flip these 4 samples to 40 50 41 51.
                       // bits[15:7] would select 60 61 70 71 from input buffer.xsquare would flip these 4 samples to 60 70 61 71.
yoffset_hi=0x0a02----, // bits[7:0] would select 42 43 52 53 from input buffer.xsquare would flip these 4 samples to 42 52 43 53.
                       // bits[15:7] would select 62 63 72 73 from input buffer.xsquare would flip these 4 samples to 62 72 63 73.
select = b11111111000000001111111100000000 // 0 would select lanes computed by xstart,xoffset and xsquare, 1 would select from y
</pre><p>32 outputs in 2x2 tiles: </p>
<div class="fragment"><div class="line">00 10 01 11 20 30 21 31 40 50 41 51 60 70 61 71 02 12 03 13 22 32 23 33 42 52 43 53 62 72 63 73</div>
<div class="line">0                       8                       16                      24</div>
</div><!-- fragment --><p>Constituting the first 4 rows of the transposed matrix w/ 2x2 packing: </p>
<div class="fragment"><div class="line">00 10 20 30 40 50 60 70</div>
<div class="line">01 11 21 31 41 51 61 71</div>
<div class="line">02 12 22 32 42 52 62 72</div>
<div class="line">03 13 23 33 43 53 63 73</div>
</div><!-- fragment --><p>If the user doesn't want 2x2 packing in the output vector as it might not conform to the input requirements of the subsequent kernel, it is possible to generate a “row-major” transpose using a 2nd select32.</p>
<p>32 outputs of the 1st select32 in first example (output in 2x2 tiles format): </p>
<div class="fragment"><div class="line">00 10 01 11 20 30 21 31 40 50 41 51 60 70 61 71 02 12 03 13 22 32 23 33 42 52 43 53 62 72 63 73</div>
<div class="line">0                       8                       16                      24</div>
</div><!-- fragment --><pre class="fragment">select32 settings to change output vector format. Input is 2x2 packed output vector from step1 above.
xstart=0,
xsquare=0x3210,
xoffset=0x15111410,    // bits[7:0] would select 00 10 20 30 from input buffer.xsquare would keep these 4 samples to 00 10 20 30.
                       // bits[15:8] would select 40 50 60 70 from input buffer.xsquare would keep these 4 samples to 40 50 60 70.
                       // bits[31:16] would similarly select samples 01 11 21 31 41 51 61 71
xoffset_hi=0x1d191c18, // bits[7:0] would select 02 12 22 32 from input buffer.xsquare would keep these 4 samples to 02 12 22 32.
                       // bits[15:8] would select 42 52 62 72 from input buffer.xsquare would keep these 4 samples to 42 52 62 72.
ystart= don't care
select = b00000000000000000000000000000000
</pre><p>32 outputs of the 2nd select32 generating the “row-major” transpose: </p>
<div class="fragment"><div class="line">00 10 20 30 40 50 60 70 01 11 21 31 41 51 61 71 02 12 22 32 42 52 62 72 03 13 23 33 43 53 63 73</div>
<div class="line">0                       8                       16                      24</div>
</div><!-- fragment --><p>Which is the first 4 rows of the “row-major” transpose: </p>
<div class="fragment"><div class="line">00 10 20 30 40 50 60 70</div>
<div class="line">01 11 21 31 41 51 61 71</div>
<div class="line">02 12 22 32 42 52 62 72</div>
<div class="line">03 13 23 33 43 53 63 73</div>
</div><!-- fragment --><p> These steps above show how to get first 4 rows of the transposed matrix. it would take one more select32 to get to next 4 rows of the rest of the matrix. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2021 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>


