<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: 32 bit Real x 32 bit Real</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__vect__mult__cmp__32x32.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">32 bit Real x 32 bit Real<div class="ingroups"><a class="el" href="group__vect__mult__cmp____32x32.html">32 bit x 32 bit</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>Vector MAC combined with vector comparisons with 32 bit real by 32 bit real </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga99b64ddbc7d3b6b5322488e1e2b4c2f0"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga99b64ddbc7d3b6b5322488e1e2b4c2f0">lmac4_abs</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga99b64ddbc7d3b6b5322488e1e2b4c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga99b64ddbc7d3b6b5322488e1e2b4c2f0"></a><br/></td></tr>
<tr class="separator:ga99b64ddbc7d3b6b5322488e1e2b4c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4652b40f7048675daf1a025d09a39a"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga2e4652b40f7048675daf1a025d09a39a">lmac4_abs</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga2e4652b40f7048675daf1a025d09a39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga2e4652b40f7048675daf1a025d09a39a"></a><br/></td></tr>
<tr class="separator:ga2e4652b40f7048675daf1a025d09a39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad222b595f67d25e0b4d2c4237b62eacf"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gad222b595f67d25e0b4d2c4237b62eacf">lmac4_max</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gad222b595f67d25e0b4d2c4237b62eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gad222b595f67d25e0b4d2c4237b62eacf"></a><br/></td></tr>
<tr class="separator:gad222b595f67d25e0b4d2c4237b62eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace443e41c9eef6db1734e7231e62727e"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gace443e41c9eef6db1734e7231e62727e">lmac4_max</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gace443e41c9eef6db1734e7231e62727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gace443e41c9eef6db1734e7231e62727e"></a><br/></td></tr>
<tr class="separator:gace443e41c9eef6db1734e7231e62727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4cfdc3c03da4f88717e0f89c76743c"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga2c4cfdc3c03da4f88717e0f89c76743c">lmac4_max</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga2c4cfdc3c03da4f88717e0f89c76743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga2c4cfdc3c03da4f88717e0f89c76743c"></a><br/></td></tr>
<tr class="separator:ga2c4cfdc3c03da4f88717e0f89c76743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf592f460078b585e1c57f6dc8083e814"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaf592f460078b585e1c57f6dc8083e814">lmac4_maxdiff</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf592f460078b585e1c57f6dc8083e814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gaf592f460078b585e1c57f6dc8083e814"></a><br/></td></tr>
<tr class="separator:gaf592f460078b585e1c57f6dc8083e814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9b93a630028ab4654f6a8674f3e4d8"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga4b9b93a630028ab4654f6a8674f3e4d8">lmac4_maxdiff</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga4b9b93a630028ab4654f6a8674f3e4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga4b9b93a630028ab4654f6a8674f3e4d8"></a><br/></td></tr>
<tr class="separator:ga4b9b93a630028ab4654f6a8674f3e4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a90d36eb5c6b2fff6bb470ddf1117ad"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga8a90d36eb5c6b2fff6bb470ddf1117ad">lmac4_maxdiff</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga8a90d36eb5c6b2fff6bb470ddf1117ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga8a90d36eb5c6b2fff6bb470ddf1117ad"></a><br/></td></tr>
<tr class="separator:ga8a90d36eb5c6b2fff6bb470ddf1117ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab606484af87868470a3bc71e4e4a800"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaab606484af87868470a3bc71e4e4a800">lmac4_min</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaab606484af87868470a3bc71e4e4a800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#gaab606484af87868470a3bc71e4e4a800"></a><br/></td></tr>
<tr class="separator:gaab606484af87868470a3bc71e4e4a800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0338217b49077f8d12b7d16cf01a0329"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga0338217b49077f8d12b7d16cf01a0329">lmac4_min</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga0338217b49077f8d12b7d16cf01a0329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0338217b49077f8d12b7d16cf01a0329"></a><br/></td></tr>
<tr class="separator:ga0338217b49077f8d12b7d16cf01a0329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae858859167953f43e7ee4bec366e0cc0"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gae858859167953f43e7ee4bec366e0cc0">lmac4_min</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gae858859167953f43e7ee4bec366e0cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gae858859167953f43e7ee4bec366e0cc0"></a><br/></td></tr>
<tr class="separator:gae858859167953f43e7ee4bec366e0cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27ae657d0fb25bec4f2e87544da50d2"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gad27ae657d0fb25bec4f2e87544da50d2">lmac8_abs</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gad27ae657d0fb25bec4f2e87544da50d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gad27ae657d0fb25bec4f2e87544da50d2"></a><br/></td></tr>
<tr class="separator:gad27ae657d0fb25bec4f2e87544da50d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4c66af5f7d5519200d2a0756d58562"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gabf4c66af5f7d5519200d2a0756d58562">lmac8_abs</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gabf4c66af5f7d5519200d2a0756d58562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gabf4c66af5f7d5519200d2a0756d58562"></a><br/></td></tr>
<tr class="separator:gabf4c66af5f7d5519200d2a0756d58562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b84d7a1dda53e4f19c7435e8a5714ad"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga6b84d7a1dda53e4f19c7435e8a5714ad">lmac8_max</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga6b84d7a1dda53e4f19c7435e8a5714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga6b84d7a1dda53e4f19c7435e8a5714ad"></a><br/></td></tr>
<tr class="separator:ga6b84d7a1dda53e4f19c7435e8a5714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372a428eec3d42ae4ac51bf206ae5248"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga372a428eec3d42ae4ac51bf206ae5248">lmac8_max</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga372a428eec3d42ae4ac51bf206ae5248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga372a428eec3d42ae4ac51bf206ae5248"></a><br/></td></tr>
<tr class="separator:ga372a428eec3d42ae4ac51bf206ae5248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c9b78406e53d800ae5ebc3abcd408e"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gab2c9b78406e53d800ae5ebc3abcd408e">lmac8_max</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gab2c9b78406e53d800ae5ebc3abcd408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gab2c9b78406e53d800ae5ebc3abcd408e"></a><br/></td></tr>
<tr class="separator:gab2c9b78406e53d800ae5ebc3abcd408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce1ccc17182575fca42e02101ac8dc5"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga8ce1ccc17182575fca42e02101ac8dc5">lmac8_maxdiff</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga8ce1ccc17182575fca42e02101ac8dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#ga8ce1ccc17182575fca42e02101ac8dc5"></a><br/></td></tr>
<tr class="separator:ga8ce1ccc17182575fca42e02101ac8dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e68eab8d9904ba2885b353ce0d1bad"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga06e68eab8d9904ba2885b353ce0d1bad">lmac8_maxdiff</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga06e68eab8d9904ba2885b353ce0d1bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga06e68eab8d9904ba2885b353ce0d1bad"></a><br/></td></tr>
<tr class="separator:ga06e68eab8d9904ba2885b353ce0d1bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65dbaa9709673e6265ea90b6a0190e10"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga65dbaa9709673e6265ea90b6a0190e10">lmac8_maxdiff</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga65dbaa9709673e6265ea90b6a0190e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga65dbaa9709673e6265ea90b6a0190e10"></a><br/></td></tr>
<tr class="separator:ga65dbaa9709673e6265ea90b6a0190e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3cfabaf5bd71610717b7459d0fa2d4"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga8f3cfabaf5bd71610717b7459d0fa2d4">lmac8_min</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga8f3cfabaf5bd71610717b7459d0fa2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga8f3cfabaf5bd71610717b7459d0fa2d4"></a><br/></td></tr>
<tr class="separator:ga8f3cfabaf5bd71610717b7459d0fa2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf939ac8fa048d4d1f0f243184fb22da9"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaf939ac8fa048d4d1f0f243184fb22da9">lmac8_min</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaf939ac8fa048d4d1f0f243184fb22da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf939ac8fa048d4d1f0f243184fb22da9"></a><br/></td></tr>
<tr class="separator:gaf939ac8fa048d4d1f0f243184fb22da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabffba830737567e8e1608839d20e92aa"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gabffba830737567e8e1608839d20e92aa">lmac8_min</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gabffba830737567e8e1608839d20e92aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gabffba830737567e8e1608839d20e92aa"></a><br/></td></tr>
<tr class="separator:gabffba830737567e8e1608839d20e92aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c65f447ccb2af611a3f39f1715314b"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga59c65f447ccb2af611a3f39f1715314b">lmsc4_abs</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga59c65f447ccb2af611a3f39f1715314b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga59c65f447ccb2af611a3f39f1715314b"></a><br/></td></tr>
<tr class="separator:ga59c65f447ccb2af611a3f39f1715314b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68559403eca3b5cf70431675ba103428"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga68559403eca3b5cf70431675ba103428">lmsc4_abs</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga68559403eca3b5cf70431675ba103428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga68559403eca3b5cf70431675ba103428"></a><br/></td></tr>
<tr class="separator:ga68559403eca3b5cf70431675ba103428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3968f94b3b5631f8cf2f745c2dd2c1b5"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga3968f94b3b5631f8cf2f745c2dd2c1b5">lmsc4_max</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga3968f94b3b5631f8cf2f745c2dd2c1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga3968f94b3b5631f8cf2f745c2dd2c1b5"></a><br/></td></tr>
<tr class="separator:ga3968f94b3b5631f8cf2f745c2dd2c1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e632f453dd0caec0e865a7306e2211"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga84e632f453dd0caec0e865a7306e2211">lmsc4_max</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga84e632f453dd0caec0e865a7306e2211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga84e632f453dd0caec0e865a7306e2211"></a><br/></td></tr>
<tr class="separator:ga84e632f453dd0caec0e865a7306e2211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace543178b9feb45ad1f71bcd070369f1"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gace543178b9feb45ad1f71bcd070369f1">lmsc4_max</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gace543178b9feb45ad1f71bcd070369f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gace543178b9feb45ad1f71bcd070369f1"></a><br/></td></tr>
<tr class="separator:gace543178b9feb45ad1f71bcd070369f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a9403b6e415b5406d41680cf123f58"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaf5a9403b6e415b5406d41680cf123f58">lmsc4_maxdiff</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf5a9403b6e415b5406d41680cf123f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gaf5a9403b6e415b5406d41680cf123f58"></a><br/></td></tr>
<tr class="separator:gaf5a9403b6e415b5406d41680cf123f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6040c1e048c961aec892a5b6cfe54d49"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga6040c1e048c961aec892a5b6cfe54d49">lmsc4_maxdiff</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga6040c1e048c961aec892a5b6cfe54d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga6040c1e048c961aec892a5b6cfe54d49"></a><br/></td></tr>
<tr class="separator:ga6040c1e048c961aec892a5b6cfe54d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f16aba8e57105d6d1446c793d90dcf"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga01f16aba8e57105d6d1446c793d90dcf">lmsc4_maxdiff</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga01f16aba8e57105d6d1446c793d90dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga01f16aba8e57105d6d1446c793d90dcf"></a><br/></td></tr>
<tr class="separator:ga01f16aba8e57105d6d1446c793d90dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e402b59abd39a0df231a7c7e54fa61d"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga9e402b59abd39a0df231a7c7e54fa61d">lmsc4_min</a> (v4acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga9e402b59abd39a0df231a7c7e54fa61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga9e402b59abd39a0df231a7c7e54fa61d"></a><br/></td></tr>
<tr class="separator:ga9e402b59abd39a0df231a7c7e54fa61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9853ca255f6f467e3b0f4d207b0458"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga4e9853ca255f6f467e3b0f4d207b0458">lmsc4_min</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga4e9853ca255f6f467e3b0f4d207b0458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga4e9853ca255f6f467e3b0f4d207b0458"></a><br/></td></tr>
<tr class="separator:ga4e9853ca255f6f467e3b0f4d207b0458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad766d01812ffe3df5639dadd567ca062"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gad766d01812ffe3df5639dadd567ca062">lmsc4_min</a> (v4acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gad766d01812ffe3df5639dadd567ca062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gad766d01812ffe3df5639dadd567ca062"></a><br/></td></tr>
<tr class="separator:gad766d01812ffe3df5639dadd567ca062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa954f83c3f364a579e9d57fd96d69cf2"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaa954f83c3f364a579e9d57fd96d69cf2">lmsc8_abs</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaa954f83c3f364a579e9d57fd96d69cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gaa954f83c3f364a579e9d57fd96d69cf2"></a><br/></td></tr>
<tr class="separator:gaa954f83c3f364a579e9d57fd96d69cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe93667c62dfb7fb32ff506e7aa1ec0"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaffe93667c62dfb7fb32ff506e7aa1ec0">lmsc8_abs</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaffe93667c62dfb7fb32ff506e7aa1ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gaffe93667c62dfb7fb32ff506e7aa1ec0"></a><br/></td></tr>
<tr class="separator:gaffe93667c62dfb7fb32ff506e7aa1ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b611e6afce4f615942e920ec9dfc12d"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga5b611e6afce4f615942e920ec9dfc12d">lmsc8_max</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga5b611e6afce4f615942e920ec9dfc12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga5b611e6afce4f615942e920ec9dfc12d"></a><br/></td></tr>
<tr class="separator:ga5b611e6afce4f615942e920ec9dfc12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga101c47f6f712634c76c8e12cb75ef525"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga101c47f6f712634c76c8e12cb75ef525">lmsc8_max</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga101c47f6f712634c76c8e12cb75ef525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga101c47f6f712634c76c8e12cb75ef525"></a><br/></td></tr>
<tr class="separator:ga101c47f6f712634c76c8e12cb75ef525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b2b66d555006c065226450ca4ffc95"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gae2b2b66d555006c065226450ca4ffc95">lmsc8_max</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gae2b2b66d555006c065226450ca4ffc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gae2b2b66d555006c065226450ca4ffc95"></a><br/></td></tr>
<tr class="separator:gae2b2b66d555006c065226450ca4ffc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d9f492997942cf119d33b075cb6a3f"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gad2d9f492997942cf119d33b075cb6a3f">lmsc8_maxdiff</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gad2d9f492997942cf119d33b075cb6a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gad2d9f492997942cf119d33b075cb6a3f"></a><br/></td></tr>
<tr class="separator:gad2d9f492997942cf119d33b075cb6a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92436ebf44602627fc4aee31afa0e8ed"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga92436ebf44602627fc4aee31afa0e8ed">lmsc8_maxdiff</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga92436ebf44602627fc4aee31afa0e8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga92436ebf44602627fc4aee31afa0e8ed"></a><br/></td></tr>
<tr class="separator:ga92436ebf44602627fc4aee31afa0e8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ff1f82668695581ff8be055351b752"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaa2ff1f82668695581ff8be055351b752">lmsc8_maxdiff</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaa2ff1f82668695581ff8be055351b752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaa2ff1f82668695581ff8be055351b752"></a><br/></td></tr>
<tr class="separator:gaa2ff1f82668695581ff8be055351b752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9316169e8b051d5b28226622bcf971"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gabb9316169e8b051d5b28226622bcf971">lmsc8_min</a> (v8acc80 acc, v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gabb9316169e8b051d5b28226622bcf971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#gabb9316169e8b051d5b28226622bcf971"></a><br/></td></tr>
<tr class="separator:gabb9316169e8b051d5b28226622bcf971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930a183176c1ce09344cfd9b6a6b41ba"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga930a183176c1ce09344cfd9b6a6b41ba">lmsc8_min</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga930a183176c1ce09344cfd9b6a6b41ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga930a183176c1ce09344cfd9b6a6b41ba"></a><br/></td></tr>
<tr class="separator:ga930a183176c1ce09344cfd9b6a6b41ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef36ae2df684237134fdc3d892ece0f"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga0ef36ae2df684237134fdc3d892ece0f">lmsc8_min</a> (v8acc80 acc, v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga0ef36ae2df684237134fdc3d892ece0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0ef36ae2df684237134fdc3d892ece0f"></a><br/></td></tr>
<tr class="separator:ga0ef36ae2df684237134fdc3d892ece0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a6bf858bb6ff4098e38e1b7cf281a1"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga10a6bf858bb6ff4098e38e1b7cf281a1">lmul4_abs</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga10a6bf858bb6ff4098e38e1b7cf281a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga10a6bf858bb6ff4098e38e1b7cf281a1"></a><br/></td></tr>
<tr class="separator:ga10a6bf858bb6ff4098e38e1b7cf281a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae50bc7a9e544a24493840768c78c9aae"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gae50bc7a9e544a24493840768c78c9aae">lmul4_abs</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gae50bc7a9e544a24493840768c78c9aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gae50bc7a9e544a24493840768c78c9aae"></a><br/></td></tr>
<tr class="separator:gae50bc7a9e544a24493840768c78c9aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54c73f1106f8211ee8db6aa73a1ea99"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gae54c73f1106f8211ee8db6aa73a1ea99">lmul4_max</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gae54c73f1106f8211ee8db6aa73a1ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gae54c73f1106f8211ee8db6aa73a1ea99"></a><br/></td></tr>
<tr class="separator:gae54c73f1106f8211ee8db6aa73a1ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e7c460bf8ea2b909cf1656ca55e8440"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga1e7c460bf8ea2b909cf1656ca55e8440">lmul4_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga1e7c460bf8ea2b909cf1656ca55e8440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga1e7c460bf8ea2b909cf1656ca55e8440"></a><br/></td></tr>
<tr class="separator:ga1e7c460bf8ea2b909cf1656ca55e8440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395bf341353eeb97ee7ff9698fe0856"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gac395bf341353eeb97ee7ff9698fe0856">lmul4_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gac395bf341353eeb97ee7ff9698fe0856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gac395bf341353eeb97ee7ff9698fe0856"></a><br/></td></tr>
<tr class="separator:gac395bf341353eeb97ee7ff9698fe0856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a3eb6370c51019c9a7d8c8306e3570"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga27a3eb6370c51019c9a7d8c8306e3570">lmul4_maxdiff</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga27a3eb6370c51019c9a7d8c8306e3570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#ga27a3eb6370c51019c9a7d8c8306e3570"></a><br/></td></tr>
<tr class="separator:ga27a3eb6370c51019c9a7d8c8306e3570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b492d526f8f55b2721d89b9b04c816c"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga6b492d526f8f55b2721d89b9b04c816c">lmul4_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga6b492d526f8f55b2721d89b9b04c816c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga6b492d526f8f55b2721d89b9b04c816c"></a><br/></td></tr>
<tr class="separator:ga6b492d526f8f55b2721d89b9b04c816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d235b9a142329318c9514faafb895d"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga88d235b9a142329318c9514faafb895d">lmul4_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga88d235b9a142329318c9514faafb895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga88d235b9a142329318c9514faafb895d"></a><br/></td></tr>
<tr class="separator:ga88d235b9a142329318c9514faafb895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977bbddbfc0d80a7ba1fcb802f6b2ce5"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga977bbddbfc0d80a7ba1fcb802f6b2ce5">lmul4_min</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga977bbddbfc0d80a7ba1fcb802f6b2ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga977bbddbfc0d80a7ba1fcb802f6b2ce5"></a><br/></td></tr>
<tr class="separator:ga977bbddbfc0d80a7ba1fcb802f6b2ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf6f09b455b8fc9c2a3af657d2fc460e"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gabf6f09b455b8fc9c2a3af657d2fc460e">lmul4_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gabf6f09b455b8fc9c2a3af657d2fc460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gabf6f09b455b8fc9c2a3af657d2fc460e"></a><br/></td></tr>
<tr class="separator:gabf6f09b455b8fc9c2a3af657d2fc460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a01d4c451f51b9c8b1561b5426149a"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga65a01d4c451f51b9c8b1561b5426149a">lmul4_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga65a01d4c451f51b9c8b1561b5426149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga65a01d4c451f51b9c8b1561b5426149a"></a><br/></td></tr>
<tr class="separator:ga65a01d4c451f51b9c8b1561b5426149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79a0997fd9cf6dce38e26d1a1de32f8"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gac79a0997fd9cf6dce38e26d1a1de32f8">lmul8_abs</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gac79a0997fd9cf6dce38e26d1a1de32f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gac79a0997fd9cf6dce38e26d1a1de32f8"></a><br/></td></tr>
<tr class="separator:gac79a0997fd9cf6dce38e26d1a1de32f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf444e82e0423a36f33182b2ceef725fe"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaf444e82e0423a36f33182b2ceef725fe">lmul8_abs</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaf444e82e0423a36f33182b2ceef725fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gaf444e82e0423a36f33182b2ceef725fe"></a><br/></td></tr>
<tr class="separator:gaf444e82e0423a36f33182b2ceef725fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53d2dc1171a8997687f84bd1450f1fd"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gae53d2dc1171a8997687f84bd1450f1fd">lmul8_max</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gae53d2dc1171a8997687f84bd1450f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gae53d2dc1171a8997687f84bd1450f1fd"></a><br/></td></tr>
<tr class="separator:gae53d2dc1171a8997687f84bd1450f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9a7deecf27e627d897fea574db12f4"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga6c9a7deecf27e627d897fea574db12f4">lmul8_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga6c9a7deecf27e627d897fea574db12f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga6c9a7deecf27e627d897fea574db12f4"></a><br/></td></tr>
<tr class="separator:ga6c9a7deecf27e627d897fea574db12f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d95b4476db0a043de13fab680deb9af"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga0d95b4476db0a043de13fab680deb9af">lmul8_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga0d95b4476db0a043de13fab680deb9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0d95b4476db0a043de13fab680deb9af"></a><br/></td></tr>
<tr class="separator:ga0d95b4476db0a043de13fab680deb9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee197b91084064f540577a82c59722c"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga8ee197b91084064f540577a82c59722c">lmul8_maxdiff</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga8ee197b91084064f540577a82c59722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#ga8ee197b91084064f540577a82c59722c"></a><br/></td></tr>
<tr class="separator:ga8ee197b91084064f540577a82c59722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23edba66bafcf1f4cd50d1aff8433cf"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gae23edba66bafcf1f4cd50d1aff8433cf">lmul8_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gae23edba66bafcf1f4cd50d1aff8433cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gae23edba66bafcf1f4cd50d1aff8433cf"></a><br/></td></tr>
<tr class="separator:gae23edba66bafcf1f4cd50d1aff8433cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8fbf29083d9711a3c90ca6c1dc5f34f"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaf8fbf29083d9711a3c90ca6c1dc5f34f">lmul8_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaf8fbf29083d9711a3c90ca6c1dc5f34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf8fbf29083d9711a3c90ca6c1dc5f34f"></a><br/></td></tr>
<tr class="separator:gaf8fbf29083d9711a3c90ca6c1dc5f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558a895a3229b0dd7397645b823c9d29"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga558a895a3229b0dd7397645b823c9d29">lmul8_min</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga558a895a3229b0dd7397645b823c9d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga558a895a3229b0dd7397645b823c9d29"></a><br/></td></tr>
<tr class="separator:ga558a895a3229b0dd7397645b823c9d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b96e094e102aeb245391093526d806c"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga3b96e094e102aeb245391093526d806c">lmul8_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga3b96e094e102aeb245391093526d806c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga3b96e094e102aeb245391093526d806c"></a><br/></td></tr>
<tr class="separator:ga3b96e094e102aeb245391093526d806c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c3a737e98d0096831a356b6895b0d6"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga21c3a737e98d0096831a356b6895b0d6">lmul8_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga21c3a737e98d0096831a356b6895b0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga21c3a737e98d0096831a356b6895b0d6"></a><br/></td></tr>
<tr class="separator:ga21c3a737e98d0096831a356b6895b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c8f41594b697e6048190b2c68ee6d3"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga61c8f41594b697e6048190b2c68ee6d3">lnegmul4_abs</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga61c8f41594b697e6048190b2c68ee6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga61c8f41594b697e6048190b2c68ee6d3"></a><br/></td></tr>
<tr class="separator:ga61c8f41594b697e6048190b2c68ee6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6754320fa8fb83d0eac1abd8faebe7"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gada6754320fa8fb83d0eac1abd8faebe7">lnegmul4_abs</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gada6754320fa8fb83d0eac1abd8faebe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gada6754320fa8fb83d0eac1abd8faebe7"></a><br/></td></tr>
<tr class="separator:gada6754320fa8fb83d0eac1abd8faebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbf2f1aff18392b1edd88d24f26bdb2"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga5fbf2f1aff18392b1edd88d24f26bdb2">lnegmul4_max</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga5fbf2f1aff18392b1edd88d24f26bdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga5fbf2f1aff18392b1edd88d24f26bdb2"></a><br/></td></tr>
<tr class="separator:ga5fbf2f1aff18392b1edd88d24f26bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216450e19951ed944554a34c596f3e9d"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga216450e19951ed944554a34c596f3e9d">lnegmul4_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga216450e19951ed944554a34c596f3e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga216450e19951ed944554a34c596f3e9d"></a><br/></td></tr>
<tr class="separator:ga216450e19951ed944554a34c596f3e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c708c202744729f25e087233da95745"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga9c708c202744729f25e087233da95745">lnegmul4_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga9c708c202744729f25e087233da95745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga9c708c202744729f25e087233da95745"></a><br/></td></tr>
<tr class="separator:ga9c708c202744729f25e087233da95745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab201ced311e5582c5038285afb662dfe"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gab201ced311e5582c5038285afb662dfe">lnegmul4_maxdiff</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gab201ced311e5582c5038285afb662dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gab201ced311e5582c5038285afb662dfe"></a><br/></td></tr>
<tr class="separator:gab201ced311e5582c5038285afb662dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63463c2037bbdeffff71b7552499c5ef"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga63463c2037bbdeffff71b7552499c5ef">lnegmul4_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga63463c2037bbdeffff71b7552499c5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga63463c2037bbdeffff71b7552499c5ef"></a><br/></td></tr>
<tr class="separator:ga63463c2037bbdeffff71b7552499c5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c6b83f48a5fca0f001117648559cec"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga38c6b83f48a5fca0f001117648559cec">lnegmul4_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga38c6b83f48a5fca0f001117648559cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga38c6b83f48a5fca0f001117648559cec"></a><br/></td></tr>
<tr class="separator:ga38c6b83f48a5fca0f001117648559cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296ec180c0e7e5222bf5904e5b7a9f53"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga296ec180c0e7e5222bf5904e5b7a9f53">lnegmul4_min</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga296ec180c0e7e5222bf5904e5b7a9f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga296ec180c0e7e5222bf5904e5b7a9f53"></a><br/></td></tr>
<tr class="separator:ga296ec180c0e7e5222bf5904e5b7a9f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6631c210f401102913484029fa356cbb"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga6631c210f401102913484029fa356cbb">lnegmul4_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga6631c210f401102913484029fa356cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga6631c210f401102913484029fa356cbb"></a><br/></td></tr>
<tr class="separator:ga6631c210f401102913484029fa356cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a200807b64d2cf7a91e87be9e3fbfd0"><td class="memItemLeft" align="right" valign="top">v4acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga5a200807b64d2cf7a91e87be9e3fbfd0">lnegmul4_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga5a200807b64d2cf7a91e87be9e3fbfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga5a200807b64d2cf7a91e87be9e3fbfd0"></a><br/></td></tr>
<tr class="separator:ga5a200807b64d2cf7a91e87be9e3fbfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bc86cc622fa971c2059f44abe01647"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga46bc86cc622fa971c2059f44abe01647">lnegmul8_abs</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga46bc86cc622fa971c2059f44abe01647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga46bc86cc622fa971c2059f44abe01647"></a><br/></td></tr>
<tr class="separator:ga46bc86cc622fa971c2059f44abe01647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad0c666115e92d977596079d544910d"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gacad0c666115e92d977596079d544910d">lnegmul8_abs</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gacad0c666115e92d977596079d544910d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gacad0c666115e92d977596079d544910d"></a><br/></td></tr>
<tr class="separator:gacad0c666115e92d977596079d544910d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bffdffd69e7a79827ae0174d000e5e"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga11bffdffd69e7a79827ae0174d000e5e">lnegmul8_max</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga11bffdffd69e7a79827ae0174d000e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga11bffdffd69e7a79827ae0174d000e5e"></a><br/></td></tr>
<tr class="separator:ga11bffdffd69e7a79827ae0174d000e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef6f82d5f353c05e5d957308ef13229"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga1ef6f82d5f353c05e5d957308ef13229">lnegmul8_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga1ef6f82d5f353c05e5d957308ef13229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga1ef6f82d5f353c05e5d957308ef13229"></a><br/></td></tr>
<tr class="separator:ga1ef6f82d5f353c05e5d957308ef13229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga099d997d63d0df4bb9d217acbf4c7983"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga099d997d63d0df4bb9d217acbf4c7983">lnegmul8_max</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga099d997d63d0df4bb9d217acbf4c7983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga099d997d63d0df4bb9d217acbf4c7983"></a><br/></td></tr>
<tr class="separator:ga099d997d63d0df4bb9d217acbf4c7983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa91634daa5b4dff54902b93b6641fbf4"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaa91634daa5b4dff54902b93b6641fbf4">lnegmul8_maxdiff</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaa91634daa5b4dff54902b93b6641fbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gaa91634daa5b4dff54902b93b6641fbf4"></a><br/></td></tr>
<tr class="separator:gaa91634daa5b4dff54902b93b6641fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8201274b4879251aeabbe317e152fed6"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga8201274b4879251aeabbe317e152fed6">lnegmul8_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga8201274b4879251aeabbe317e152fed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga8201274b4879251aeabbe317e152fed6"></a><br/></td></tr>
<tr class="separator:ga8201274b4879251aeabbe317e152fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74ee1f970c7323f2edaecf6a74cf315"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#gaf74ee1f970c7323f2edaecf6a74cf315">lnegmul8_maxdiff</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:gaf74ee1f970c7323f2edaecf6a74cf315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf74ee1f970c7323f2edaecf6a74cf315"></a><br/></td></tr>
<tr class="separator:gaf74ee1f970c7323f2edaecf6a74cf315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e9224d00011a17ca8fb18991a9e4a6"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga17e9224d00011a17ca8fb18991a9e4a6">lnegmul8_min</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga17e9224d00011a17ca8fb18991a9e4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga17e9224d00011a17ca8fb18991a9e4a6"></a><br/></td></tr>
<tr class="separator:ga17e9224d00011a17ca8fb18991a9e4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b4588820c80b7a74457a645bcf180a"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga90b4588820c80b7a74457a645bcf180a">lnegmul8_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga90b4588820c80b7a74457a645bcf180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga90b4588820c80b7a74457a645bcf180a"></a><br/></td></tr>
<tr class="separator:ga90b4588820c80b7a74457a645bcf180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga153a54ae8f7912e796f29a7f89c05556"><td class="memItemLeft" align="right" valign="top">v8acc80&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__32x32.html#ga153a54ae8f7912e796f29a7f89c05556">lnegmul8_min</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v16int32 ybuff, int ystart, v8int32 zbuff, int zstart, unsigned int zoffsets)</td></tr>
<tr class="memdesc:ga153a54ae8f7912e796f29a7f89c05556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga153a54ae8f7912e796f29a7f89c05556"></a><br/></td></tr>
<tr class="separator:ga153a54ae8f7912e796f29a7f89c05556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga99b64ddbc7d3b6b5322488e1e2b4c2f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_abs </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmac4_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 += z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 += z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 += z30*abs(x30) + z31*abs(x31)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e4652b40f7048675daf1a025d09a39a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_abs </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 += z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 += z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 += z30*abs(x30) + z31*abs(x31)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad222b595f67d25e0b4d2c4237b62eacf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_max </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmac4_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gace443e41c9eef6db1734e7231e62727e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_max </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2c4cfdc3c03da4f88717e0f89c76743c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_max </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf592f460078b585e1c57f6dc8083e814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmac4_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4b9b93a630028ab4654f6a8674f3e4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8a90d36eb5c6b2fff6bb470ddf1117ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaab606484af87868470a3bc71e4e4a800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_min </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmac4_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0338217b49077f8d12b7d16cf01a0329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_min </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae858859167953f43e7ee4bec366e0cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmac4_min </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmac4_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad27ae657d0fb25bec4f2e87544da50d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmac8_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00)</div>
<div class="line">acc1 += z10*abs(x10)</div>
<div class="line">acc2 += z20*abs(x20)</div>
<div class="line">acc3 += z30*abs(x30)</div>
<div class="line">acc4 += z40*abs(x40)</div>
<div class="line">acc5 += z50*abs(x50)</div>
<div class="line">acc6 += z60*abs(x60)</div>
<div class="line">acc7 += z70*abs(x70)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabf4c66af5f7d5519200d2a0756d58562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00)</div>
<div class="line">acc1 += z10*abs(x10)</div>
<div class="line">acc2 += z20*abs(x20)</div>
<div class="line">acc3 += z30*abs(x30)</div>
<div class="line">acc4 += z40*abs(x40)</div>
<div class="line">acc5 += z50*abs(x50)</div>
<div class="line">acc6 += z60*abs(x60)</div>
<div class="line">acc7 += z70*abs(x70)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6b84d7a1dda53e4f19c7435e8a5714ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmac8_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00))</div>
<div class="line">acc1 += z10*(max(x10 , y10))</div>
<div class="line">acc2 += z20*(max(x20 , y20))</div>
<div class="line">acc3 += z30*(max(x30 , y30))</div>
<div class="line">acc4 += z40*(max(x40 , y40))</div>
<div class="line">acc5 += z50*(max(x50 , y50))</div>
<div class="line">acc6 += z60*(max(x60 , y60))</div>
<div class="line">acc7 += z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga372a428eec3d42ae4ac51bf206ae5248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00))</div>
<div class="line">acc1 += z10*(max(x10 , y10))</div>
<div class="line">acc2 += z20*(max(x20 , y20))</div>
<div class="line">acc3 += z30*(max(x30 , y30))</div>
<div class="line">acc4 += z40*(max(x40 , y40))</div>
<div class="line">acc5 += z50*(max(x50 , y50))</div>
<div class="line">acc6 += z60*(max(x60 , y60))</div>
<div class="line">acc7 += z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab2c9b78406e53d800ae5ebc3abcd408e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00))</div>
<div class="line">acc1 += z10*(max(x10 , y10))</div>
<div class="line">acc2 += z20*(max(x20 , y20))</div>
<div class="line">acc3 += z30*(max(x30 , y30))</div>
<div class="line">acc4 += z40*(max(x40 , y40))</div>
<div class="line">acc5 += z50*(max(x50 , y50))</div>
<div class="line">acc6 += z60*(max(x60 , y60))</div>
<div class="line">acc7 += z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8ce1ccc17182575fca42e02101ac8dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmac8_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga06e68eab8d9904ba2885b353ce0d1bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga65dbaa9709673e6265ea90b6a0190e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8f3cfabaf5bd71610717b7459d0fa2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmac8_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00))</div>
<div class="line">acc1 += z10*(min(x10 , y10))</div>
<div class="line">acc2 += z20*(min(x20 , y20))</div>
<div class="line">acc3 += z30*(min(x30 , y30))</div>
<div class="line">acc4 += z40*(min(x40 , y40))</div>
<div class="line">acc5 += z50*(min(x50 , y50))</div>
<div class="line">acc6 += z60*(min(x60 , y60))</div>
<div class="line">acc7 += z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf939ac8fa048d4d1f0f243184fb22da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00))</div>
<div class="line">acc1 += z10*(min(x10 , y10))</div>
<div class="line">acc2 += z20*(min(x20 , y20))</div>
<div class="line">acc3 += z30*(min(x30 , y30))</div>
<div class="line">acc4 += z40*(min(x40 , y40))</div>
<div class="line">acc5 += z50*(min(x50 , y50))</div>
<div class="line">acc6 += z60*(min(x60 , y60))</div>
<div class="line">acc7 += z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabffba830737567e8e1608839d20e92aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmac8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmac8_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00))</div>
<div class="line">acc1 += z10*(min(x10 , y10))</div>
<div class="line">acc2 += z20*(min(x20 , y20))</div>
<div class="line">acc3 += z30*(min(x30 , y30))</div>
<div class="line">acc4 += z40*(min(x40 , y40))</div>
<div class="line">acc5 += z50*(min(x50 , y50))</div>
<div class="line">acc6 += z60*(min(x60 , y60))</div>
<div class="line">acc7 += z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga59c65f447ccb2af611a3f39f1715314b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_abs </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmsc4_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 -= z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 -= z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 -= z30*abs(x30) + z31*abs(x31)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga68559403eca3b5cf70431675ba103428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_abs </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 -= z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 -= z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 -= z30*abs(x30) + z31*abs(x31)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3968f94b3b5631f8cf2f745c2dd2c1b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_max </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmsc4_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga84e632f453dd0caec0e865a7306e2211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_max </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gace543178b9feb45ad1f71bcd070369f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_max </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf5a9403b6e415b5406d41680cf123f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmsc4_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6040c1e048c961aec892a5b6cfe54d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga01f16aba8e57105d6d1446c793d90dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9e402b59abd39a0df231a7c7e54fa61d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_min </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmsc4_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4e9853ca255f6f467e3b0f4d207b0458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_min </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad766d01812ffe3df5639dadd567ca062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmsc4_min </td>
          <td>(</td>
          <td class="paramtype">v4acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmsc4_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v4acc80 </td><td>Incoming accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa954f83c3f364a579e9d57fd96d69cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmsc8_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00)</div>
<div class="line">acc1 -= z10*abs(x10)</div>
<div class="line">acc2 -= z20*abs(x20)</div>
<div class="line">acc3 -= z30*abs(x30)</div>
<div class="line">acc4 -= z40*abs(x40)</div>
<div class="line">acc5 -= z50*abs(x50)</div>
<div class="line">acc6 -= z60*abs(x60)</div>
<div class="line">acc7 -= z70*abs(x70)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaffe93667c62dfb7fb32ff506e7aa1ec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00)</div>
<div class="line">acc1 -= z10*abs(x10)</div>
<div class="line">acc2 -= z20*abs(x20)</div>
<div class="line">acc3 -= z30*abs(x30)</div>
<div class="line">acc4 -= z40*abs(x40)</div>
<div class="line">acc5 -= z50*abs(x50)</div>
<div class="line">acc6 -= z60*abs(x60)</div>
<div class="line">acc7 -= z70*abs(x70)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5b611e6afce4f615942e920ec9dfc12d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmsc8_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00))</div>
<div class="line">acc1 -= z10*(max(x10 , y10))</div>
<div class="line">acc2 -= z20*(max(x20 , y20))</div>
<div class="line">acc3 -= z30*(max(x30 , y30))</div>
<div class="line">acc4 -= z40*(max(x40 , y40))</div>
<div class="line">acc5 -= z50*(max(x50 , y50))</div>
<div class="line">acc6 -= z60*(max(x60 , y60))</div>
<div class="line">acc7 -= z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga101c47f6f712634c76c8e12cb75ef525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00))</div>
<div class="line">acc1 -= z10*(max(x10 , y10))</div>
<div class="line">acc2 -= z20*(max(x20 , y20))</div>
<div class="line">acc3 -= z30*(max(x30 , y30))</div>
<div class="line">acc4 -= z40*(max(x40 , y40))</div>
<div class="line">acc5 -= z50*(max(x50 , y50))</div>
<div class="line">acc6 -= z60*(max(x60 , y60))</div>
<div class="line">acc7 -= z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae2b2b66d555006c065226450ca4ffc95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00))</div>
<div class="line">acc1 -= z10*(max(x10 , y10))</div>
<div class="line">acc2 -= z20*(max(x20 , y20))</div>
<div class="line">acc3 -= z30*(max(x30 , y30))</div>
<div class="line">acc4 -= z40*(max(x40 , y40))</div>
<div class="line">acc5 -= z50*(max(x50 , y50))</div>
<div class="line">acc6 -= z60*(max(x60 , y60))</div>
<div class="line">acc7 -= z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad2d9f492997942cf119d33b075cb6a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmsc8_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga92436ebf44602627fc4aee31afa0e8ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa2ff1f82668695581ff8be055351b752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabb9316169e8b051d5b28226622bcf971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmsc8_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00))</div>
<div class="line">acc1 -= z10*(min(x10 , y10))</div>
<div class="line">acc2 -= z20*(min(x20 , y20))</div>
<div class="line">acc3 -= z30*(min(x30 , y30))</div>
<div class="line">acc4 -= z40*(min(x40 , y40))</div>
<div class="line">acc5 -= z50*(min(x50 , y50))</div>
<div class="line">acc6 -= z60*(min(x60 , y60))</div>
<div class="line">acc7 -= z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga930a183176c1ce09344cfd9b6a6b41ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00))</div>
<div class="line">acc1 -= z10*(min(x10 , y10))</div>
<div class="line">acc2 -= z20*(min(x20 , y20))</div>
<div class="line">acc3 -= z30*(min(x30 , y30))</div>
<div class="line">acc4 -= z40*(min(x40 , y40))</div>
<div class="line">acc5 -= z50*(min(x50 , y50))</div>
<div class="line">acc6 -= z60*(min(x60 , y60))</div>
<div class="line">acc7 -= z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0ef36ae2df684237134fdc3d892ece0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmsc8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc80&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmsc8_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00))</div>
<div class="line">acc1 -= z10*(min(x10 , y10))</div>
<div class="line">acc2 -= z20*(min(x20 , y20))</div>
<div class="line">acc3 -= z30*(min(x30 , y30))</div>
<div class="line">acc4 -= z40*(min(x40 , y40))</div>
<div class="line">acc5 -= z50*(min(x50 , y50))</div>
<div class="line">acc6 -= z60*(min(x60 , y60))</div>
<div class="line">acc7 -= z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc80 </td><td>Incoming accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga10a6bf858bb6ff4098e38e1b7cf281a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_abs </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmul4_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 = z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 = z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 = z30*abs(x30) + z31*abs(x31)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae50bc7a9e544a24493840768c78c9aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_abs </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 = z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 = z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 = z30*abs(x30) + z31*abs(x31)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae54c73f1106f8211ee8db6aa73a1ea99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_max </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmul4_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1e7c460bf8ea2b909cf1656ca55e8440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac395bf341353eeb97ee7ff9698fe0856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga27a3eb6370c51019c9a7d8c8306e3570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmul4_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6b492d526f8f55b2721d89b9b04c816c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga88d235b9a142329318c9514faafb895d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga977bbddbfc0d80a7ba1fcb802f6b2ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_min </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lmul4_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabf6f09b455b8fc9c2a3af657d2fc460e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga65a01d4c451f51b9c8b1561b5426149a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lmul4_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lmul4_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac79a0997fd9cf6dce38e26d1a1de32f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_abs </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmul8_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00)</div>
<div class="line">acc1 = z10*abs(x10)</div>
<div class="line">acc2 = z20*abs(x20)</div>
<div class="line">acc3 = z30*abs(x30)</div>
<div class="line">acc4 = z40*abs(x40)</div>
<div class="line">acc5 = z50*abs(x50)</div>
<div class="line">acc6 = z60*abs(x60)</div>
<div class="line">acc7 = z70*abs(x70)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf444e82e0423a36f33182b2ceef725fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_abs </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00)</div>
<div class="line">acc1 = z10*abs(x10)</div>
<div class="line">acc2 = z20*abs(x20)</div>
<div class="line">acc3 = z30*abs(x30)</div>
<div class="line">acc4 = z40*abs(x40)</div>
<div class="line">acc5 = z50*abs(x50)</div>
<div class="line">acc6 = z60*abs(x60)</div>
<div class="line">acc7 = z70*abs(x70)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae53d2dc1171a8997687f84bd1450f1fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_max </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmul8_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00))</div>
<div class="line">acc1 = z10*(max(x10 , y10))</div>
<div class="line">acc2 = z20*(max(x20 , y20))</div>
<div class="line">acc3 = z30*(max(x30 , y30))</div>
<div class="line">acc4 = z40*(max(x40 , y40))</div>
<div class="line">acc5 = z50*(max(x50 , y50))</div>
<div class="line">acc6 = z60*(max(x60 , y60))</div>
<div class="line">acc7 = z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6c9a7deecf27e627d897fea574db12f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00))</div>
<div class="line">acc1 = z10*(max(x10 , y10))</div>
<div class="line">acc2 = z20*(max(x20 , y20))</div>
<div class="line">acc3 = z30*(max(x30 , y30))</div>
<div class="line">acc4 = z40*(max(x40 , y40))</div>
<div class="line">acc5 = z50*(max(x50 , y50))</div>
<div class="line">acc6 = z60*(max(x60 , y60))</div>
<div class="line">acc7 = z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0d95b4476db0a043de13fab680deb9af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00))</div>
<div class="line">acc1 = z10*(max(x10 , y10))</div>
<div class="line">acc2 = z20*(max(x20 , y20))</div>
<div class="line">acc3 = z30*(max(x30 , y30))</div>
<div class="line">acc4 = z40*(max(x40 , y40))</div>
<div class="line">acc5 = z50*(max(x50 , y50))</div>
<div class="line">acc6 = z60*(max(x60 , y60))</div>
<div class="line">acc7 = z70*(max(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8ee197b91084064f540577a82c59722c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmul8_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae23edba66bafcf1f4cd50d1aff8433cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf8fbf29083d9711a3c90ca6c1dc5f34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga558a895a3229b0dd7397645b823c9d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_min </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lmul8_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00))</div>
<div class="line">acc1 = z10*(min(x10 , y10))</div>
<div class="line">acc2 = z20*(min(x20 , y20))</div>
<div class="line">acc3 = z30*(min(x30 , y30))</div>
<div class="line">acc4 = z40*(min(x40 , y40))</div>
<div class="line">acc5 = z50*(min(x50 , y50))</div>
<div class="line">acc6 = z60*(min(x60 , y60))</div>
<div class="line">acc7 = z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3b96e094e102aeb245391093526d806c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00))</div>
<div class="line">acc1 = z10*(min(x10 , y10))</div>
<div class="line">acc2 = z20*(min(x20 , y20))</div>
<div class="line">acc3 = z30*(min(x30 , y30))</div>
<div class="line">acc4 = z40*(min(x40 , y40))</div>
<div class="line">acc5 = z50*(min(x50 , y50))</div>
<div class="line">acc6 = z60*(min(x60 , y60))</div>
<div class="line">acc7 = z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga21c3a737e98d0096831a356b6895b0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lmul8_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lmul8_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00))</div>
<div class="line">acc1 = z10*(min(x10 , y10))</div>
<div class="line">acc2 = z20*(min(x20 , y20))</div>
<div class="line">acc3 = z30*(min(x30 , y30))</div>
<div class="line">acc4 = z40*(min(x40 , y40))</div>
<div class="line">acc5 = z50*(min(x50 , y50))</div>
<div class="line">acc6 = z60*(min(x60 , y60))</div>
<div class="line">acc7 = z70*(min(x70 , y70))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga61c8f41594b697e6048190b2c68ee6d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_abs </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lnegmul4_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) + z01*abs(x01) )</div>
<div class="line">acc1 = -( z10*abs(x10) + z11*abs(x11) )</div>
<div class="line">acc2 = -( z20*abs(x20) + z21*abs(x21) )</div>
<div class="line">acc3 = -( z30*abs(x30) + z31*abs(x31) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gada6754320fa8fb83d0eac1abd8faebe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_abs </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) + z01*abs(x01) )</div>
<div class="line">acc1 = -( z10*abs(x10) + z11*abs(x11) )</div>
<div class="line">acc2 = -( z20*abs(x20) + z21*abs(x21) )</div>
<div class="line">acc3 = -( z30*abs(x30) + z31*abs(x31) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5fbf2f1aff18392b1edd88d24f26bdb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_max </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lnegmul4_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga216450e19951ed944554a34c596f3e9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9c708c202744729f25e087233da95745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab201ced311e5582c5038285afb662dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lnegmul4_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga63463c2037bbdeffff71b7552499c5ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga38c6b83f48a5fca0f001117648559cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga296ec180c0e7e5222bf5904e5b7a9f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_min </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v4acc80_lnegmul4_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6631c210f401102913484029fa356cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5a200807b64d2cf7a91e87be9e3fbfd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4acc80 lnegmul4_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v4acc80_lnegmul4_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v4acc80 </td><td>Returned accumulation vector (4 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga46bc86cc622fa971c2059f44abe01647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_abs </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lnegmul8_abs_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) )</div>
<div class="line">acc1 = -( z10*abs(x10) )</div>
<div class="line">acc2 = -( z20*abs(x20) )</div>
<div class="line">acc3 = -( z30*abs(x30) )</div>
<div class="line">acc4 = -( z40*abs(x40) )</div>
<div class="line">acc5 = -( z50*abs(x50) )</div>
<div class="line">acc6 = -( z60*abs(x60) )</div>
<div class="line">acc7 = -( z70*abs(x70) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacad0c666115e92d977596079d544910d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_abs </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_abs_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) )</div>
<div class="line">acc1 = -( z10*abs(x10) )</div>
<div class="line">acc2 = -( z20*abs(x20) )</div>
<div class="line">acc3 = -( z30*abs(x30) )</div>
<div class="line">acc4 = -( z40*abs(x40) )</div>
<div class="line">acc5 = -( z50*abs(x50) )</div>
<div class="line">acc6 = -( z60*abs(x60) )</div>
<div class="line">acc7 = -( z70*abs(x70) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga11bffdffd69e7a79827ae0174d000e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_max </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lnegmul8_max_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1ef6f82d5f353c05e5d957308ef13229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_max_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga099d997d63d0df4bb9d217acbf4c7983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_max </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_max_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa91634daa5b4dff54902b93b6641fbf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lnegmul8_maxdiff_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8201274b4879251aeabbe317e152fed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_maxdiff_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf74ee1f970c7323f2edaecf6a74cf315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_maxdiff_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga17e9224d00011a17ca8fb18991a9e4a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_min </td>
          <td>(</td>
          <td class="paramtype">v32int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc80_lnegmul8_min_v32int32_v8int32_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int32</td><td>Input buffer of 32 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga90b4588820c80b7a74457a645bcf180a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_min_v16int32_v8int32_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga153a54ae8f7912e796f29a7f89c05556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc80 lnegmul8_min </td>
          <td>(</td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int32&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc80_lnegmul8_min_v16int32_v8int32_twobuf_smallbuf_32_32"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc80 </td><td>Returned accumulation vector (8 x int80 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v16int32</td><td>Input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>ybuff </td><td>v16int32</td><td>Right input buffer of 16 elements of type int32 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>zbuff </td><td>v8int32</td><td>Input buffer of 8 elements of type int32 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. The data buffer and coefficient buffer in this intrinsic use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2021 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
