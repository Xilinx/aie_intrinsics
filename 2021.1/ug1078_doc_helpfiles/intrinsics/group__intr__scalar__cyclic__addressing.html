<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: Cyclic Addressing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intr__scalar__cyclic__addressing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Cyclic Addressing<div class="ingroups"><a class="el" href="group__intr__scalar__addressing.html">Addressing Operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>Cyclic addressing intrinsics allow indexing into circular buffers. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cyclic Increment or Decrement within a buffer (NOT FOR UNALIGNED LOADS/STORES)</h2></td></tr>
<tr class="memitem:ga165d24fe3f092a79e330018199d3551f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga165d24fe3f092a79e330018199d3551f">cyclic_add</a> (void *a, int offs, void *restrict start, int len)</td></tr>
<tr class="memdesc:ga165d24fe3f092a79e330018199d3551f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cyclic increment or decrement of a pointer within a buffer.  <a href="#ga165d24fe3f092a79e330018199d3551f"></a><br/></td></tr>
<tr class="separator:ga165d24fe3f092a79e330018199d3551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cyclic increment/decrement for Unaligned Loads/Stores</h2></td></tr>
<tr class="memitem:ga4d0c95cf31b27aacb26b8d506d9d0d29"><td class="memItemLeft" align="right" valign="top">v32int8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga4d0c95cf31b27aacb26b8d506d9d0d29">cyclic_add_unaligned_load</a> (v32int8 *a, int offs, v32int8 *start, int len)</td></tr>
<tr class="memdesc:ga4d0c95cf31b27aacb26b8d506d9d0d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga4d0c95cf31b27aacb26b8d506d9d0d29"></a><br/></td></tr>
<tr class="separator:ga4d0c95cf31b27aacb26b8d506d9d0d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad47efa931fea790201cbe6578a06c613"><td class="memItemLeft" align="right" valign="top">v32uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#gad47efa931fea790201cbe6578a06c613">cyclic_add_unaligned_load</a> (v32uint8 *a, int offs, v32uint8 *start, int len)</td></tr>
<tr class="memdesc:gad47efa931fea790201cbe6578a06c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#gad47efa931fea790201cbe6578a06c613"></a><br/></td></tr>
<tr class="separator:gad47efa931fea790201cbe6578a06c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47115d38ffad14e52de18a2422d65a66"><td class="memItemLeft" align="right" valign="top">v16int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga47115d38ffad14e52de18a2422d65a66">cyclic_add_unaligned_load</a> (v16int16 *a, int offs, v16int16 *start, int len)</td></tr>
<tr class="memdesc:ga47115d38ffad14e52de18a2422d65a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga47115d38ffad14e52de18a2422d65a66"></a><br/></td></tr>
<tr class="separator:ga47115d38ffad14e52de18a2422d65a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6b160d46265c1a46e43284677da65c"><td class="memItemLeft" align="right" valign="top">v8cint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga8f6b160d46265c1a46e43284677da65c">cyclic_add_unaligned_load</a> (v8cint16 *a, int offs, v8cint16 *start, int len)</td></tr>
<tr class="memdesc:ga8f6b160d46265c1a46e43284677da65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga8f6b160d46265c1a46e43284677da65c"></a><br/></td></tr>
<tr class="separator:ga8f6b160d46265c1a46e43284677da65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c0be61808bba29257758fd0a34a636"><td class="memItemLeft" align="right" valign="top">v8int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga81c0be61808bba29257758fd0a34a636">cyclic_add_unaligned_load</a> (v8int32 *a, int offs, v8int32 *start, int len)</td></tr>
<tr class="memdesc:ga81c0be61808bba29257758fd0a34a636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga81c0be61808bba29257758fd0a34a636"></a><br/></td></tr>
<tr class="separator:ga81c0be61808bba29257758fd0a34a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fb26713b5d8e5c456c674cc0f3d5bb"><td class="memItemLeft" align="right" valign="top">v4cint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#gab0fb26713b5d8e5c456c674cc0f3d5bb">cyclic_add_unaligned_load</a> (v4cint32 *a, int offs, v4cint32 *start, int len)</td></tr>
<tr class="memdesc:gab0fb26713b5d8e5c456c674cc0f3d5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#gab0fb26713b5d8e5c456c674cc0f3d5bb"></a><br/></td></tr>
<tr class="separator:gab0fb26713b5d8e5c456c674cc0f3d5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bcd4d05a5f101173eb63d8d1eac113"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga25bcd4d05a5f101173eb63d8d1eac113">cyclic_add_unaligned_load</a> (v8float *a, int offs, v8float *start, int len)</td></tr>
<tr class="memdesc:ga25bcd4d05a5f101173eb63d8d1eac113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga25bcd4d05a5f101173eb63d8d1eac113"></a><br/></td></tr>
<tr class="separator:ga25bcd4d05a5f101173eb63d8d1eac113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d82fa2a52e9a5ea171a8296a97f58d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga07d82fa2a52e9a5ea171a8296a97f58d">cyclic_add_unaligned_load</a> (v4cfloat *a, int offs, v4cfloat *start, int len)</td></tr>
<tr class="memdesc:ga07d82fa2a52e9a5ea171a8296a97f58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga07d82fa2a52e9a5ea171a8296a97f58d"></a><br/></td></tr>
<tr class="separator:ga07d82fa2a52e9a5ea171a8296a97f58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91dfed833b11ddd874dfc574c892b2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga91dfed833b11ddd874dfc574c892b2bc">cyclic_add_unaligned_store</a> (v32int8 *a, int offs, v32int8 *start, int len, v32int8 d)</td></tr>
<tr class="memdesc:ga91dfed833b11ddd874dfc574c892b2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga91dfed833b11ddd874dfc574c892b2bc"></a><br/></td></tr>
<tr class="separator:ga91dfed833b11ddd874dfc574c892b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15395b2f058b7e21ef05e04742db1177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga15395b2f058b7e21ef05e04742db1177">cyclic_add_unaligned_store</a> (v32uint8 *a, int offs, v32uint8 *start, int len, v32uint8 d)</td></tr>
<tr class="memdesc:ga15395b2f058b7e21ef05e04742db1177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga15395b2f058b7e21ef05e04742db1177"></a><br/></td></tr>
<tr class="separator:ga15395b2f058b7e21ef05e04742db1177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8616f9dc8dd35fc5f26037c17250dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#gab8616f9dc8dd35fc5f26037c17250dec">cyclic_add_unaligned_store</a> (v16int16 *a, int offs, v16int16 *start, int len, v16int16 d)</td></tr>
<tr class="memdesc:gab8616f9dc8dd35fc5f26037c17250dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#gab8616f9dc8dd35fc5f26037c17250dec"></a><br/></td></tr>
<tr class="separator:gab8616f9dc8dd35fc5f26037c17250dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86babe68985c148987e86f55b19af773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga86babe68985c148987e86f55b19af773">cyclic_add_unaligned_store</a> (v8cint16 *a, int offs, v8cint16 *start, int len, v8cint16 d)</td></tr>
<tr class="memdesc:ga86babe68985c148987e86f55b19af773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga86babe68985c148987e86f55b19af773"></a><br/></td></tr>
<tr class="separator:ga86babe68985c148987e86f55b19af773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad832dce4895a55ab59455659ada9acbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#gad832dce4895a55ab59455659ada9acbd">cyclic_add_unaligned_store</a> (v8int32 *a, int offs, v8int32 *start, int len, v8int32 d)</td></tr>
<tr class="memdesc:gad832dce4895a55ab59455659ada9acbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#gad832dce4895a55ab59455659ada9acbd"></a><br/></td></tr>
<tr class="separator:gad832dce4895a55ab59455659ada9acbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c361950e893e82bec0337002b24b4ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga6c361950e893e82bec0337002b24b4ce">cyclic_add_unaligned_store</a> (v4cint32 *a, int offs, v4cint32 *start, int len, v4cint32 d)</td></tr>
<tr class="memdesc:ga6c361950e893e82bec0337002b24b4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga6c361950e893e82bec0337002b24b4ce"></a><br/></td></tr>
<tr class="separator:ga6c361950e893e82bec0337002b24b4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e734049764943d8ab8da68ded423d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga8e734049764943d8ab8da68ded423d89">cyclic_add_unaligned_store</a> (v8float *a, int offs, v8float *start, int len, v8float d)</td></tr>
<tr class="memdesc:ga8e734049764943d8ab8da68ded423d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga8e734049764943d8ab8da68ded423d89"></a><br/></td></tr>
<tr class="separator:ga8e734049764943d8ab8da68ded423d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675c762bc4f36786945e3c005cc8ea08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__scalar__cyclic__addressing.html#ga675c762bc4f36786945e3c005cc8ea08">cyclic_add_unaligned_store</a> (v4cfloat *a, int offs, v4cfloat *start, int len, v4cfloat d)</td></tr>
<tr class="memdesc:ga675c762bc4f36786945e3c005cc8ea08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a vector from a pointer and perform a cyclic increment or decrement within a buffer.  <a href="#ga675c762bc4f36786945e3c005cc8ea08"></a><br/></td></tr>
<tr class="separator:ga675c762bc4f36786945e3c005cc8ea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga165d24fe3f092a79e330018199d3551f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cyclic_add </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cyclic increment or decrement of a pointer within a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of elements to increment the pointer by (each step is the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (number of elements of the datatype of the pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The AIE hardware has a load+cyclic_add instruction which loads from a pointer and post-modifies it in the same cycle. In case the vector size is 256-bit and the pointer is only 128-bit aligned and it points right before the end of the buffer, this instruction will load the first 128-bit from the end of the buffer and the second 128-bit from the beginning of the buffer.</dd></dl>
<dl class="section user"><dt></dt><dd>If the load and the cyclic_add are executed in separate instructions, the above behavior is not achieved. Hence, in typical source code, the user writes the load and the cyclic_add on the pointer as separate intrinsics and relies on the compiler to combine the two if possible. That means the unaligned behavior is not guaranteed in this case. In x86 compilation, the two intrinsics will always be executed sequentially and the unaligned load across buffer boundaries will never work.</dd></dl>
<dl class="section user"><dt></dt><dd>Therefore, if you want to load unaligned across cyclic buffer boundaries, please use the <a class="el" href="group__intr__scalar__cyclic__addressing.html#ga4d0c95cf31b27aacb26b8d506d9d0d29" title="Load a vector from a pointer and perform a cyclic increment or decrement within a buffer...">cyclic_add_unaligned_load()</a> intrinsic. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d0c95cf31b27aacb26b8d506d9d0d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v32int8 cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v32int8 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int8 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad47efa931fea790201cbe6578a06c613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v32uint8 cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v32uint8 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32uint8 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga47115d38ffad14e52de18a2422d65a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16int16 cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v16int16 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f6b160d46265c1a46e43284677da65c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8cint16 cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v8cint16 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cint16 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga81c0be61808bba29257758fd0a34a636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8int32 cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v8int32 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0fb26713b5d8e5c456c674cc0f3d5bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cint32 cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v4cint32 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cint32 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga25bcd4d05a5f101173eb63d8d1eac113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v8float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07d82fa2a52e9a5ea171a8296a97f58d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat cyclic_add_unaligned_load </td>
          <td>(</td>
          <td class="paramtype">v4cfloat *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91dfed833b11ddd874dfc574c892b2bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v32int8 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int8 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15395b2f058b7e21ef05e04742db1177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v32uint8 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32uint8 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32uint8&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8616f9dc8dd35fc5f26037c17250dec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v16int16 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86babe68985c148987e86f55b19af773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v8cint16 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cint16 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cint16&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad832dce4895a55ab59455659ada9acbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v8int32 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8int32&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c361950e893e82bec0337002b24b4ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v4cint32 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cint32 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cint32&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e734049764943d8ab8da68ded423d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v8float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga675c762bc4f36786945e3c005cc8ea08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cyclic_add_unaligned_store </td>
          <td>(</td>
          <td class="paramtype">v4cfloat *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a vector from a pointer and perform a cyclic increment or decrement within a buffer. </p>
<p>Please use this intrinsic if your pointer is unaligned with respect to the vector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a]</td><td>Current circular buffer pointer position </td></tr>
    <tr><td class="paramname">offs]</td><td>Number of (half) elements to increment the pointer by (each step is <em>half</em> the size of the input type) </td></tr>
    <tr><td class="paramname">start]</td><td>Pointer to the start of the circular buffer (must be aligned to the vector size) </td></tr>
    <tr><td class="paramname">len]</td><td>Size of the circular buffer (<em>double</em> the number of elements of the datatype of the pointer) </td></tr>
    <tr><td class="paramname">d]</td><td>input vector to be stored for unaligned stores only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2021 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
