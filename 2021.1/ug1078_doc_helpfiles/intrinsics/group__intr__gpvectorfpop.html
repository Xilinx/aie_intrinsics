<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: Float</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intr__gpvectorfpop.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Float<div class="ingroups"><a class="el" href="group__intr__gpvectorop__mul__adv.html">Advanced</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p><a class="anchor" id="fpops_explained"></a> Advanced Float Vector Operations. This page contains the fully configurable fpmac_conf and some convenient wrappers to it. The lane selection scheme is explained after each intrinsic definition.</p>
<p>Some of this floating point operations can generate exceptions, for more information you can go <a class="el" href="group__intr__gpvectorop__mode__status.html#floating_point_flags">here</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac58df991edbdab048ff09113e35dff50"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac58df991edbdab048ff09113e35dff50">fpabs_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac58df991edbdab048ff09113e35dff50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#gac58df991edbdab048ff09113e35dff50"></a><br/></td></tr>
<tr class="separator:gac58df991edbdab048ff09113e35dff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c60203c3f652b8b48a3d27a20f9b3cb"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5c60203c3f652b8b48a3d27a20f9b3cb">fpabs_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5c60203c3f652b8b48a3d27a20f9b3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#ga5c60203c3f652b8b48a3d27a20f9b3cb"></a><br/></td></tr>
<tr class="separator:ga5c60203c3f652b8b48a3d27a20f9b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0facea1eeaf1520c4c167420a49a2431"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0facea1eeaf1520c4c167420a49a2431">fpabs_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0facea1eeaf1520c4c167420a49a2431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#ga0facea1eeaf1520c4c167420a49a2431"></a><br/></td></tr>
<tr class="separator:ga0facea1eeaf1520c4c167420a49a2431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274c0586c48a2005482c1a506ce6e154"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga274c0586c48a2005482c1a506ce6e154">fpabs_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga274c0586c48a2005482c1a506ce6e154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#ga274c0586c48a2005482c1a506ce6e154"></a><br/></td></tr>
<tr class="separator:ga274c0586c48a2005482c1a506ce6e154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf07f2d5763334632fc327a67a3c6201"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadf07f2d5763334632fc327a67a3c6201">fpabs_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gadf07f2d5763334632fc327a67a3c6201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#gadf07f2d5763334632fc327a67a3c6201"></a><br/></td></tr>
<tr class="separator:gadf07f2d5763334632fc327a67a3c6201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02d3ed06bfd2b655c8c4c1be66e4c08"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac02d3ed06bfd2b655c8c4c1be66e4c08">fpabs_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac02d3ed06bfd2b655c8c4c1be66e4c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#gac02d3ed06bfd2b655c8c4c1be66e4c08"></a><br/></td></tr>
<tr class="separator:gac02d3ed06bfd2b655c8c4c1be66e4c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cea3890e799190fd7bcdc80ec2d3d0"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga60cea3890e799190fd7bcdc80ec2d3d0">fpabs_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga60cea3890e799190fd7bcdc80ec2d3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real times real floating point vectors.  <a href="#ga60cea3890e799190fd7bcdc80ec2d3d0"></a><br/></td></tr>
<tr class="separator:ga60cea3890e799190fd7bcdc80ec2d3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf152610c3f0fd63229e22d6b5bababc6"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf152610c3f0fd63229e22d6b5bababc6">fpmac</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaf152610c3f0fd63229e22d6b5bababc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#gaf152610c3f0fd63229e22d6b5bababc6"></a><br/></td></tr>
<tr class="separator:gaf152610c3f0fd63229e22d6b5bababc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf976b059904724fad494ae287d9ce1e8"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf976b059904724fad494ae287d9ce1e8">fpmac</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaf976b059904724fad494ae287d9ce1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#gaf976b059904724fad494ae287d9ce1e8"></a><br/></td></tr>
<tr class="separator:gaf976b059904724fad494ae287d9ce1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga985d9bcc68c31785fee85d1a380dd9c5"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga985d9bcc68c31785fee85d1a380dd9c5">fpmac</a> (v4cfloat acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga985d9bcc68c31785fee85d1a380dd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex floating point vectors.  <a href="#ga985d9bcc68c31785fee85d1a380dd9c5"></a><br/></td></tr>
<tr class="separator:ga985d9bcc68c31785fee85d1a380dd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa737318f7d89f5ab0240fc77efa8ca"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5aa737318f7d89f5ab0240fc77efa8ca">fpmac</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5aa737318f7d89f5ab0240fc77efa8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#ga5aa737318f7d89f5ab0240fc77efa8ca"></a><br/></td></tr>
<tr class="separator:ga5aa737318f7d89f5ab0240fc77efa8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7764577efa29699835bbca5bf001da0"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa7764577efa29699835bbca5bf001da0">fpmac</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa7764577efa29699835bbca5bf001da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#gaa7764577efa29699835bbca5bf001da0"></a><br/></td></tr>
<tr class="separator:gaa7764577efa29699835bbca5bf001da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a72d66b7919bed3bc090ae558d074d5"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9a72d66b7919bed3bc090ae558d074d5">fpmac</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga9a72d66b7919bed3bc090ae558d074d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#ga9a72d66b7919bed3bc090ae558d074d5"></a><br/></td></tr>
<tr class="separator:ga9a72d66b7919bed3bc090ae558d074d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a9e43a73c1816ce9a54413226e1770"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga59a9e43a73c1816ce9a54413226e1770">fpmac</a> (v4cfloat acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga59a9e43a73c1816ce9a54413226e1770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex floating point vectors.  <a href="#ga59a9e43a73c1816ce9a54413226e1770"></a><br/></td></tr>
<tr class="separator:ga59a9e43a73c1816ce9a54413226e1770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad42e3329aea69d2ffb7035d6704f45"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1ad42e3329aea69d2ffb7035d6704f45">fpmac</a> (v4cfloat acc, v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga1ad42e3329aea69d2ffb7035d6704f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex floating point vectors.  <a href="#ga1ad42e3329aea69d2ffb7035d6704f45"></a><br/></td></tr>
<tr class="separator:ga1ad42e3329aea69d2ffb7035d6704f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e5b7f6e2c9d3c54e020f104404fa4e"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga34e5b7f6e2c9d3c54e020f104404fa4e">fpmac</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga34e5b7f6e2c9d3c54e020f104404fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#ga34e5b7f6e2c9d3c54e020f104404fa4e"></a><br/></td></tr>
<tr class="separator:ga34e5b7f6e2c9d3c54e020f104404fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f57a10e173e12ed0f35f2672b91124"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga76f57a10e173e12ed0f35f2672b91124">fpmac</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga76f57a10e173e12ed0f35f2672b91124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times real floating point vectors.  <a href="#ga76f57a10e173e12ed0f35f2672b91124"></a><br/></td></tr>
<tr class="separator:ga76f57a10e173e12ed0f35f2672b91124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a9599d9840ab31ab0df46a5926d088"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac1a9599d9840ab31ab0df46a5926d088">fpmac</a> (v4cfloat acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac1a9599d9840ab31ab0df46a5926d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex floating point vectors.  <a href="#gac1a9599d9840ab31ab0df46a5926d088"></a><br/></td></tr>
<tr class="separator:gac1a9599d9840ab31ab0df46a5926d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32540facab7d50877e2beb93f90284c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf32540facab7d50877e2beb93f90284c">fpmac</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaf32540facab7d50877e2beb93f90284c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times real floating point vectors.  <a href="#gaf32540facab7d50877e2beb93f90284c"></a><br/></td></tr>
<tr class="separator:gaf32540facab7d50877e2beb93f90284c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900af335ebc1a69976c1709e759e9a97"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga900af335ebc1a69976c1709e759e9a97">fpmac</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga900af335ebc1a69976c1709e759e9a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#ga900af335ebc1a69976c1709e759e9a97"></a><br/></td></tr>
<tr class="separator:ga900af335ebc1a69976c1709e759e9a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ae36df38fd90f2c897c472251fb044"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga00ae36df38fd90f2c897c472251fb044">fpmac</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga00ae36df38fd90f2c897c472251fb044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#ga00ae36df38fd90f2c897c472251fb044"></a><br/></td></tr>
<tr class="separator:ga00ae36df38fd90f2c897c472251fb044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78806c429af07ed08f3e85397ce4aed"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab78806c429af07ed08f3e85397ce4aed">fpmac</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab78806c429af07ed08f3e85397ce4aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times real floating point vectors.  <a href="#gab78806c429af07ed08f3e85397ce4aed"></a><br/></td></tr>
<tr class="separator:gab78806c429af07ed08f3e85397ce4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190656385018f38bca2a8baad199decf"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga190656385018f38bca2a8baad199decf">fpmac</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga190656385018f38bca2a8baad199decf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times real floating point vectors.  <a href="#ga190656385018f38bca2a8baad199decf"></a><br/></td></tr>
<tr class="separator:ga190656385018f38bca2a8baad199decf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89424178e1749cea4e414fe07325c15d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga89424178e1749cea4e414fe07325c15d">fpmac</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga89424178e1749cea4e414fe07325c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#ga89424178e1749cea4e414fe07325c15d"></a><br/></td></tr>
<tr class="separator:ga89424178e1749cea4e414fe07325c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f0f80aa2ec930e7cdf697fed300e02"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga72f0f80aa2ec930e7cdf697fed300e02">fpmac</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga72f0f80aa2ec930e7cdf697fed300e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#ga72f0f80aa2ec930e7cdf697fed300e02"></a><br/></td></tr>
<tr class="separator:ga72f0f80aa2ec930e7cdf697fed300e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e2c7f4a83c1f6085f71d8ff677c8b6"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga73e2c7f4a83c1f6085f71d8ff677c8b6">fpmac</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga73e2c7f4a83c1f6085f71d8ff677c8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#ga73e2c7f4a83c1f6085f71d8ff677c8b6"></a><br/></td></tr>
<tr class="separator:ga73e2c7f4a83c1f6085f71d8ff677c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447ce0ae232b8df6fe124ebadbc7b5f3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga447ce0ae232b8df6fe124ebadbc7b5f3">fpmac</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga447ce0ae232b8df6fe124ebadbc7b5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times real floating point vectors.  <a href="#ga447ce0ae232b8df6fe124ebadbc7b5f3"></a><br/></td></tr>
<tr class="separator:ga447ce0ae232b8df6fe124ebadbc7b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6f5aa4a861dfa2e84f4ba264428e54"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafe6f5aa4a861dfa2e84f4ba264428e54">fpmac</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gafe6f5aa4a861dfa2e84f4ba264428e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#gafe6f5aa4a861dfa2e84f4ba264428e54"></a><br/></td></tr>
<tr class="separator:gafe6f5aa4a861dfa2e84f4ba264428e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f30f2195f57d631683395594461514"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga60f30f2195f57d631683395594461514">fpmac</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga60f30f2195f57d631683395594461514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex floating point vectors.  <a href="#ga60f30f2195f57d631683395594461514"></a><br/></td></tr>
<tr class="separator:ga60f30f2195f57d631683395594461514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10a63a97ac139720c9ed90765f3dd41"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab10a63a97ac139720c9ed90765f3dd41">fpmac_abs</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab10a63a97ac139720c9ed90765f3dd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#gab10a63a97ac139720c9ed90765f3dd41"></a><br/></td></tr>
<tr class="separator:gab10a63a97ac139720c9ed90765f3dd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e6b26879f0d3030b98eafbbc0e3c2b"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf4e6b26879f0d3030b98eafbbc0e3c2b">fpmac_abs</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaf4e6b26879f0d3030b98eafbbc0e3c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#gaf4e6b26879f0d3030b98eafbbc0e3c2b"></a><br/></td></tr>
<tr class="separator:gaf4e6b26879f0d3030b98eafbbc0e3c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4a790d518eeee5cd395ddbf43e40b7"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabf4a790d518eeee5cd395ddbf43e40b7">fpmac_abs</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabf4a790d518eeee5cd395ddbf43e40b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#gabf4a790d518eeee5cd395ddbf43e40b7"></a><br/></td></tr>
<tr class="separator:gabf4a790d518eeee5cd395ddbf43e40b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312fdde910f1be7fc48ccc364c48cb5c"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga312fdde910f1be7fc48ccc364c48cb5c">fpmac_abs</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga312fdde910f1be7fc48ccc364c48cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#ga312fdde910f1be7fc48ccc364c48cb5c"></a><br/></td></tr>
<tr class="separator:ga312fdde910f1be7fc48ccc364c48cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07d939f05edd34ed4f4a979a00a8ad9"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa07d939f05edd34ed4f4a979a00a8ad9">fpmac_abs</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gaa07d939f05edd34ed4f4a979a00a8ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#gaa07d939f05edd34ed4f4a979a00a8ad9"></a><br/></td></tr>
<tr class="separator:gaa07d939f05edd34ed4f4a979a00a8ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb63fe3d65e964f38a3c13e979cd9fc"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaddb63fe3d65e964f38a3c13e979cd9fc">fpmac_abs</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaddb63fe3d65e964f38a3c13e979cd9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#gaddb63fe3d65e964f38a3c13e979cd9fc"></a><br/></td></tr>
<tr class="separator:gaddb63fe3d65e964f38a3c13e979cd9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cfc364d36638647c0b5dfb09106e16c"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4cfc364d36638647c0b5dfb09106e16c">fpmac_abs</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4cfc364d36638647c0b5dfb09106e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real times real floating point vectors.  <a href="#ga4cfc364d36638647c0b5dfb09106e16c"></a><br/></td></tr>
<tr class="separator:ga4cfc364d36638647c0b5dfb09106e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20cea7d0ff13059f5aefe8d0ef869d0c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga20cea7d0ff13059f5aefe8d0ef869d0c">fpmac_c</a> (v4cfloat acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga20cea7d0ff13059f5aefe8d0ef869d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex conjugate floating point vectors.  <a href="#ga20cea7d0ff13059f5aefe8d0ef869d0c"></a><br/></td></tr>
<tr class="separator:ga20cea7d0ff13059f5aefe8d0ef869d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b3531f6e573a88a37b52c3bcb801e93"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1b3531f6e573a88a37b52c3bcb801e93">fpmac_c</a> (v4cfloat acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1b3531f6e573a88a37b52c3bcb801e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex conjugate floating point vectors.  <a href="#ga1b3531f6e573a88a37b52c3bcb801e93"></a><br/></td></tr>
<tr class="separator:ga1b3531f6e573a88a37b52c3bcb801e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b63065da9066735c098a8dbb8c99c15"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7b63065da9066735c098a8dbb8c99c15">fpmac_c</a> (v4cfloat acc, v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga7b63065da9066735c098a8dbb8c99c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex conjugate floating point vectors.  <a href="#ga7b63065da9066735c098a8dbb8c99c15"></a><br/></td></tr>
<tr class="separator:ga7b63065da9066735c098a8dbb8c99c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac670a46b4d56c65693352653f8a86560"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac670a46b4d56c65693352653f8a86560">fpmac_c</a> (v4cfloat acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac670a46b4d56c65693352653f8a86560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision real times complex conjugate floating point vectors.  <a href="#gac670a46b4d56c65693352653f8a86560"></a><br/></td></tr>
<tr class="separator:gac670a46b4d56c65693352653f8a86560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa5ce0fc5cbb25565651c7c3aaaf7b0"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4fa5ce0fc5cbb25565651c7c3aaaf7b0">fpmac_c</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4fa5ce0fc5cbb25565651c7c3aaaf7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times real floating point vectors.  <a href="#ga4fa5ce0fc5cbb25565651c7c3aaaf7b0"></a><br/></td></tr>
<tr class="separator:ga4fa5ce0fc5cbb25565651c7c3aaaf7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990129e0bc509682abf622e4b91a15c1"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga990129e0bc509682abf622e4b91a15c1">fpmac_c</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga990129e0bc509682abf622e4b91a15c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times real floating point vectors.  <a href="#ga990129e0bc509682abf622e4b91a15c1"></a><br/></td></tr>
<tr class="separator:ga990129e0bc509682abf622e4b91a15c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93a917fef6c054c0dada0b8f6ca02c7"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae93a917fef6c054c0dada0b8f6ca02c7">fpmac_c</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gae93a917fef6c054c0dada0b8f6ca02c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times real floating point vectors.  <a href="#gae93a917fef6c054c0dada0b8f6ca02c7"></a><br/></td></tr>
<tr class="separator:gae93a917fef6c054c0dada0b8f6ca02c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd96834a113a91158a567bbfa28bdd8"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4fd96834a113a91158a567bbfa28bdd8">fpmac_c</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4fd96834a113a91158a567bbfa28bdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times real floating point vectors.  <a href="#ga4fd96834a113a91158a567bbfa28bdd8"></a><br/></td></tr>
<tr class="separator:ga4fd96834a113a91158a567bbfa28bdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b950935aee1e8b099f59939cd264aba"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3b950935aee1e8b099f59939cd264aba">fpmac_cc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga3b950935aee1e8b099f59939cd264aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga3b950935aee1e8b099f59939cd264aba"></a><br/></td></tr>
<tr class="separator:ga3b950935aee1e8b099f59939cd264aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778a2b565b2cad33e89b2ba5acd66829"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga778a2b565b2cad33e89b2ba5acd66829">fpmac_cc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga778a2b565b2cad33e89b2ba5acd66829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga778a2b565b2cad33e89b2ba5acd66829"></a><br/></td></tr>
<tr class="separator:ga778a2b565b2cad33e89b2ba5acd66829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44da05651d8acde8150c32017c4ca44"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac44da05651d8acde8150c32017c4ca44">fpmac_cc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac44da05651d8acde8150c32017c4ca44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gac44da05651d8acde8150c32017c4ca44"></a><br/></td></tr>
<tr class="separator:gac44da05651d8acde8150c32017c4ca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b73df4e6d14332b7979487f02a396c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad0b73df4e6d14332b7979487f02a396c">fpmac_cc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gad0b73df4e6d14332b7979487f02a396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gad0b73df4e6d14332b7979487f02a396c"></a><br/></td></tr>
<tr class="separator:gad0b73df4e6d14332b7979487f02a396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e050ee7dac28bbf3a11043ac80b035"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga08e050ee7dac28bbf3a11043ac80b035">fpmac_cc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga08e050ee7dac28bbf3a11043ac80b035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga08e050ee7dac28bbf3a11043ac80b035"></a><br/></td></tr>
<tr class="separator:ga08e050ee7dac28bbf3a11043ac80b035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd3b7c103306d9988dfde0bf9118f9d8"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadd3b7c103306d9988dfde0bf9118f9d8">fpmac_cc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gadd3b7c103306d9988dfde0bf9118f9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gadd3b7c103306d9988dfde0bf9118f9d8"></a><br/></td></tr>
<tr class="separator:gadd3b7c103306d9988dfde0bf9118f9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27b3582623a5dc34f03f78c77621440"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad27b3582623a5dc34f03f78c77621440">fpmac_cc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gad27b3582623a5dc34f03f78c77621440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gad27b3582623a5dc34f03f78c77621440"></a><br/></td></tr>
<tr class="separator:gad27b3582623a5dc34f03f78c77621440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56add04da122c94749e70acf774d1b87"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga56add04da122c94749e70acf774d1b87">fpmac_cn</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga56add04da122c94749e70acf774d1b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#ga56add04da122c94749e70acf774d1b87"></a><br/></td></tr>
<tr class="separator:ga56add04da122c94749e70acf774d1b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e3358b68ba31dbc8bfab8c2a8518277"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0e3358b68ba31dbc8bfab8c2a8518277">fpmac_cn</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0e3358b68ba31dbc8bfab8c2a8518277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#ga0e3358b68ba31dbc8bfab8c2a8518277"></a><br/></td></tr>
<tr class="separator:ga0e3358b68ba31dbc8bfab8c2a8518277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abd7ebfc0e32d26d4f8e8abc907f298"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8abd7ebfc0e32d26d4f8e8abc907f298">fpmac_cn</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8abd7ebfc0e32d26d4f8e8abc907f298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#ga8abd7ebfc0e32d26d4f8e8abc907f298"></a><br/></td></tr>
<tr class="separator:ga8abd7ebfc0e32d26d4f8e8abc907f298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35ba21db8994c015fecd04645fcba0d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf35ba21db8994c015fecd04645fcba0d">fpmac_cn</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaf35ba21db8994c015fecd04645fcba0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#gaf35ba21db8994c015fecd04645fcba0d"></a><br/></td></tr>
<tr class="separator:gaf35ba21db8994c015fecd04645fcba0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f8ce180356be911cee4c9fb3b5c9b2"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf1f8ce180356be911cee4c9fb3b5c9b2">fpmac_cn</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gaf1f8ce180356be911cee4c9fb3b5c9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#gaf1f8ce180356be911cee4c9fb3b5c9b2"></a><br/></td></tr>
<tr class="separator:gaf1f8ce180356be911cee4c9fb3b5c9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b773b14265eb6abd8f93aaca8bfa0d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga35b773b14265eb6abd8f93aaca8bfa0d">fpmac_cn</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga35b773b14265eb6abd8f93aaca8bfa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#ga35b773b14265eb6abd8f93aaca8bfa0d"></a><br/></td></tr>
<tr class="separator:ga35b773b14265eb6abd8f93aaca8bfa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136d699321574ef4ca022e16aee55270"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga136d699321574ef4ca022e16aee55270">fpmac_cn</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga136d699321574ef4ca022e16aee55270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex conjugate times complex floating point vectors.  <a href="#ga136d699321574ef4ca022e16aee55270"></a><br/></td></tr>
<tr class="separator:ga136d699321574ef4ca022e16aee55270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6deccb120d1bc0c08234889413d5aee6"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga6deccb120d1bc0c08234889413d5aee6">fpmac_conf</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga6deccb120d1bc0c08234889413d5aee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga6deccb120d1bc0c08234889413d5aee6"></a><br/></td></tr>
<tr class="separator:ga6deccb120d1bc0c08234889413d5aee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f0041c586f6f6dd0894896a71e86d6"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga03f0041c586f6f6dd0894896a71e86d6">fpmac_conf</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga03f0041c586f6f6dd0894896a71e86d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga03f0041c586f6f6dd0894896a71e86d6"></a><br/></td></tr>
<tr class="separator:ga03f0041c586f6f6dd0894896a71e86d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59016c1d7be44952a51c056901c8211"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae59016c1d7be44952a51c056901c8211">fpmac_conf</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gae59016c1d7be44952a51c056901c8211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gae59016c1d7be44952a51c056901c8211"></a><br/></td></tr>
<tr class="separator:gae59016c1d7be44952a51c056901c8211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga019cf8186da482be77f33ff39e4c716b"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga019cf8186da482be77f33ff39e4c716b">fpmac_conf</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga019cf8186da482be77f33ff39e4c716b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga019cf8186da482be77f33ff39e4c716b"></a><br/></td></tr>
<tr class="separator:ga019cf8186da482be77f33ff39e4c716b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8344cac4e5c088d56b5601a5e849ae"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1d8344cac4e5c088d56b5601a5e849ae">fpmac_conf</a> (v4cfloat acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga1d8344cac4e5c088d56b5601a5e849ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga1d8344cac4e5c088d56b5601a5e849ae"></a><br/></td></tr>
<tr class="separator:ga1d8344cac4e5c088d56b5601a5e849ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08804c927a6096f60c3d89c3f933812a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga08804c927a6096f60c3d89c3f933812a">fpmac_conf</a> (v4cfloat acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga08804c927a6096f60c3d89c3f933812a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga08804c927a6096f60c3d89c3f933812a"></a><br/></td></tr>
<tr class="separator:ga08804c927a6096f60c3d89c3f933812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6128cbe449b62af09b1255bc20f206a8"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga6128cbe449b62af09b1255bc20f206a8">fpmac_conf</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga6128cbe449b62af09b1255bc20f206a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga6128cbe449b62af09b1255bc20f206a8"></a><br/></td></tr>
<tr class="separator:ga6128cbe449b62af09b1255bc20f206a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf83ced652673021b09d77a339a2e74f"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacf83ced652673021b09d77a339a2e74f">fpmac_conf</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gacf83ced652673021b09d77a339a2e74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gacf83ced652673021b09d77a339a2e74f"></a><br/></td></tr>
<tr class="separator:gacf83ced652673021b09d77a339a2e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ab721fa840816d803a74d4c8960fa1"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga84ab721fa840816d803a74d4c8960fa1">fpmac_conf</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga84ab721fa840816d803a74d4c8960fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga84ab721fa840816d803a74d4c8960fa1"></a><br/></td></tr>
<tr class="separator:ga84ab721fa840816d803a74d4c8960fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270120a0ebc86049420ed15884a760d9"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga270120a0ebc86049420ed15884a760d9">fpmac_conf</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga270120a0ebc86049420ed15884a760d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga270120a0ebc86049420ed15884a760d9"></a><br/></td></tr>
<tr class="separator:ga270120a0ebc86049420ed15884a760d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e724a7a2ce34cbd3a6534c75f7f9e79"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9e724a7a2ce34cbd3a6534c75f7f9e79">fpmac_conf</a> (v4cfloat acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga9e724a7a2ce34cbd3a6534c75f7f9e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga9e724a7a2ce34cbd3a6534c75f7f9e79"></a><br/></td></tr>
<tr class="separator:ga9e724a7a2ce34cbd3a6534c75f7f9e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936851c57b3cc0add42bdd22d91c44b6"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga936851c57b3cc0add42bdd22d91c44b6">fpmac_conf</a> (v4cfloat acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga936851c57b3cc0add42bdd22d91c44b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga936851c57b3cc0add42bdd22d91c44b6"></a><br/></td></tr>
<tr class="separator:ga936851c57b3cc0add42bdd22d91c44b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389a58e20b6742e9eeea5c1f84d2d821"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga389a58e20b6742e9eeea5c1f84d2d821">fpmac_conf</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga389a58e20b6742e9eeea5c1f84d2d821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga389a58e20b6742e9eeea5c1f84d2d821"></a><br/></td></tr>
<tr class="separator:ga389a58e20b6742e9eeea5c1f84d2d821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0923b0208495c392d1755842dce66d47"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0923b0208495c392d1755842dce66d47">fpmac_conf</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga0923b0208495c392d1755842dce66d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga0923b0208495c392d1755842dce66d47"></a><br/></td></tr>
<tr class="separator:ga0923b0208495c392d1755842dce66d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7f9e9dbc0df75658a1c2fbfb30873b"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7c7f9e9dbc0df75658a1c2fbfb30873b">fpmac_conf</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga7c7f9e9dbc0df75658a1c2fbfb30873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga7c7f9e9dbc0df75658a1c2fbfb30873b"></a><br/></td></tr>
<tr class="separator:ga7c7f9e9dbc0df75658a1c2fbfb30873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac410a63472d6fe739d5f141e14f3fe2d"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac410a63472d6fe739d5f141e14f3fe2d">fpmac_conf</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gac410a63472d6fe739d5f141e14f3fe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gac410a63472d6fe739d5f141e14f3fe2d"></a><br/></td></tr>
<tr class="separator:gac410a63472d6fe739d5f141e14f3fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9266dd0cd9a703f4cc0256e59b61463c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9266dd0cd9a703f4cc0256e59b61463c">fpmac_conf</a> (v4cfloat acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga9266dd0cd9a703f4cc0256e59b61463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga9266dd0cd9a703f4cc0256e59b61463c"></a><br/></td></tr>
<tr class="separator:ga9266dd0cd9a703f4cc0256e59b61463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82a218e4dd42b2179f3444359601b3f"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab82a218e4dd42b2179f3444359601b3f">fpmac_conf</a> (v4cfloat acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab82a218e4dd42b2179f3444359601b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gab82a218e4dd42b2179f3444359601b3f"></a><br/></td></tr>
<tr class="separator:gab82a218e4dd42b2179f3444359601b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11cc33cfe1426c89a7a302739e36e1d3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga11cc33cfe1426c89a7a302739e36e1d3">fpmac_conf</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga11cc33cfe1426c89a7a302739e36e1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga11cc33cfe1426c89a7a302739e36e1d3"></a><br/></td></tr>
<tr class="separator:ga11cc33cfe1426c89a7a302739e36e1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32f9d0e3909c4a2b5a3d36ab5955d10"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa32f9d0e3909c4a2b5a3d36ab5955d10">fpmac_conf</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gaa32f9d0e3909c4a2b5a3d36ab5955d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gaa32f9d0e3909c4a2b5a3d36ab5955d10"></a><br/></td></tr>
<tr class="separator:gaa32f9d0e3909c4a2b5a3d36ab5955d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1fba04cbdbb3b56102136d1d201d3bc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae1fba04cbdbb3b56102136d1d201d3bc">fpmac_conf</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gae1fba04cbdbb3b56102136d1d201d3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gae1fba04cbdbb3b56102136d1d201d3bc"></a><br/></td></tr>
<tr class="separator:gae1fba04cbdbb3b56102136d1d201d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b88cb3180803101ba96b98139b1580"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab0b88cb3180803101ba96b98139b1580">fpmac_conf</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab0b88cb3180803101ba96b98139b1580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gab0b88cb3180803101ba96b98139b1580"></a><br/></td></tr>
<tr class="separator:gab0b88cb3180803101ba96b98139b1580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e91d0e9d2dcb727002874b27bb7553"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga86e91d0e9d2dcb727002874b27bb7553">fpmac_conf</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga86e91d0e9d2dcb727002874b27bb7553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga86e91d0e9d2dcb727002874b27bb7553"></a><br/></td></tr>
<tr class="separator:ga86e91d0e9d2dcb727002874b27bb7553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84c7a3d3dba85b57664053fe0a883edc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga84c7a3d3dba85b57664053fe0a883edc">fpmac_conf</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga84c7a3d3dba85b57664053fe0a883edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga84c7a3d3dba85b57664053fe0a883edc"></a><br/></td></tr>
<tr class="separator:ga84c7a3d3dba85b57664053fe0a883edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798f830b91f7a141a41998eeadc705b3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga798f830b91f7a141a41998eeadc705b3">fpmac_conf</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga798f830b91f7a141a41998eeadc705b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga798f830b91f7a141a41998eeadc705b3"></a><br/></td></tr>
<tr class="separator:ga798f830b91f7a141a41998eeadc705b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bcd9c467a30cb5447174c847d68eeb"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga94bcd9c467a30cb5447174c847d68eeb">fpmac_conf</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga94bcd9c467a30cb5447174c847d68eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga94bcd9c467a30cb5447174c847d68eeb"></a><br/></td></tr>
<tr class="separator:ga94bcd9c467a30cb5447174c847d68eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0aa1196dd4e52e44d851c46fd4d210"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4b0aa1196dd4e52e44d851c46fd4d210">fpmac_conf</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga4b0aa1196dd4e52e44d851c46fd4d210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga4b0aa1196dd4e52e44d851c46fd4d210"></a><br/></td></tr>
<tr class="separator:ga4b0aa1196dd4e52e44d851c46fd4d210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6e690509cf12aba9d1bda9bd8d226d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0e6e690509cf12aba9d1bda9bd8d226d">fpmac_conf</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga0e6e690509cf12aba9d1bda9bd8d226d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga0e6e690509cf12aba9d1bda9bd8d226d"></a><br/></td></tr>
<tr class="separator:ga0e6e690509cf12aba9d1bda9bd8d226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7827d0fe97053cf7bbaaabeba3bf529"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf7827d0fe97053cf7bbaaabeba3bf529">fpmac_conf</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gaf7827d0fe97053cf7bbaaabeba3bf529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gaf7827d0fe97053cf7bbaaabeba3bf529"></a><br/></td></tr>
<tr class="separator:gaf7827d0fe97053cf7bbaaabeba3bf529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f3486a407913c4d7fbacd1f81041e0"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga22f3486a407913c4d7fbacd1f81041e0">fpmac_conf</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga22f3486a407913c4d7fbacd1f81041e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga22f3486a407913c4d7fbacd1f81041e0"></a><br/></td></tr>
<tr class="separator:ga22f3486a407913c4d7fbacd1f81041e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9140d5d5bcf84ee494fc35dd1c4ca1"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaeb9140d5d5bcf84ee494fc35dd1c4ca1">fpmac_conf</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gaeb9140d5d5bcf84ee494fc35dd1c4ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gaeb9140d5d5bcf84ee494fc35dd1c4ca1"></a><br/></td></tr>
<tr class="separator:gaeb9140d5d5bcf84ee494fc35dd1c4ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e5ee227fe6c0dcb06e313d97648844"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga34e5ee227fe6c0dcb06e313d97648844">fpmac_conf</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga34e5ee227fe6c0dcb06e313d97648844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga34e5ee227fe6c0dcb06e313d97648844"></a><br/></td></tr>
<tr class="separator:ga34e5ee227fe6c0dcb06e313d97648844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c105388d2aeb00939deb815546d3fe"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab0c105388d2aeb00939deb815546d3fe">fpmac_conf</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gab0c105388d2aeb00939deb815546d3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gab0c105388d2aeb00939deb815546d3fe"></a><br/></td></tr>
<tr class="separator:gab0c105388d2aeb00939deb815546d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529d610c0293b24ed4b51b7a76e3b883"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga529d610c0293b24ed4b51b7a76e3b883">fpmac_conf</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga529d610c0293b24ed4b51b7a76e3b883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga529d610c0293b24ed4b51b7a76e3b883"></a><br/></td></tr>
<tr class="separator:ga529d610c0293b24ed4b51b7a76e3b883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9d5eeac4e068b41d99593b412571ed"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9e9d5eeac4e068b41d99593b412571ed">fpmac_conf</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga9e9d5eeac4e068b41d99593b412571ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#ga9e9d5eeac4e068b41d99593b412571ed"></a><br/></td></tr>
<tr class="separator:ga9e9d5eeac4e068b41d99593b412571ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab406a9c168d3c26062f9cf0f36697d93"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab406a9c168d3c26062f9cf0f36697d93">fpmac_conf</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab406a9c168d3c26062f9cf0f36697d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply and accumulate for single precision floating point vectors.  <a href="#gab406a9c168d3c26062f9cf0f36697d93"></a><br/></td></tr>
<tr class="separator:gab406a9c168d3c26062f9cf0f36697d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ed54a9fb24cd785f57a660f129ada0"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga91ed54a9fb24cd785f57a660f129ada0">fpmac_nc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga91ed54a9fb24cd785f57a660f129ada0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#ga91ed54a9fb24cd785f57a660f129ada0"></a><br/></td></tr>
<tr class="separator:ga91ed54a9fb24cd785f57a660f129ada0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d68a79e58d5e614d8cd37d86d4f4fb7"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0d68a79e58d5e614d8cd37d86d4f4fb7">fpmac_nc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0d68a79e58d5e614d8cd37d86d4f4fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#ga0d68a79e58d5e614d8cd37d86d4f4fb7"></a><br/></td></tr>
<tr class="separator:ga0d68a79e58d5e614d8cd37d86d4f4fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40dc6934f0fa102f1ef867553d4f5511"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga40dc6934f0fa102f1ef867553d4f5511">fpmac_nc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga40dc6934f0fa102f1ef867553d4f5511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#ga40dc6934f0fa102f1ef867553d4f5511"></a><br/></td></tr>
<tr class="separator:ga40dc6934f0fa102f1ef867553d4f5511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac827706a2b7c5dac5c173a1752b7e8fd"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac827706a2b7c5dac5c173a1752b7e8fd">fpmac_nc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac827706a2b7c5dac5c173a1752b7e8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#gac827706a2b7c5dac5c173a1752b7e8fd"></a><br/></td></tr>
<tr class="separator:gac827706a2b7c5dac5c173a1752b7e8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0efc49db3f8048d75ba8b96fe21bf7"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4c0efc49db3f8048d75ba8b96fe21bf7">fpmac_nc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga4c0efc49db3f8048d75ba8b96fe21bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#ga4c0efc49db3f8048d75ba8b96fe21bf7"></a><br/></td></tr>
<tr class="separator:ga4c0efc49db3f8048d75ba8b96fe21bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43495ac6598dde4c8b9d40d7950959b"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab43495ac6598dde4c8b9d40d7950959b">fpmac_nc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab43495ac6598dde4c8b9d40d7950959b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#gab43495ac6598dde4c8b9d40d7950959b"></a><br/></td></tr>
<tr class="separator:gab43495ac6598dde4c8b9d40d7950959b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d86ba537d2d7740ae3f35c230ae785e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9d86ba537d2d7740ae3f35c230ae785e">fpmac_nc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9d86ba537d2d7740ae3f35c230ae785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and accumulate for single precision complex times complex conjugate floating point vectors.  <a href="#ga9d86ba537d2d7740ae3f35c230ae785e"></a><br/></td></tr>
<tr class="separator:ga9d86ba537d2d7740ae3f35c230ae785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb35eaadd0cc73e7fc9187b22352f858"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabb35eaadd0cc73e7fc9187b22352f858">fpmsc</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabb35eaadd0cc73e7fc9187b22352f858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#gabb35eaadd0cc73e7fc9187b22352f858"></a><br/></td></tr>
<tr class="separator:gabb35eaadd0cc73e7fc9187b22352f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a31b08088965b55c7083811358a4b7e"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5a31b08088965b55c7083811358a4b7e">fpmsc</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5a31b08088965b55c7083811358a4b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#ga5a31b08088965b55c7083811358a4b7e"></a><br/></td></tr>
<tr class="separator:ga5a31b08088965b55c7083811358a4b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4979875bcb091219f8fac27f8248c886"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4979875bcb091219f8fac27f8248c886">fpmsc</a> (v4cfloat acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4979875bcb091219f8fac27f8248c886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex floating point vectors.  <a href="#ga4979875bcb091219f8fac27f8248c886"></a><br/></td></tr>
<tr class="separator:ga4979875bcb091219f8fac27f8248c886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc06cd24132d7178bcee30ba717dbb0"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaffc06cd24132d7178bcee30ba717dbb0">fpmsc</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaffc06cd24132d7178bcee30ba717dbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#gaffc06cd24132d7178bcee30ba717dbb0"></a><br/></td></tr>
<tr class="separator:gaffc06cd24132d7178bcee30ba717dbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db06e36afad70f93afaedfaac72b4df"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1db06e36afad70f93afaedfaac72b4df">fpmsc</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1db06e36afad70f93afaedfaac72b4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#ga1db06e36afad70f93afaedfaac72b4df"></a><br/></td></tr>
<tr class="separator:ga1db06e36afad70f93afaedfaac72b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa963e3da5a032cb9f1bf50939bf81c05"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa963e3da5a032cb9f1bf50939bf81c05">fpmsc</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gaa963e3da5a032cb9f1bf50939bf81c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#gaa963e3da5a032cb9f1bf50939bf81c05"></a><br/></td></tr>
<tr class="separator:gaa963e3da5a032cb9f1bf50939bf81c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30263502d587d2642577bdd0b8f572a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab30263502d587d2642577bdd0b8f572a">fpmsc</a> (v4cfloat acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab30263502d587d2642577bdd0b8f572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex floating point vectors.  <a href="#gab30263502d587d2642577bdd0b8f572a"></a><br/></td></tr>
<tr class="separator:gab30263502d587d2642577bdd0b8f572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69aec73e41aa2ed8b79d3041db60497b"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga69aec73e41aa2ed8b79d3041db60497b">fpmsc</a> (v4cfloat acc, v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga69aec73e41aa2ed8b79d3041db60497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex floating point vectors.  <a href="#ga69aec73e41aa2ed8b79d3041db60497b"></a><br/></td></tr>
<tr class="separator:ga69aec73e41aa2ed8b79d3041db60497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea70bc03ebc2fd4ff397e095a2528b0"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4ea70bc03ebc2fd4ff397e095a2528b0">fpmsc</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4ea70bc03ebc2fd4ff397e095a2528b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#ga4ea70bc03ebc2fd4ff397e095a2528b0"></a><br/></td></tr>
<tr class="separator:ga4ea70bc03ebc2fd4ff397e095a2528b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d1b80d9cb3a72ee7b30043085517db9"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8d1b80d9cb3a72ee7b30043085517db9">fpmsc</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8d1b80d9cb3a72ee7b30043085517db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times real floating point vectors.  <a href="#ga8d1b80d9cb3a72ee7b30043085517db9"></a><br/></td></tr>
<tr class="separator:ga8d1b80d9cb3a72ee7b30043085517db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1284de74f1c922f34f367d934c911703"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1284de74f1c922f34f367d934c911703">fpmsc</a> (v4cfloat acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1284de74f1c922f34f367d934c911703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex floating point vectors.  <a href="#ga1284de74f1c922f34f367d934c911703"></a><br/></td></tr>
<tr class="separator:ga1284de74f1c922f34f367d934c911703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga836444859e2e7de655deb409563e2426"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga836444859e2e7de655deb409563e2426">fpmsc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga836444859e2e7de655deb409563e2426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times real floating point vectors.  <a href="#ga836444859e2e7de655deb409563e2426"></a><br/></td></tr>
<tr class="separator:ga836444859e2e7de655deb409563e2426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8982124c7b70d01607da29033af62b3c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8982124c7b70d01607da29033af62b3c">fpmsc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8982124c7b70d01607da29033af62b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#ga8982124c7b70d01607da29033af62b3c"></a><br/></td></tr>
<tr class="separator:ga8982124c7b70d01607da29033af62b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a838960b7e3aa039f379ee97efda26"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab1a838960b7e3aa039f379ee97efda26">fpmsc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab1a838960b7e3aa039f379ee97efda26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#gab1a838960b7e3aa039f379ee97efda26"></a><br/></td></tr>
<tr class="separator:gab1a838960b7e3aa039f379ee97efda26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b8559a1f5d33420744d544afda4b27"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga91b8559a1f5d33420744d544afda4b27">fpmsc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga91b8559a1f5d33420744d544afda4b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times real floating point vectors.  <a href="#ga91b8559a1f5d33420744d544afda4b27"></a><br/></td></tr>
<tr class="separator:ga91b8559a1f5d33420744d544afda4b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab209d934b98a9dc6ba8114f7005aefbb"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab209d934b98a9dc6ba8114f7005aefbb">fpmsc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gab209d934b98a9dc6ba8114f7005aefbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times real floating point vectors.  <a href="#gab209d934b98a9dc6ba8114f7005aefbb"></a><br/></td></tr>
<tr class="separator:gab209d934b98a9dc6ba8114f7005aefbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b25bc373baf18db70e4ae639b913565"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1b25bc373baf18db70e4ae639b913565">fpmsc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1b25bc373baf18db70e4ae639b913565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#ga1b25bc373baf18db70e4ae639b913565"></a><br/></td></tr>
<tr class="separator:ga1b25bc373baf18db70e4ae639b913565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809b4207325f5443751c7bbae5e249a5"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga809b4207325f5443751c7bbae5e249a5">fpmsc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga809b4207325f5443751c7bbae5e249a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#ga809b4207325f5443751c7bbae5e249a5"></a><br/></td></tr>
<tr class="separator:ga809b4207325f5443751c7bbae5e249a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga976899107841ecfe5927fad8d74a1991"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga976899107841ecfe5927fad8d74a1991">fpmsc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga976899107841ecfe5927fad8d74a1991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#ga976899107841ecfe5927fad8d74a1991"></a><br/></td></tr>
<tr class="separator:ga976899107841ecfe5927fad8d74a1991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5580c5ce689b602cfb1fb8ab936f7868"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5580c5ce689b602cfb1fb8ab936f7868">fpmsc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5580c5ce689b602cfb1fb8ab936f7868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times real floating point vectors.  <a href="#ga5580c5ce689b602cfb1fb8ab936f7868"></a><br/></td></tr>
<tr class="separator:ga5580c5ce689b602cfb1fb8ab936f7868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9d17eae5bea8a3783d6f2f18c1ba20"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gada9d17eae5bea8a3783d6f2f18c1ba20">fpmsc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gada9d17eae5bea8a3783d6f2f18c1ba20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#gada9d17eae5bea8a3783d6f2f18c1ba20"></a><br/></td></tr>
<tr class="separator:gada9d17eae5bea8a3783d6f2f18c1ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad94da13dfd8314cefbc1358272c45ba"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaad94da13dfd8314cefbc1358272c45ba">fpmsc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaad94da13dfd8314cefbc1358272c45ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex floating point vectors.  <a href="#gaad94da13dfd8314cefbc1358272c45ba"></a><br/></td></tr>
<tr class="separator:gaad94da13dfd8314cefbc1358272c45ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea8880c9b4e6ed420f2739ce1648895"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9ea8880c9b4e6ed420f2739ce1648895">fpmsc_abs</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9ea8880c9b4e6ed420f2739ce1648895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#ga9ea8880c9b4e6ed420f2739ce1648895"></a><br/></td></tr>
<tr class="separator:ga9ea8880c9b4e6ed420f2739ce1648895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a896e1b45fe94ef50d99069cdebfc2"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga07a896e1b45fe94ef50d99069cdebfc2">fpmsc_abs</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga07a896e1b45fe94ef50d99069cdebfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#ga07a896e1b45fe94ef50d99069cdebfc2"></a><br/></td></tr>
<tr class="separator:ga07a896e1b45fe94ef50d99069cdebfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1834f7ab3e7ce47ecba4a1c202926223"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1834f7ab3e7ce47ecba4a1c202926223">fpmsc_abs</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1834f7ab3e7ce47ecba4a1c202926223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#ga1834f7ab3e7ce47ecba4a1c202926223"></a><br/></td></tr>
<tr class="separator:ga1834f7ab3e7ce47ecba4a1c202926223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c752825c0bcca7cd039834d8a2b7bd2"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2c752825c0bcca7cd039834d8a2b7bd2">fpmsc_abs</a> (v8float acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga2c752825c0bcca7cd039834d8a2b7bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#ga2c752825c0bcca7cd039834d8a2b7bd2"></a><br/></td></tr>
<tr class="separator:ga2c752825c0bcca7cd039834d8a2b7bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f950fd4a784e7e30fd1da729ea44a2"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga01f950fd4a784e7e30fd1da729ea44a2">fpmsc_abs</a> (v8float acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga01f950fd4a784e7e30fd1da729ea44a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#ga01f950fd4a784e7e30fd1da729ea44a2"></a><br/></td></tr>
<tr class="separator:ga01f950fd4a784e7e30fd1da729ea44a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd25f74812fbb2f218fe18fb785afafb"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabd25f74812fbb2f218fe18fb785afafb">fpmsc_abs</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabd25f74812fbb2f218fe18fb785afafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#gabd25f74812fbb2f218fe18fb785afafb"></a><br/></td></tr>
<tr class="separator:gabd25f74812fbb2f218fe18fb785afafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab72656a5ae33734a73ce45ce3898ff"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7ab72656a5ae33734a73ce45ce3898ff">fpmsc_abs</a> (v8float acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga7ab72656a5ae33734a73ce45ce3898ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real times real floating point vectors.  <a href="#ga7ab72656a5ae33734a73ce45ce3898ff"></a><br/></td></tr>
<tr class="separator:ga7ab72656a5ae33734a73ce45ce3898ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2993b7da75827e6c1b3f5cec0c07043"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae2993b7da75827e6c1b3f5cec0c07043">fpmsc_c</a> (v4cfloat acc, v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gae2993b7da75827e6c1b3f5cec0c07043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex conjugate floating point vectors.  <a href="#gae2993b7da75827e6c1b3f5cec0c07043"></a><br/></td></tr>
<tr class="separator:gae2993b7da75827e6c1b3f5cec0c07043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3972c3afbdab25134038374116d054"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7f3972c3afbdab25134038374116d054">fpmsc_c</a> (v4cfloat acc, v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga7f3972c3afbdab25134038374116d054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex conjugate floating point vectors.  <a href="#ga7f3972c3afbdab25134038374116d054"></a><br/></td></tr>
<tr class="separator:ga7f3972c3afbdab25134038374116d054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9409abdf3043176386db5ecff9aaed3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad9409abdf3043176386db5ecff9aaed3">fpmsc_c</a> (v4cfloat acc, v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gad9409abdf3043176386db5ecff9aaed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex conjugate floating point vectors.  <a href="#gad9409abdf3043176386db5ecff9aaed3"></a><br/></td></tr>
<tr class="separator:gad9409abdf3043176386db5ecff9aaed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f678122e0d3f85280e4a6d52ef0666"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac3f678122e0d3f85280e4a6d52ef0666">fpmsc_c</a> (v4cfloat acc, v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac3f678122e0d3f85280e4a6d52ef0666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision real times complex conjugate floating point vectors.  <a href="#gac3f678122e0d3f85280e4a6d52ef0666"></a><br/></td></tr>
<tr class="separator:gac3f678122e0d3f85280e4a6d52ef0666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51dfefd36b61069425bad39aa442552c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga51dfefd36b61069425bad39aa442552c">fpmsc_c</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga51dfefd36b61069425bad39aa442552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times real floating point vectors.  <a href="#ga51dfefd36b61069425bad39aa442552c"></a><br/></td></tr>
<tr class="separator:ga51dfefd36b61069425bad39aa442552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca1610f790fb319284b66cbb99a1ddd"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7ca1610f790fb319284b66cbb99a1ddd">fpmsc_c</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga7ca1610f790fb319284b66cbb99a1ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times real floating point vectors.  <a href="#ga7ca1610f790fb319284b66cbb99a1ddd"></a><br/></td></tr>
<tr class="separator:ga7ca1610f790fb319284b66cbb99a1ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4677506514fdede016d8f4e58f43e832"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4677506514fdede016d8f4e58f43e832">fpmsc_c</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga4677506514fdede016d8f4e58f43e832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times real floating point vectors.  <a href="#ga4677506514fdede016d8f4e58f43e832"></a><br/></td></tr>
<tr class="separator:ga4677506514fdede016d8f4e58f43e832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa135603b3709c68efadd119505d0a571"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa135603b3709c68efadd119505d0a571">fpmsc_c</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa135603b3709c68efadd119505d0a571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times real floating point vectors.  <a href="#gaa135603b3709c68efadd119505d0a571"></a><br/></td></tr>
<tr class="separator:gaa135603b3709c68efadd119505d0a571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec935ca8e15f93d5f0efc3f6333c97bf"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaec935ca8e15f93d5f0efc3f6333c97bf">fpmsc_cc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaec935ca8e15f93d5f0efc3f6333c97bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gaec935ca8e15f93d5f0efc3f6333c97bf"></a><br/></td></tr>
<tr class="separator:gaec935ca8e15f93d5f0efc3f6333c97bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb14ff626bf7c31371a5ed1771fe06d2"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacb14ff626bf7c31371a5ed1771fe06d2">fpmsc_cc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gacb14ff626bf7c31371a5ed1771fe06d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gacb14ff626bf7c31371a5ed1771fe06d2"></a><br/></td></tr>
<tr class="separator:gacb14ff626bf7c31371a5ed1771fe06d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9b3c5678430d2a8771734a41faae4c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2f9b3c5678430d2a8771734a41faae4c">fpmsc_cc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga2f9b3c5678430d2a8771734a41faae4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga2f9b3c5678430d2a8771734a41faae4c"></a><br/></td></tr>
<tr class="separator:ga2f9b3c5678430d2a8771734a41faae4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4ea82b00fa78da0af7cddaf3a04cbe"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabf4ea82b00fa78da0af7cddaf3a04cbe">fpmsc_cc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabf4ea82b00fa78da0af7cddaf3a04cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gabf4ea82b00fa78da0af7cddaf3a04cbe"></a><br/></td></tr>
<tr class="separator:gabf4ea82b00fa78da0af7cddaf3a04cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5dbe5c771805b9bd0576a43927c38df"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab5dbe5c771805b9bd0576a43927c38df">fpmsc_cc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gab5dbe5c771805b9bd0576a43927c38df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gab5dbe5c771805b9bd0576a43927c38df"></a><br/></td></tr>
<tr class="separator:gab5dbe5c771805b9bd0576a43927c38df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8cd0a45e74324ef6ab5b25a17584a6"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2d8cd0a45e74324ef6ab5b25a17584a6">fpmsc_cc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga2d8cd0a45e74324ef6ab5b25a17584a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga2d8cd0a45e74324ef6ab5b25a17584a6"></a><br/></td></tr>
<tr class="separator:ga2d8cd0a45e74324ef6ab5b25a17584a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8edf5aebcf8e327a678200e634d94c1"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae8edf5aebcf8e327a678200e634d94c1">fpmsc_cc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gae8edf5aebcf8e327a678200e634d94c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gae8edf5aebcf8e327a678200e634d94c1"></a><br/></td></tr>
<tr class="separator:gae8edf5aebcf8e327a678200e634d94c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7e36a37765a481a499dfdedee72d28"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gade7e36a37765a481a499dfdedee72d28">fpmsc_cn</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gade7e36a37765a481a499dfdedee72d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#gade7e36a37765a481a499dfdedee72d28"></a><br/></td></tr>
<tr class="separator:gade7e36a37765a481a499dfdedee72d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43c3da72caaa60b17c38ab7f89210f3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf43c3da72caaa60b17c38ab7f89210f3">fpmsc_cn</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaf43c3da72caaa60b17c38ab7f89210f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#gaf43c3da72caaa60b17c38ab7f89210f3"></a><br/></td></tr>
<tr class="separator:gaf43c3da72caaa60b17c38ab7f89210f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c1ab97e206343b68c476e3be382580"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga07c1ab97e206343b68c476e3be382580">fpmsc_cn</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga07c1ab97e206343b68c476e3be382580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#ga07c1ab97e206343b68c476e3be382580"></a><br/></td></tr>
<tr class="separator:ga07c1ab97e206343b68c476e3be382580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183c817bf69b243993ebe610da98ad28"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga183c817bf69b243993ebe610da98ad28">fpmsc_cn</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga183c817bf69b243993ebe610da98ad28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#ga183c817bf69b243993ebe610da98ad28"></a><br/></td></tr>
<tr class="separator:ga183c817bf69b243993ebe610da98ad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09d45cf0a963de650f7c4ace03b0c61"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae09d45cf0a963de650f7c4ace03b0c61">fpmsc_cn</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gae09d45cf0a963de650f7c4ace03b0c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#gae09d45cf0a963de650f7c4ace03b0c61"></a><br/></td></tr>
<tr class="separator:gae09d45cf0a963de650f7c4ace03b0c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62290519cc7ebe8d23d6b8c2cd2caa96"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga62290519cc7ebe8d23d6b8c2cd2caa96">fpmsc_cn</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga62290519cc7ebe8d23d6b8c2cd2caa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#ga62290519cc7ebe8d23d6b8c2cd2caa96"></a><br/></td></tr>
<tr class="separator:ga62290519cc7ebe8d23d6b8c2cd2caa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd8bc25c9f07f4dd6dc417e4ffe94f60"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadd8bc25c9f07f4dd6dc417e4ffe94f60">fpmsc_cn</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gadd8bc25c9f07f4dd6dc417e4ffe94f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex conjugate times complex floating point vectors.  <a href="#gadd8bc25c9f07f4dd6dc417e4ffe94f60"></a><br/></td></tr>
<tr class="separator:gadd8bc25c9f07f4dd6dc417e4ffe94f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b8bb5f78a06ac2192ed88e648ebb48"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga00b8bb5f78a06ac2192ed88e648ebb48">fpmsc_nc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga00b8bb5f78a06ac2192ed88e648ebb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#ga00b8bb5f78a06ac2192ed88e648ebb48"></a><br/></td></tr>
<tr class="separator:ga00b8bb5f78a06ac2192ed88e648ebb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b32682b3b517b9c52e61dd91a9ca76"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga26b32682b3b517b9c52e61dd91a9ca76">fpmsc_nc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga26b32682b3b517b9c52e61dd91a9ca76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#ga26b32682b3b517b9c52e61dd91a9ca76"></a><br/></td></tr>
<tr class="separator:ga26b32682b3b517b9c52e61dd91a9ca76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9717796d4e29694c1e7b261680461994"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9717796d4e29694c1e7b261680461994">fpmsc_nc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9717796d4e29694c1e7b261680461994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#ga9717796d4e29694c1e7b261680461994"></a><br/></td></tr>
<tr class="separator:ga9717796d4e29694c1e7b261680461994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga263d882c3f00a96053ca838955ff5d67"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga263d882c3f00a96053ca838955ff5d67">fpmsc_nc</a> (v4cfloat acc, v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga263d882c3f00a96053ca838955ff5d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#ga263d882c3f00a96053ca838955ff5d67"></a><br/></td></tr>
<tr class="separator:ga263d882c3f00a96053ca838955ff5d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3101625520eaaf5633ec32f1e88ad22b"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3101625520eaaf5633ec32f1e88ad22b">fpmsc_nc</a> (v4cfloat acc, v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga3101625520eaaf5633ec32f1e88ad22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#ga3101625520eaaf5633ec32f1e88ad22b"></a><br/></td></tr>
<tr class="separator:ga3101625520eaaf5633ec32f1e88ad22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab3d3d6cd67f41c72e1eeef761b69ed5"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaab3d3d6cd67f41c72e1eeef761b69ed5">fpmsc_nc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaab3d3d6cd67f41c72e1eeef761b69ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#gaab3d3d6cd67f41c72e1eeef761b69ed5"></a><br/></td></tr>
<tr class="separator:gaab3d3d6cd67f41c72e1eeef761b69ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e59900d4c7a75dc13b83610d1c0fa05"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0e59900d4c7a75dc13b83610d1c0fa05">fpmsc_nc</a> (v4cfloat acc, v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0e59900d4c7a75dc13b83610d1c0fa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and subtract for single precision complex times complex conjugate floating point vectors.  <a href="#ga0e59900d4c7a75dc13b83610d1c0fa05"></a><br/></td></tr>
<tr class="separator:ga0e59900d4c7a75dc13b83610d1c0fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe843aeca1155835ee04b197b78b29e"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4fe843aeca1155835ee04b197b78b29e">fpmul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4fe843aeca1155835ee04b197b78b29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#ga4fe843aeca1155835ee04b197b78b29e"></a><br/></td></tr>
<tr class="separator:ga4fe843aeca1155835ee04b197b78b29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga139252f25a52ef219639f727bdbd4039"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga139252f25a52ef219639f727bdbd4039">fpmul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga139252f25a52ef219639f727bdbd4039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#ga139252f25a52ef219639f727bdbd4039"></a><br/></td></tr>
<tr class="separator:ga139252f25a52ef219639f727bdbd4039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6e4ca7df669b59e663c5db5ac8ad8d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaef6e4ca7df669b59e663c5db5ac8ad8d">fpmul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaef6e4ca7df669b59e663c5db5ac8ad8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex floating point vectors.  <a href="#gaef6e4ca7df669b59e663c5db5ac8ad8d"></a><br/></td></tr>
<tr class="separator:gaef6e4ca7df669b59e663c5db5ac8ad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835915c48a204091cac8d24ad5f5fb7d"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga835915c48a204091cac8d24ad5f5fb7d">fpmul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga835915c48a204091cac8d24ad5f5fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#ga835915c48a204091cac8d24ad5f5fb7d"></a><br/></td></tr>
<tr class="separator:ga835915c48a204091cac8d24ad5f5fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b9a4d59a4aa20f9ad25066f842d021"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga40b9a4d59a4aa20f9ad25066f842d021">fpmul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga40b9a4d59a4aa20f9ad25066f842d021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#ga40b9a4d59a4aa20f9ad25066f842d021"></a><br/></td></tr>
<tr class="separator:ga40b9a4d59a4aa20f9ad25066f842d021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3064b16102c89b644eadf61853e68e65"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3064b16102c89b644eadf61853e68e65">fpmul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga3064b16102c89b644eadf61853e68e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#ga3064b16102c89b644eadf61853e68e65"></a><br/></td></tr>
<tr class="separator:ga3064b16102c89b644eadf61853e68e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff7b0cbd53c325912b0496294322635"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4ff7b0cbd53c325912b0496294322635">fpmul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4ff7b0cbd53c325912b0496294322635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex floating point vectors.  <a href="#ga4ff7b0cbd53c325912b0496294322635"></a><br/></td></tr>
<tr class="separator:ga4ff7b0cbd53c325912b0496294322635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01218efe1647c71a21a78c62c53a57f5"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga01218efe1647c71a21a78c62c53a57f5">fpmul</a> (v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga01218efe1647c71a21a78c62c53a57f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex floating point vectors.  <a href="#ga01218efe1647c71a21a78c62c53a57f5"></a><br/></td></tr>
<tr class="separator:ga01218efe1647c71a21a78c62c53a57f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa503b32381bbe29d31f1736abb32e0b6"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa503b32381bbe29d31f1736abb32e0b6">fpmul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa503b32381bbe29d31f1736abb32e0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#gaa503b32381bbe29d31f1736abb32e0b6"></a><br/></td></tr>
<tr class="separator:gaa503b32381bbe29d31f1736abb32e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e227b979aba4c06ee90aaa73c2dd9b"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga06e227b979aba4c06ee90aaa73c2dd9b">fpmul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga06e227b979aba4c06ee90aaa73c2dd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times real floating point vectors.  <a href="#ga06e227b979aba4c06ee90aaa73c2dd9b"></a><br/></td></tr>
<tr class="separator:ga06e227b979aba4c06ee90aaa73c2dd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79fa774a15884fda26cf5ec390db2d31"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga79fa774a15884fda26cf5ec390db2d31">fpmul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga79fa774a15884fda26cf5ec390db2d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex floating point vectors.  <a href="#ga79fa774a15884fda26cf5ec390db2d31"></a><br/></td></tr>
<tr class="separator:ga79fa774a15884fda26cf5ec390db2d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc71fc8ca2fb42b277e8cece0407bf44"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafc71fc8ca2fb42b277e8cece0407bf44">fpmul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gafc71fc8ca2fb42b277e8cece0407bf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times real floating point vectors.  <a href="#gafc71fc8ca2fb42b277e8cece0407bf44"></a><br/></td></tr>
<tr class="separator:gafc71fc8ca2fb42b277e8cece0407bf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed6eb2d8a76e056a34a352f8659842b"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8ed6eb2d8a76e056a34a352f8659842b">fpmul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8ed6eb2d8a76e056a34a352f8659842b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#ga8ed6eb2d8a76e056a34a352f8659842b"></a><br/></td></tr>
<tr class="separator:ga8ed6eb2d8a76e056a34a352f8659842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac63be461209dfd01f27fe5bda4cb5bdc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac63be461209dfd01f27fe5bda4cb5bdc">fpmul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac63be461209dfd01f27fe5bda4cb5bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#gac63be461209dfd01f27fe5bda4cb5bdc"></a><br/></td></tr>
<tr class="separator:gac63be461209dfd01f27fe5bda4cb5bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0623cbfefba2f406c172ebf78cc8c3a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae0623cbfefba2f406c172ebf78cc8c3a">fpmul</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gae0623cbfefba2f406c172ebf78cc8c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times real floating point vectors.  <a href="#gae0623cbfefba2f406c172ebf78cc8c3a"></a><br/></td></tr>
<tr class="separator:gae0623cbfefba2f406c172ebf78cc8c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f9740ca63154db10d7748e234879cc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga43f9740ca63154db10d7748e234879cc">fpmul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga43f9740ca63154db10d7748e234879cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times real floating point vectors.  <a href="#ga43f9740ca63154db10d7748e234879cc"></a><br/></td></tr>
<tr class="separator:ga43f9740ca63154db10d7748e234879cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b696862928c431e495ef6e5113c9926"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8b696862928c431e495ef6e5113c9926">fpmul</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8b696862928c431e495ef6e5113c9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#ga8b696862928c431e495ef6e5113c9926"></a><br/></td></tr>
<tr class="separator:ga8b696862928c431e495ef6e5113c9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99cd596be05760a5e5831ddf2b850f4b"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga99cd596be05760a5e5831ddf2b850f4b">fpmul</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga99cd596be05760a5e5831ddf2b850f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#ga99cd596be05760a5e5831ddf2b850f4b"></a><br/></td></tr>
<tr class="separator:ga99cd596be05760a5e5831ddf2b850f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5a78fc3c73315049db5bff3f8f1126"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2c5a78fc3c73315049db5bff3f8f1126">fpmul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga2c5a78fc3c73315049db5bff3f8f1126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#ga2c5a78fc3c73315049db5bff3f8f1126"></a><br/></td></tr>
<tr class="separator:ga2c5a78fc3c73315049db5bff3f8f1126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665ec0814aaf7cdac43bd3e5068e3e8e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga665ec0814aaf7cdac43bd3e5068e3e8e">fpmul</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga665ec0814aaf7cdac43bd3e5068e3e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times real floating point vectors.  <a href="#ga665ec0814aaf7cdac43bd3e5068e3e8e"></a><br/></td></tr>
<tr class="separator:ga665ec0814aaf7cdac43bd3e5068e3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f1f8d8fcf8d00446ecf799b9883800"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga91f1f8d8fcf8d00446ecf799b9883800">fpmul</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga91f1f8d8fcf8d00446ecf799b9883800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#ga91f1f8d8fcf8d00446ecf799b9883800"></a><br/></td></tr>
<tr class="separator:ga91f1f8d8fcf8d00446ecf799b9883800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae0c48377d6fcc432b66273a2256bf4"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9ae0c48377d6fcc432b66273a2256bf4">fpmul</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9ae0c48377d6fcc432b66273a2256bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex floating point vectors.  <a href="#ga9ae0c48377d6fcc432b66273a2256bf4"></a><br/></td></tr>
<tr class="separator:ga9ae0c48377d6fcc432b66273a2256bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7a23ed440b11dc6b3bd61577de35d7"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabb7a23ed440b11dc6b3bd61577de35d7">fpmul_c</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabb7a23ed440b11dc6b3bd61577de35d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex conjugate floating point vectors.  <a href="#gabb7a23ed440b11dc6b3bd61577de35d7"></a><br/></td></tr>
<tr class="separator:gabb7a23ed440b11dc6b3bd61577de35d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f36771a35e37c75e36e435441127d6"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad3f36771a35e37c75e36e435441127d6">fpmul_c</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gad3f36771a35e37c75e36e435441127d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex conjugate floating point vectors.  <a href="#gad3f36771a35e37c75e36e435441127d6"></a><br/></td></tr>
<tr class="separator:gad3f36771a35e37c75e36e435441127d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63abe47a977aeb61f433a8ae3c81b2ae"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga63abe47a977aeb61f433a8ae3c81b2ae">fpmul_c</a> (v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga63abe47a977aeb61f433a8ae3c81b2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex conjugate floating point vectors.  <a href="#ga63abe47a977aeb61f433a8ae3c81b2ae"></a><br/></td></tr>
<tr class="separator:ga63abe47a977aeb61f433a8ae3c81b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5667db6d3983eea7aa56032f0cef9f81"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5667db6d3983eea7aa56032f0cef9f81">fpmul_c</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5667db6d3983eea7aa56032f0cef9f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision real times complex conjugate floating point vectors.  <a href="#ga5667db6d3983eea7aa56032f0cef9f81"></a><br/></td></tr>
<tr class="separator:ga5667db6d3983eea7aa56032f0cef9f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ba933fa567fa779f588e475070024d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga51ba933fa567fa779f588e475070024d">fpmul_c</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga51ba933fa567fa779f588e475070024d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times real floating point vectors.  <a href="#ga51ba933fa567fa779f588e475070024d"></a><br/></td></tr>
<tr class="separator:ga51ba933fa567fa779f588e475070024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab871b3b22bb58b789f6a911b3b4680d1"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab871b3b22bb58b789f6a911b3b4680d1">fpmul_c</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab871b3b22bb58b789f6a911b3b4680d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times real floating point vectors.  <a href="#gab871b3b22bb58b789f6a911b3b4680d1"></a><br/></td></tr>
<tr class="separator:gab871b3b22bb58b789f6a911b3b4680d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d40a65b597942289cb1672819583400"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2d40a65b597942289cb1672819583400">fpmul_c</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga2d40a65b597942289cb1672819583400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times real floating point vectors.  <a href="#ga2d40a65b597942289cb1672819583400"></a><br/></td></tr>
<tr class="separator:ga2d40a65b597942289cb1672819583400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529fd90984651a9e0e421e1dff5498b3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga529fd90984651a9e0e421e1dff5498b3">fpmul_c</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga529fd90984651a9e0e421e1dff5498b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times real floating point vectors.  <a href="#ga529fd90984651a9e0e421e1dff5498b3"></a><br/></td></tr>
<tr class="separator:ga529fd90984651a9e0e421e1dff5498b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a6d4fce38258a9778885b7856b19ee"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga20a6d4fce38258a9778885b7856b19ee">fpmul_cc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga20a6d4fce38258a9778885b7856b19ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga20a6d4fce38258a9778885b7856b19ee"></a><br/></td></tr>
<tr class="separator:ga20a6d4fce38258a9778885b7856b19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b656e2a1cbfd65130ecce72f5a0ac48"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7b656e2a1cbfd65130ecce72f5a0ac48">fpmul_cc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga7b656e2a1cbfd65130ecce72f5a0ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga7b656e2a1cbfd65130ecce72f5a0ac48"></a><br/></td></tr>
<tr class="separator:ga7b656e2a1cbfd65130ecce72f5a0ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a28ff1b7a6e615b2abd3f7a98444e2d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4a28ff1b7a6e615b2abd3f7a98444e2d">fpmul_cc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4a28ff1b7a6e615b2abd3f7a98444e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga4a28ff1b7a6e615b2abd3f7a98444e2d"></a><br/></td></tr>
<tr class="separator:ga4a28ff1b7a6e615b2abd3f7a98444e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18be7dabebe81f2a06fce883fbdfbfca"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga18be7dabebe81f2a06fce883fbdfbfca">fpmul_cc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga18be7dabebe81f2a06fce883fbdfbfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga18be7dabebe81f2a06fce883fbdfbfca"></a><br/></td></tr>
<tr class="separator:ga18be7dabebe81f2a06fce883fbdfbfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190dbe4ae3f96249b8f4532c0d1d6b82"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga190dbe4ae3f96249b8f4532c0d1d6b82">fpmul_cc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga190dbe4ae3f96249b8f4532c0d1d6b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga190dbe4ae3f96249b8f4532c0d1d6b82"></a><br/></td></tr>
<tr class="separator:ga190dbe4ae3f96249b8f4532c0d1d6b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1747c817d90b172bb78e79f04e5d3a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabf1747c817d90b172bb78e79f04e5d3a">fpmul_cc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabf1747c817d90b172bb78e79f04e5d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gabf1747c817d90b172bb78e79f04e5d3a"></a><br/></td></tr>
<tr class="separator:gabf1747c817d90b172bb78e79f04e5d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb08d9f26584c6f7a5fa791271d30504"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabb08d9f26584c6f7a5fa791271d30504">fpmul_cc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabb08d9f26584c6f7a5fa791271d30504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gabb08d9f26584c6f7a5fa791271d30504"></a><br/></td></tr>
<tr class="separator:gabb08d9f26584c6f7a5fa791271d30504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e736c3978ee671e795fcb64c4c42649"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9e736c3978ee671e795fcb64c4c42649">fpmul_cn</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9e736c3978ee671e795fcb64c4c42649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#ga9e736c3978ee671e795fcb64c4c42649"></a><br/></td></tr>
<tr class="separator:ga9e736c3978ee671e795fcb64c4c42649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d52132dd98f920e42f47e8d6710fbb"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga04d52132dd98f920e42f47e8d6710fbb">fpmul_cn</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga04d52132dd98f920e42f47e8d6710fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#ga04d52132dd98f920e42f47e8d6710fbb"></a><br/></td></tr>
<tr class="separator:ga04d52132dd98f920e42f47e8d6710fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347652212313d8295d1c3135fca7543e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga347652212313d8295d1c3135fca7543e">fpmul_cn</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga347652212313d8295d1c3135fca7543e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#ga347652212313d8295d1c3135fca7543e"></a><br/></td></tr>
<tr class="separator:ga347652212313d8295d1c3135fca7543e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d1fb83e860c21ab1d906b3fe741537"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga50d1fb83e860c21ab1d906b3fe741537">fpmul_cn</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga50d1fb83e860c21ab1d906b3fe741537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#ga50d1fb83e860c21ab1d906b3fe741537"></a><br/></td></tr>
<tr class="separator:ga50d1fb83e860c21ab1d906b3fe741537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3123782776a2c672592fce679b36698"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad3123782776a2c672592fce679b36698">fpmul_cn</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gad3123782776a2c672592fce679b36698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#gad3123782776a2c672592fce679b36698"></a><br/></td></tr>
<tr class="separator:gad3123782776a2c672592fce679b36698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6f31632d50692b9a13cd83b825271e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaef6f31632d50692b9a13cd83b825271e">fpmul_cn</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaef6f31632d50692b9a13cd83b825271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#gaef6f31632d50692b9a13cd83b825271e"></a><br/></td></tr>
<tr class="separator:gaef6f31632d50692b9a13cd83b825271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088dd249cd3d0c431190e2dec4cbecb7"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga088dd249cd3d0c431190e2dec4cbecb7">fpmul_cn</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga088dd249cd3d0c431190e2dec4cbecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex conjugate times complex floating point vectors.  <a href="#ga088dd249cd3d0c431190e2dec4cbecb7"></a><br/></td></tr>
<tr class="separator:ga088dd249cd3d0c431190e2dec4cbecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8817e518861808d8471bbe660d7c08d4"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8817e518861808d8471bbe660d7c08d4">fpmul_conf</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga8817e518861808d8471bbe660d7c08d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga8817e518861808d8471bbe660d7c08d4"></a><br/></td></tr>
<tr class="separator:ga8817e518861808d8471bbe660d7c08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5646f302d9fc0a4904a438b77123df"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3b5646f302d9fc0a4904a438b77123df">fpmul_conf</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga3b5646f302d9fc0a4904a438b77123df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga3b5646f302d9fc0a4904a438b77123df"></a><br/></td></tr>
<tr class="separator:ga3b5646f302d9fc0a4904a438b77123df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8afe0abe5f3a3ba74ffb6b18aa89a14"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa8afe0abe5f3a3ba74ffb6b18aa89a14">fpmul_conf</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gaa8afe0abe5f3a3ba74ffb6b18aa89a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gaa8afe0abe5f3a3ba74ffb6b18aa89a14"></a><br/></td></tr>
<tr class="separator:gaa8afe0abe5f3a3ba74ffb6b18aa89a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8abcefe23f74594f601cc675900219"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7d8abcefe23f74594f601cc675900219">fpmul_conf</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga7d8abcefe23f74594f601cc675900219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga7d8abcefe23f74594f601cc675900219"></a><br/></td></tr>
<tr class="separator:ga7d8abcefe23f74594f601cc675900219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de18900613e0272f6ac920f8ccef9b8"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0de18900613e0272f6ac920f8ccef9b8">fpmul_conf</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga0de18900613e0272f6ac920f8ccef9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga0de18900613e0272f6ac920f8ccef9b8"></a><br/></td></tr>
<tr class="separator:ga0de18900613e0272f6ac920f8ccef9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b881ba5c318239e070143f3c65a0517"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1b881ba5c318239e070143f3c65a0517">fpmul_conf</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga1b881ba5c318239e070143f3c65a0517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga1b881ba5c318239e070143f3c65a0517"></a><br/></td></tr>
<tr class="separator:ga1b881ba5c318239e070143f3c65a0517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7d35cdb3c698d342aa625827c085a7"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1b7d35cdb3c698d342aa625827c085a7">fpmul_conf</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga1b7d35cdb3c698d342aa625827c085a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga1b7d35cdb3c698d342aa625827c085a7"></a><br/></td></tr>
<tr class="separator:ga1b7d35cdb3c698d342aa625827c085a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea8f1855b08cea6cf96a26dd1376751"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacea8f1855b08cea6cf96a26dd1376751">fpmul_conf</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gacea8f1855b08cea6cf96a26dd1376751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gacea8f1855b08cea6cf96a26dd1376751"></a><br/></td></tr>
<tr class="separator:gacea8f1855b08cea6cf96a26dd1376751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2700e0f68cad3751c0670b4799e674b4"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2700e0f68cad3751c0670b4799e674b4">fpmul_conf</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga2700e0f68cad3751c0670b4799e674b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga2700e0f68cad3751c0670b4799e674b4"></a><br/></td></tr>
<tr class="separator:ga2700e0f68cad3751c0670b4799e674b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d5d98e6bb51fa0cf8e8b1492653a7d"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga17d5d98e6bb51fa0cf8e8b1492653a7d">fpmul_conf</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga17d5d98e6bb51fa0cf8e8b1492653a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga17d5d98e6bb51fa0cf8e8b1492653a7d"></a><br/></td></tr>
<tr class="separator:ga17d5d98e6bb51fa0cf8e8b1492653a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8c325c8b8d3c1dcd0f5c7c7450d4bf50">fpmul_conf</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"></a><br/></td></tr>
<tr class="separator:ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd3a3c6e6d74bd75e064d6f2f1175ce"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3bd3a3c6e6d74bd75e064d6f2f1175ce">fpmul_conf</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga3bd3a3c6e6d74bd75e064d6f2f1175ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga3bd3a3c6e6d74bd75e064d6f2f1175ce"></a><br/></td></tr>
<tr class="separator:ga3bd3a3c6e6d74bd75e064d6f2f1175ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d6e2a16d63a97464038d1e8fc70eeb"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga30d6e2a16d63a97464038d1e8fc70eeb">fpmul_conf</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga30d6e2a16d63a97464038d1e8fc70eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga30d6e2a16d63a97464038d1e8fc70eeb"></a><br/></td></tr>
<tr class="separator:ga30d6e2a16d63a97464038d1e8fc70eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e9e9fcd47151968c33a9374ca4c467"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga20e9e9fcd47151968c33a9374ca4c467">fpmul_conf</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga20e9e9fcd47151968c33a9374ca4c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga20e9e9fcd47151968c33a9374ca4c467"></a><br/></td></tr>
<tr class="separator:ga20e9e9fcd47151968c33a9374ca4c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf5c992722b320d02e3d1f0a918de70"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafbf5c992722b320d02e3d1f0a918de70">fpmul_conf</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gafbf5c992722b320d02e3d1f0a918de70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gafbf5c992722b320d02e3d1f0a918de70"></a><br/></td></tr>
<tr class="separator:gafbf5c992722b320d02e3d1f0a918de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1099b4410e8f84c7af1518c740ab437"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad1099b4410e8f84c7af1518c740ab437">fpmul_conf</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gad1099b4410e8f84c7af1518c740ab437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gad1099b4410e8f84c7af1518c740ab437"></a><br/></td></tr>
<tr class="separator:gad1099b4410e8f84c7af1518c740ab437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869745c907faf2171d869ecdebba676e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga869745c907faf2171d869ecdebba676e">fpmul_conf</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga869745c907faf2171d869ecdebba676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga869745c907faf2171d869ecdebba676e"></a><br/></td></tr>
<tr class="separator:ga869745c907faf2171d869ecdebba676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9d4d3e1f4697909c09910608736ae6"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacd9d4d3e1f4697909c09910608736ae6">fpmul_conf</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gacd9d4d3e1f4697909c09910608736ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gacd9d4d3e1f4697909c09910608736ae6"></a><br/></td></tr>
<tr class="separator:gacd9d4d3e1f4697909c09910608736ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb018ddbebbb5f7eb80cd8bc6b776509"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadb018ddbebbb5f7eb80cd8bc6b776509">fpmul_conf</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gadb018ddbebbb5f7eb80cd8bc6b776509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gadb018ddbebbb5f7eb80cd8bc6b776509"></a><br/></td></tr>
<tr class="separator:gadb018ddbebbb5f7eb80cd8bc6b776509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2d3900511ea498196c46893d1023fc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaeb2d3900511ea498196c46893d1023fc">fpmul_conf</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gaeb2d3900511ea498196c46893d1023fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gaeb2d3900511ea498196c46893d1023fc"></a><br/></td></tr>
<tr class="separator:gaeb2d3900511ea498196c46893d1023fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb9dc04dc4e3d66bb0eb40a7baefabc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga6bb9dc04dc4e3d66bb0eb40a7baefabc">fpmul_conf</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga6bb9dc04dc4e3d66bb0eb40a7baefabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga6bb9dc04dc4e3d66bb0eb40a7baefabc"></a><br/></td></tr>
<tr class="separator:ga6bb9dc04dc4e3d66bb0eb40a7baefabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ad1ec2d24249fecb1b07762d4e80ff"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf5ad1ec2d24249fecb1b07762d4e80ff">fpmul_conf</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gaf5ad1ec2d24249fecb1b07762d4e80ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gaf5ad1ec2d24249fecb1b07762d4e80ff"></a><br/></td></tr>
<tr class="separator:gaf5ad1ec2d24249fecb1b07762d4e80ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f708ddfd2968f21a4804861c56c7d2"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga44f708ddfd2968f21a4804861c56c7d2">fpmul_conf</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga44f708ddfd2968f21a4804861c56c7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga44f708ddfd2968f21a4804861c56c7d2"></a><br/></td></tr>
<tr class="separator:ga44f708ddfd2968f21a4804861c56c7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935db197f922a0db6b42f0bfe8430222"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga935db197f922a0db6b42f0bfe8430222">fpmul_conf</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga935db197f922a0db6b42f0bfe8430222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga935db197f922a0db6b42f0bfe8430222"></a><br/></td></tr>
<tr class="separator:ga935db197f922a0db6b42f0bfe8430222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98234f63c4eaf04e9b1ab399acc7fce"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab98234f63c4eaf04e9b1ab399acc7fce">fpmul_conf</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gab98234f63c4eaf04e9b1ab399acc7fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gab98234f63c4eaf04e9b1ab399acc7fce"></a><br/></td></tr>
<tr class="separator:gab98234f63c4eaf04e9b1ab399acc7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0d44cb23159974ff487ae1adcc6097"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8e0d44cb23159974ff487ae1adcc6097">fpmul_conf</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga8e0d44cb23159974ff487ae1adcc6097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga8e0d44cb23159974ff487ae1adcc6097"></a><br/></td></tr>
<tr class="separator:ga8e0d44cb23159974ff487ae1adcc6097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665272a82dd053ce671ae28db33ba7bc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga665272a82dd053ce671ae28db33ba7bc">fpmul_conf</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga665272a82dd053ce671ae28db33ba7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga665272a82dd053ce671ae28db33ba7bc"></a><br/></td></tr>
<tr class="separator:ga665272a82dd053ce671ae28db33ba7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e090062933d16c1753285763a50e02"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga62e090062933d16c1753285763a50e02">fpmul_conf</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga62e090062933d16c1753285763a50e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga62e090062933d16c1753285763a50e02"></a><br/></td></tr>
<tr class="separator:ga62e090062933d16c1753285763a50e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58850c0179b60e60f76ecf55308d979"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad58850c0179b60e60f76ecf55308d979">fpmul_conf</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:gad58850c0179b60e60f76ecf55308d979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gad58850c0179b60e60f76ecf55308d979"></a><br/></td></tr>
<tr class="separator:gad58850c0179b60e60f76ecf55308d979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae715d9690aac3f88784ca2414b3b74f7"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae715d9690aac3f88784ca2414b3b74f7">fpmul_conf</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gae715d9690aac3f88784ca2414b3b74f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gae715d9690aac3f88784ca2414b3b74f7"></a><br/></td></tr>
<tr class="separator:gae715d9690aac3f88784ca2414b3b74f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2199bc6d5389a86e31843d5589d4cd78"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2199bc6d5389a86e31843d5589d4cd78">fpmul_conf</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga2199bc6d5389a86e31843d5589d4cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga2199bc6d5389a86e31843d5589d4cd78"></a><br/></td></tr>
<tr class="separator:ga2199bc6d5389a86e31843d5589d4cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134dd2770e84c1ec768de42e1c394f4d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga134dd2770e84c1ec768de42e1c394f4d">fpmul_conf</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga134dd2770e84c1ec768de42e1c394f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga134dd2770e84c1ec768de42e1c394f4d"></a><br/></td></tr>
<tr class="separator:ga134dd2770e84c1ec768de42e1c394f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c8c929e6f022ef735e3ca22051814d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga41c8c929e6f022ef735e3ca22051814d">fpmul_conf</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga41c8c929e6f022ef735e3ca22051814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga41c8c929e6f022ef735e3ca22051814d"></a><br/></td></tr>
<tr class="separator:ga41c8c929e6f022ef735e3ca22051814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4b185fd15f9215581a3ca6696215d0"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1a4b185fd15f9215581a3ca6696215d0">fpmul_conf</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga1a4b185fd15f9215581a3ca6696215d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga1a4b185fd15f9215581a3ca6696215d0"></a><br/></td></tr>
<tr class="separator:ga1a4b185fd15f9215581a3ca6696215d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f039649eb3e694153aae0640a4081da"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2f039649eb3e694153aae0640a4081da">fpmul_conf</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;<a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>)</td></tr>
<tr class="memdesc:ga2f039649eb3e694153aae0640a4081da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#ga2f039649eb3e694153aae0640a4081da"></a><br/></td></tr>
<tr class="separator:ga2f039649eb3e694153aae0640a4081da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28a10c8a3de173bb0a390d76ad09e5a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab28a10c8a3de173bb0a390d76ad09e5a">fpmul_conf</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab28a10c8a3de173bb0a390d76ad09e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable multiply for single precision floating point vectors.  <a href="#gab28a10c8a3de173bb0a390d76ad09e5a"></a><br/></td></tr>
<tr class="separator:gab28a10c8a3de173bb0a390d76ad09e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ff9f143dbcbd87c11a8081edaebbbe"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga42ff9f143dbcbd87c11a8081edaebbbe">fpmul_nc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga42ff9f143dbcbd87c11a8081edaebbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#ga42ff9f143dbcbd87c11a8081edaebbbe"></a><br/></td></tr>
<tr class="separator:ga42ff9f143dbcbd87c11a8081edaebbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad280005472d614e6d5f132984b33f1ef"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad280005472d614e6d5f132984b33f1ef">fpmul_nc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gad280005472d614e6d5f132984b33f1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#gad280005472d614e6d5f132984b33f1ef"></a><br/></td></tr>
<tr class="separator:gad280005472d614e6d5f132984b33f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732ac4e7455035cd647d048eeb05b772"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga732ac4e7455035cd647d048eeb05b772">fpmul_nc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga732ac4e7455035cd647d048eeb05b772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#ga732ac4e7455035cd647d048eeb05b772"></a><br/></td></tr>
<tr class="separator:ga732ac4e7455035cd647d048eeb05b772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b2a15403e6d93bd413a2727117f093"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac0b2a15403e6d93bd413a2727117f093">fpmul_nc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac0b2a15403e6d93bd413a2727117f093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#gac0b2a15403e6d93bd413a2727117f093"></a><br/></td></tr>
<tr class="separator:gac0b2a15403e6d93bd413a2727117f093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f480b83bd3a2067a3b6140498d0f25"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac6f480b83bd3a2067a3b6140498d0f25">fpmul_nc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gac6f480b83bd3a2067a3b6140498d0f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#gac6f480b83bd3a2067a3b6140498d0f25"></a><br/></td></tr>
<tr class="separator:gac6f480b83bd3a2067a3b6140498d0f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4fdacb0a283a9cccaf165547ede327"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5e4fdacb0a283a9cccaf165547ede327">fpmul_nc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5e4fdacb0a283a9cccaf165547ede327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#ga5e4fdacb0a283a9cccaf165547ede327"></a><br/></td></tr>
<tr class="separator:ga5e4fdacb0a283a9cccaf165547ede327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8438bb2171a72aea5ff7462ffc8a8b2"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab8438bb2171a72aea5ff7462ffc8a8b2">fpmul_nc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab8438bb2171a72aea5ff7462ffc8a8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply for single precision complex times complex conjugate floating point vectors.  <a href="#gab8438bb2171a72aea5ff7462ffc8a8b2"></a><br/></td></tr>
<tr class="separator:gab8438bb2171a72aea5ff7462ffc8a8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022119108cc3a3d4bbab689e0b344621"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga022119108cc3a3d4bbab689e0b344621">fpneg_abs_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga022119108cc3a3d4bbab689e0b344621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#ga022119108cc3a3d4bbab689e0b344621"></a><br/></td></tr>
<tr class="separator:ga022119108cc3a3d4bbab689e0b344621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87acdde800a7a19e2b59449c059da7bd"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga87acdde800a7a19e2b59449c059da7bd">fpneg_abs_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga87acdde800a7a19e2b59449c059da7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#ga87acdde800a7a19e2b59449c059da7bd"></a><br/></td></tr>
<tr class="separator:ga87acdde800a7a19e2b59449c059da7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71a0b6fb38bf7749602504501aa1498"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab71a0b6fb38bf7749602504501aa1498">fpneg_abs_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab71a0b6fb38bf7749602504501aa1498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#gab71a0b6fb38bf7749602504501aa1498"></a><br/></td></tr>
<tr class="separator:gab71a0b6fb38bf7749602504501aa1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace69229c4d8e678144d283689f2a8e65"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gace69229c4d8e678144d283689f2a8e65">fpneg_abs_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gace69229c4d8e678144d283689f2a8e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#gace69229c4d8e678144d283689f2a8e65"></a><br/></td></tr>
<tr class="separator:gace69229c4d8e678144d283689f2a8e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f03c8ade33b723e3724c595247237b4"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9f03c8ade33b723e3724c595247237b4">fpneg_abs_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:ga9f03c8ade33b723e3724c595247237b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#ga9f03c8ade33b723e3724c595247237b4"></a><br/></td></tr>
<tr class="separator:ga9f03c8ade33b723e3724c595247237b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca258d5056d7d097365ed2ab83a92ad9"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaca258d5056d7d097365ed2ab83a92ad9">fpneg_abs_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaca258d5056d7d097365ed2ab83a92ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#gaca258d5056d7d097365ed2ab83a92ad9"></a><br/></td></tr>
<tr class="separator:gaca258d5056d7d097365ed2ab83a92ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2a8f5b81c7572a8f695634979d185b"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2d2a8f5b81c7572a8f695634979d185b">fpneg_abs_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga2d2a8f5b81c7572a8f695634979d185b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real times real floating point vectors.  <a href="#ga2d2a8f5b81c7572a8f695634979d185b"></a><br/></td></tr>
<tr class="separator:ga2d2a8f5b81c7572a8f695634979d185b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7776d97fafce9f1c5a71a60d3f8fda"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabf7776d97fafce9f1c5a71a60d3f8fda">fpneg_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabf7776d97fafce9f1c5a71a60d3f8fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#gabf7776d97fafce9f1c5a71a60d3f8fda"></a><br/></td></tr>
<tr class="separator:gabf7776d97fafce9f1c5a71a60d3f8fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5b8634b62c072fe4e81a47f5469e63"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafb5b8634b62c072fe4e81a47f5469e63">fpneg_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gafb5b8634b62c072fe4e81a47f5469e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#gafb5b8634b62c072fe4e81a47f5469e63"></a><br/></td></tr>
<tr class="separator:gafb5b8634b62c072fe4e81a47f5469e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65db77d97f4cf07d5236bdef3d7e64bc"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga65db77d97f4cf07d5236bdef3d7e64bc">fpneg_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga65db77d97f4cf07d5236bdef3d7e64bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex floating point vectors.  <a href="#ga65db77d97f4cf07d5236bdef3d7e64bc"></a><br/></td></tr>
<tr class="separator:ga65db77d97f4cf07d5236bdef3d7e64bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3238d3340096b7a9711d6f94ff4a3c5c"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3238d3340096b7a9711d6f94ff4a3c5c">fpneg_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga3238d3340096b7a9711d6f94ff4a3c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#ga3238d3340096b7a9711d6f94ff4a3c5c"></a><br/></td></tr>
<tr class="separator:ga3238d3340096b7a9711d6f94ff4a3c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a71ff908ea8b3d050f9f3b9e23d29e"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga29a71ff908ea8b3d050f9f3b9e23d29e">fpneg_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga29a71ff908ea8b3d050f9f3b9e23d29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#ga29a71ff908ea8b3d050f9f3b9e23d29e"></a><br/></td></tr>
<tr class="separator:ga29a71ff908ea8b3d050f9f3b9e23d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad7c4d71ac19a29794662584d72b8e2e"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaad7c4d71ac19a29794662584d72b8e2e">fpneg_mul</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gaad7c4d71ac19a29794662584d72b8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#gaad7c4d71ac19a29794662584d72b8e2e"></a><br/></td></tr>
<tr class="separator:gaad7c4d71ac19a29794662584d72b8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e49278ec57725b4e7da150b9074cf8"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa3e49278ec57725b4e7da150b9074cf8">fpneg_mul</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa3e49278ec57725b4e7da150b9074cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex floating point vectors.  <a href="#gaa3e49278ec57725b4e7da150b9074cf8"></a><br/></td></tr>
<tr class="separator:gaa3e49278ec57725b4e7da150b9074cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ff50f36c3287fde485c7aa08829ebe"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga16ff50f36c3287fde485c7aa08829ebe">fpneg_mul</a> (v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga16ff50f36c3287fde485c7aa08829ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex floating point vectors.  <a href="#ga16ff50f36c3287fde485c7aa08829ebe"></a><br/></td></tr>
<tr class="separator:ga16ff50f36c3287fde485c7aa08829ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0218ee177f14aa89eebe5aa3abe596bf"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0218ee177f14aa89eebe5aa3abe596bf">fpneg_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0218ee177f14aa89eebe5aa3abe596bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#ga0218ee177f14aa89eebe5aa3abe596bf"></a><br/></td></tr>
<tr class="separator:ga0218ee177f14aa89eebe5aa3abe596bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbde825857ab1970a955710c0017f471"><td class="memItemLeft" align="right" valign="top">v8float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabbde825857ab1970a955710c0017f471">fpneg_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabbde825857ab1970a955710c0017f471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times real floating point vectors.  <a href="#gabbde825857ab1970a955710c0017f471"></a><br/></td></tr>
<tr class="separator:gabbde825857ab1970a955710c0017f471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae832f48fbe247e2fc5d5a944210e21"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadae832f48fbe247e2fc5d5a944210e21">fpneg_mul</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gadae832f48fbe247e2fc5d5a944210e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex floating point vectors.  <a href="#gadae832f48fbe247e2fc5d5a944210e21"></a><br/></td></tr>
<tr class="separator:gadae832f48fbe247e2fc5d5a944210e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae72904deca72ed7cf05479f83c00731"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaae72904deca72ed7cf05479f83c00731">fpneg_mul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaae72904deca72ed7cf05479f83c00731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times real floating point vectors.  <a href="#gaae72904deca72ed7cf05479f83c00731"></a><br/></td></tr>
<tr class="separator:gaae72904deca72ed7cf05479f83c00731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f4236bfb02eaedc8a71b85cf6f4c868"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8f4236bfb02eaedc8a71b85cf6f4c868">fpneg_mul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8f4236bfb02eaedc8a71b85cf6f4c868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#ga8f4236bfb02eaedc8a71b85cf6f4c868"></a><br/></td></tr>
<tr class="separator:ga8f4236bfb02eaedc8a71b85cf6f4c868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8c402e8f796de9367a19a7aceeefb8"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafb8c402e8f796de9367a19a7aceeefb8">fpneg_mul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gafb8c402e8f796de9367a19a7aceeefb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#gafb8c402e8f796de9367a19a7aceeefb8"></a><br/></td></tr>
<tr class="separator:gafb8c402e8f796de9367a19a7aceeefb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8e2ad8957c319518044c6d73d12b3e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaff8e2ad8957c319518044c6d73d12b3e">fpneg_mul</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaff8e2ad8957c319518044c6d73d12b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times real floating point vectors.  <a href="#gaff8e2ad8957c319518044c6d73d12b3e"></a><br/></td></tr>
<tr class="separator:gaff8e2ad8957c319518044c6d73d12b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf321ccfa5667ec01cf6103a61eda94fe"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf321ccfa5667ec01cf6103a61eda94fe">fpneg_mul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gaf321ccfa5667ec01cf6103a61eda94fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times real floating point vectors.  <a href="#gaf321ccfa5667ec01cf6103a61eda94fe"></a><br/></td></tr>
<tr class="separator:gaf321ccfa5667ec01cf6103a61eda94fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ccc67806d74d6382b759e45cbfbd4f"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga54ccc67806d74d6382b759e45cbfbd4f">fpneg_mul</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga54ccc67806d74d6382b759e45cbfbd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#ga54ccc67806d74d6382b759e45cbfbd4f"></a><br/></td></tr>
<tr class="separator:ga54ccc67806d74d6382b759e45cbfbd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524d4eede4eac23df19566828212caef"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga524d4eede4eac23df19566828212caef">fpneg_mul</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga524d4eede4eac23df19566828212caef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#ga524d4eede4eac23df19566828212caef"></a><br/></td></tr>
<tr class="separator:ga524d4eede4eac23df19566828212caef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219011153e65991faaabae1476e63f8b"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga219011153e65991faaabae1476e63f8b">fpneg_mul</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga219011153e65991faaabae1476e63f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#ga219011153e65991faaabae1476e63f8b"></a><br/></td></tr>
<tr class="separator:ga219011153e65991faaabae1476e63f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36585639e2836b5cfacaa4054e7f5ac0"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga36585639e2836b5cfacaa4054e7f5ac0">fpneg_mul</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga36585639e2836b5cfacaa4054e7f5ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times real floating point vectors.  <a href="#ga36585639e2836b5cfacaa4054e7f5ac0"></a><br/></td></tr>
<tr class="separator:ga36585639e2836b5cfacaa4054e7f5ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13108a5139900aad2cbb55802cdcc9f5"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga13108a5139900aad2cbb55802cdcc9f5">fpneg_mul</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga13108a5139900aad2cbb55802cdcc9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#ga13108a5139900aad2cbb55802cdcc9f5"></a><br/></td></tr>
<tr class="separator:ga13108a5139900aad2cbb55802cdcc9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c193b3f46d8196aaec774f1b44c89e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga88c193b3f46d8196aaec774f1b44c89e">fpneg_mul</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga88c193b3f46d8196aaec774f1b44c89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex floating point vectors.  <a href="#ga88c193b3f46d8196aaec774f1b44c89e"></a><br/></td></tr>
<tr class="separator:ga88c193b3f46d8196aaec774f1b44c89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12a058edeab9bc05a4388a686b5de8e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab12a058edeab9bc05a4388a686b5de8e">fpneg_mul_c</a> (v8float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab12a058edeab9bc05a4388a686b5de8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex conjugate floating point vectors.  <a href="#gab12a058edeab9bc05a4388a686b5de8e"></a><br/></td></tr>
<tr class="separator:gab12a058edeab9bc05a4388a686b5de8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b15bb97d263d91e4f7aa7668dd7c226"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3b15bb97d263d91e4f7aa7668dd7c226">fpneg_mul_c</a> (v16float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga3b15bb97d263d91e4f7aa7668dd7c226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex conjugate floating point vectors.  <a href="#ga3b15bb97d263d91e4f7aa7668dd7c226"></a><br/></td></tr>
<tr class="separator:ga3b15bb97d263d91e4f7aa7668dd7c226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e0c354a6fe3881152a7d2c8ed052e8"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga21e0c354a6fe3881152a7d2c8ed052e8">fpneg_mul_c</a> (v4float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga21e0c354a6fe3881152a7d2c8ed052e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex conjugate floating point vectors.  <a href="#ga21e0c354a6fe3881152a7d2c8ed052e8"></a><br/></td></tr>
<tr class="separator:ga21e0c354a6fe3881152a7d2c8ed052e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffdc93bc950cf17158519fd52efafd06"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaffdc93bc950cf17158519fd52efafd06">fpneg_mul_c</a> (v32float <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaffdc93bc950cf17158519fd52efafd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision real times complex conjugate floating point vectors.  <a href="#gaffdc93bc950cf17158519fd52efafd06"></a><br/></td></tr>
<tr class="separator:gaffdc93bc950cf17158519fd52efafd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1262448ad8854e828de795cbe044a65a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1262448ad8854e828de795cbe044a65a">fpneg_mul_c</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1262448ad8854e828de795cbe044a65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times real floating point vectors.  <a href="#ga1262448ad8854e828de795cbe044a65a"></a><br/></td></tr>
<tr class="separator:ga1262448ad8854e828de795cbe044a65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9d7caba912973508dafa2d6cdba7e4"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga6f9d7caba912973508dafa2d6cdba7e4">fpneg_mul_c</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga6f9d7caba912973508dafa2d6cdba7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times real floating point vectors.  <a href="#ga6f9d7caba912973508dafa2d6cdba7e4"></a><br/></td></tr>
<tr class="separator:ga6f9d7caba912973508dafa2d6cdba7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd885306169b6f82686ffd49e2e357df"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadd885306169b6f82686ffd49e2e357df">fpneg_mul_c</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v8float zbuf)</td></tr>
<tr class="memdesc:gadd885306169b6f82686ffd49e2e357df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times real floating point vectors.  <a href="#gadd885306169b6f82686ffd49e2e357df"></a><br/></td></tr>
<tr class="separator:gadd885306169b6f82686ffd49e2e357df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db5c39978035cdaa50bd6108947acdf"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9db5c39978035cdaa50bd6108947acdf">fpneg_mul_c</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v8float zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9db5c39978035cdaa50bd6108947acdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times real floating point vectors.  <a href="#ga9db5c39978035cdaa50bd6108947acdf"></a><br/></td></tr>
<tr class="separator:ga9db5c39978035cdaa50bd6108947acdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce1ccfce52a43aa6f9dc814212a2a39"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadce1ccfce52a43aa6f9dc814212a2a39">fpneg_mul_cc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gadce1ccfce52a43aa6f9dc814212a2a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gadce1ccfce52a43aa6f9dc814212a2a39"></a><br/></td></tr>
<tr class="separator:gadce1ccfce52a43aa6f9dc814212a2a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa6fd68c9b2477162cb7f9d36917200a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaaa6fd68c9b2477162cb7f9d36917200a">fpneg_mul_cc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaaa6fd68c9b2477162cb7f9d36917200a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gaaa6fd68c9b2477162cb7f9d36917200a"></a><br/></td></tr>
<tr class="separator:gaaa6fd68c9b2477162cb7f9d36917200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bd22081c875975377a8e48f41bca932"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5bd22081c875975377a8e48f41bca932">fpneg_mul_cc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5bd22081c875975377a8e48f41bca932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga5bd22081c875975377a8e48f41bca932"></a><br/></td></tr>
<tr class="separator:ga5bd22081c875975377a8e48f41bca932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7da1fad0374286c1c908453d4d0fabc1"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7da1fad0374286c1c908453d4d0fabc1">fpneg_mul_cc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga7da1fad0374286c1c908453d4d0fabc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#ga7da1fad0374286c1c908453d4d0fabc1"></a><br/></td></tr>
<tr class="separator:ga7da1fad0374286c1c908453d4d0fabc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01b2987fcbba79fd0f5e8106fdde54f"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf01b2987fcbba79fd0f5e8106fdde54f">fpneg_mul_cc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gaf01b2987fcbba79fd0f5e8106fdde54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gaf01b2987fcbba79fd0f5e8106fdde54f"></a><br/></td></tr>
<tr class="separator:gaf01b2987fcbba79fd0f5e8106fdde54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48c7540c1e154e3d56760e2864dba6f"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab48c7540c1e154e3d56760e2864dba6f">fpneg_mul_cc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab48c7540c1e154e3d56760e2864dba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gab48c7540c1e154e3d56760e2864dba6f"></a><br/></td></tr>
<tr class="separator:gab48c7540c1e154e3d56760e2864dba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac019fc25d7e7fb150951963a21c7eba0"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac019fc25d7e7fb150951963a21c7eba0">fpneg_mul_cc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac019fc25d7e7fb150951963a21c7eba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors.  <a href="#gac019fc25d7e7fb150951963a21c7eba0"></a><br/></td></tr>
<tr class="separator:gac019fc25d7e7fb150951963a21c7eba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bafaa9665641cf1f66a64de196ca10c"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7bafaa9665641cf1f66a64de196ca10c">fpneg_mul_cn</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga7bafaa9665641cf1f66a64de196ca10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#ga7bafaa9665641cf1f66a64de196ca10c"></a><br/></td></tr>
<tr class="separator:ga7bafaa9665641cf1f66a64de196ca10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c136e929f62cbd0d2829501c5f43ceb"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9c136e929f62cbd0d2829501c5f43ceb">fpneg_mul_cn</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9c136e929f62cbd0d2829501c5f43ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#ga9c136e929f62cbd0d2829501c5f43ceb"></a><br/></td></tr>
<tr class="separator:ga9c136e929f62cbd0d2829501c5f43ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cca9ce7f020f943ea039689212e78ad"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9cca9ce7f020f943ea039689212e78ad">fpneg_mul_cn</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga9cca9ce7f020f943ea039689212e78ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#ga9cca9ce7f020f943ea039689212e78ad"></a><br/></td></tr>
<tr class="separator:ga9cca9ce7f020f943ea039689212e78ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43051cfb14b5f4369350d84d99f42a6e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga43051cfb14b5f4369350d84d99f42a6e">fpneg_mul_cn</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga43051cfb14b5f4369350d84d99f42a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#ga43051cfb14b5f4369350d84d99f42a6e"></a><br/></td></tr>
<tr class="separator:ga43051cfb14b5f4369350d84d99f42a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf25c5e1d55b378cdca6a8e97e0b685"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacaf25c5e1d55b378cdca6a8e97e0b685">fpneg_mul_cn</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:gacaf25c5e1d55b378cdca6a8e97e0b685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#gacaf25c5e1d55b378cdca6a8e97e0b685"></a><br/></td></tr>
<tr class="separator:gacaf25c5e1d55b378cdca6a8e97e0b685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103db4575b5d10667b84f76e3242554e"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga103db4575b5d10667b84f76e3242554e">fpneg_mul_cn</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga103db4575b5d10667b84f76e3242554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#ga103db4575b5d10667b84f76e3242554e"></a><br/></td></tr>
<tr class="separator:ga103db4575b5d10667b84f76e3242554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a8f4c9e7caab06f8b1a0c934585bc3"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad5a8f4c9e7caab06f8b1a0c934585bc3">fpneg_mul_cn</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gad5a8f4c9e7caab06f8b1a0c934585bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex conjugate times complex floating point vectors.  <a href="#gad5a8f4c9e7caab06f8b1a0c934585bc3"></a><br/></td></tr>
<tr class="separator:gad5a8f4c9e7caab06f8b1a0c934585bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2630906aa61107faddb5ccb6c4991f1a"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2630906aa61107faddb5ccb6c4991f1a">fpneg_mul_nc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga2630906aa61107faddb5ccb6c4991f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#ga2630906aa61107faddb5ccb6c4991f1a"></a><br/></td></tr>
<tr class="separator:ga2630906aa61107faddb5ccb6c4991f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9bcaec0099d38a49a98901b993738d"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga6d9bcaec0099d38a49a98901b993738d">fpneg_mul_nc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga6d9bcaec0099d38a49a98901b993738d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#ga6d9bcaec0099d38a49a98901b993738d"></a><br/></td></tr>
<tr class="separator:ga6d9bcaec0099d38a49a98901b993738d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa05cd938af96f0ca91145b19e5994ebf"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa05cd938af96f0ca91145b19e5994ebf">fpneg_mul_nc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa05cd938af96f0ca91145b19e5994ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#gaa05cd938af96f0ca91145b19e5994ebf"></a><br/></td></tr>
<tr class="separator:gaa05cd938af96f0ca91145b19e5994ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66eb8f4840c43766089718c80b72f236"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga66eb8f4840c43766089718c80b72f236">fpneg_mul_nc</a> (v8cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga66eb8f4840c43766089718c80b72f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#ga66eb8f4840c43766089718c80b72f236"></a><br/></td></tr>
<tr class="separator:ga66eb8f4840c43766089718c80b72f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a3122538be25526a7e6da6c02221fa"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga35a3122538be25526a7e6da6c02221fa">fpneg_mul_nc</a> (v4cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, v4cfloat zbuf)</td></tr>
<tr class="memdesc:ga35a3122538be25526a7e6da6c02221fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#ga35a3122538be25526a7e6da6c02221fa"></a><br/></td></tr>
<tr class="separator:ga35a3122538be25526a7e6da6c02221fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad83b60625886f3b13ae44dda602237"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4ad83b60625886f3b13ae44dda602237">fpneg_mul_nc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, v4cfloat zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4ad83b60625886f3b13ae44dda602237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#ga4ad83b60625886f3b13ae44dda602237"></a><br/></td></tr>
<tr class="separator:ga4ad83b60625886f3b13ae44dda602237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d564d9231aa2c3f07a4983cc562c18"><td class="memItemLeft" align="right" valign="top">v4cfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga85d564d9231aa2c3f07a4983cc562c18">fpneg_mul_nc</a> (v16cfloat <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga85d564d9231aa2c3f07a4983cc562c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and negate for single precision complex times complex conjugate floating point vectors.  <a href="#ga85d564d9231aa2c3f07a4983cc562c18"></a><br/></td></tr>
<tr class="separator:ga85d564d9231aa2c3f07a4983cc562c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac58df991edbdab048ff09113e35dff50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c60203c3f652b8b48a3d27a20f9b3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0facea1eeaf1520c4c167420a49a2431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga274c0586c48a2005482c1a506ce6e154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf07f2d5763334632fc327a67a3c6201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = abs(xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac02d3ed06bfd2b655c8c4c1be66e4c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga60cea3890e799190fd7bcdc80ec2d3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpabs_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf152610c3f0fd63229e22d6b5bababc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf976b059904724fad494ae287d9ce1e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga985d9bcc68c31785fee85d1a380dd9c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5aa737318f7d89f5ab0240fc77efa8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa7764577efa29699835bbca5bf001da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9a72d66b7919bed3bc090ae558d074d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59a9e43a73c1816ce9a54413226e1770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ad42e3329aea69d2ffb7035d6704f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34e5b7f6e2c9d3c54e020f104404fa4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga76f57a10e173e12ed0f35f2672b91124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1a9599d9840ab31ab0df46a5926d088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf32540facab7d50877e2beb93f90284c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga900af335ebc1a69976c1709e759e9a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga00ae36df38fd90f2c897c472251fb044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gab78806c429af07ed08f3e85397ce4aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga190656385018f38bca2a8baad199decf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89424178e1749cea4e414fe07325c15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga72f0f80aa2ec930e7cdf697fed300e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e2c7f4a83c1f6085f71d8ff677c8b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga447ce0ae232b8df6fe124ebadbc7b5f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe6f5aa4a861dfa2e84f4ba264428e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60f30f2195f57d631683395594461514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gab10a63a97ac139720c9ed90765f3dd41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] + abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4e6b26879f0d3030b98eafbbc0e3c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf4a790d518eeee5cd395ddbf43e40b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] + abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga312fdde910f1be7fc48ccc364c48cb5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa07d939f05edd34ed4f4a979a00a8ad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + abs(xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaddb63fe3d65e964f38a3c13e979cd9fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] + abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4cfc364d36638647c0b5dfb09106e16c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] + abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20cea7d0ff13059f5aefe8d0ef869d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b3531f6e573a88a37b52c3bcb801e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b63065da9066735c098a8dbb8c99c15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[i] * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac670a46b4d56c65693352653f8a86560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fa5ce0fc5cbb25565651c7c3aaaf7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga990129e0bc509682abf622e4b91a15c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae93a917fef6c054c0dada0b8f6ca02c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[i]) * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4fd96834a113a91158a567bbfa28bdd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b950935aee1e8b099f59939cd264aba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga778a2b565b2cad33e89b2ba5acd66829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gac44da05651d8acde8150c32017c4ca44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0b73df4e6d14332b7979487f02a396c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga08e050ee7dac28bbf3a11043ac80b035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[i]) * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd3b7c103306d9988dfde0bf9118f9d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad27b3582623a5dc34f03f78c77621440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56add04da122c94749e70acf774d1b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e3358b68ba31dbc8bfab8c2a8518277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8abd7ebfc0e32d26d4f8e8abc907f298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf35ba21db8994c015fecd04645fcba0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1f8ce180356be911cee4c9fb3b5c9b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[i]) * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35b773b14265eb6abd8f93aaca8bfa0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga136d699321574ef4ca022e16aee55270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6deccb120d1bc0c08234889413d5aee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03f0041c586f6f6dd0894896a71e86d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae59016c1d7be44952a51c056901c8211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga019cf8186da482be77f33ff39e4c716b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1d8344cac4e5c088d56b5601a5e849ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08804c927a6096f60c3d89c3f933812a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6128cbe449b62af09b1255bc20f206a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf83ced652673021b09d77a339a2e74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84ab721fa840816d803a74d4c8960fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga270120a0ebc86049420ed15884a760d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e724a7a2ce34cbd3a6534c75f7f9e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga936851c57b3cc0add42bdd22d91c44b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga389a58e20b6742e9eeea5c1f84d2d821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0923b0208495c392d1755842dce66d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c7f9e9dbc0df75658a1c2fbfb30873b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac410a63472d6fe739d5f141e14f3fe2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9266dd0cd9a703f4cc0256e59b61463c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab82a218e4dd42b2179f3444359601b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga11cc33cfe1426c89a7a302739e36e1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa32f9d0e3909c4a2b5a3d36ab5955d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1fba04cbdbb3b56102136d1d201d3bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0b88cb3180803101ba96b98139b1580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86e91d0e9d2dcb727002874b27bb7553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84c7a3d3dba85b57664053fe0a883edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga798f830b91f7a141a41998eeadc705b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94bcd9c467a30cb5447174c847d68eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b0aa1196dd4e52e44d851c46fd4d210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e6e690509cf12aba9d1bda9bd8d226d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7827d0fe97053cf7bbaaabeba3bf529"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22f3486a407913c4d7fbacd1f81041e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb9140d5d5bcf84ee494fc35dd1c4ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34e5ee227fe6c0dcb06e313d97648844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0c105388d2aeb00939deb815546d3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga529d610c0293b24ed4b51b7a76e3b883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e9d5eeac4e068b41d99593b412571ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab406a9c168d3c26062f9cf0f36697d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply and accumulate for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = acc[i] + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91ed54a9fb24cd785f57a660f129ada0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d68a79e58d5e614d8cd37d86d4f4fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga40dc6934f0fa102f1ef867553d4f5511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gac827706a2b7c5dac5c173a1752b7e8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c0efc49db3f8048d75ba8b96fe21bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[i] * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab43495ac6598dde4c8b9d40d7950959b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d86ba537d2d7740ae3f35c230ae785e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmac_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and accumulate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] + xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb35eaadd0cc73e7fc9187b22352f858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a31b08088965b55c7083811358a4b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4979875bcb091219f8fac27f8248c886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaffc06cd24132d7178bcee30ba717dbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1db06e36afad70f93afaedfaac72b4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa963e3da5a032cb9f1bf50939bf81c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab30263502d587d2642577bdd0b8f572a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga69aec73e41aa2ed8b79d3041db60497b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ea70bc03ebc2fd4ff397e095a2528b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d1b80d9cb3a72ee7b30043085517db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1284de74f1c922f34f367d934c911703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga836444859e2e7de655deb409563e2426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8982124c7b70d01607da29033af62b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1a838960b7e3aa039f379ee97efda26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91b8559a1f5d33420744d544afda4b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab209d934b98a9dc6ba8114f7005aefbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b25bc373baf18db70e4ae639b913565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga809b4207325f5443751c7bbae5e249a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga976899107841ecfe5927fad8d74a1991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5580c5ce689b602cfb1fb8ab936f7868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada9d17eae5bea8a3783d6f2f18c1ba20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad94da13dfd8314cefbc1358272c45ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ea8880c9b4e6ed420f2739ce1648895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] - abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga07a896e1b45fe94ef50d99069cdebfc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1834f7ab3e7ce47ecba4a1c202926223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] - abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c752825c0bcca7cd039834d8a2b7bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01f950fd4a784e7e30fd1da729ea44a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - abs(xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd25f74812fbb2f218fe18fb785afafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = acc[i] - abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ab72656a5ae33734a73ce45ce3898ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = acc[i] - abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae2993b7da75827e6c1b3f5cec0c07043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f3972c3afbdab25134038374116d054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9409abdf3043176386db5ecff9aaed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[i] * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac3f678122e0d3f85280e4a6d52ef0666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51dfefd36b61069425bad39aa442552c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7ca1610f790fb319284b66cbb99a1ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4677506514fdede016d8f4e58f43e832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[i]) * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa135603b3709c68efadd119505d0a571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec935ca8e15f93d5f0efc3f6333c97bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb14ff626bf7c31371a5ed1771fe06d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f9b3c5678430d2a8771734a41faae4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf4ea82b00fa78da0af7cddaf3a04cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gab5dbe5c771805b9bd0576a43927c38df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[i]) * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d8cd0a45e74324ef6ab5b25a17584a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8edf5aebcf8e327a678200e634d94c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gade7e36a37765a481a499dfdedee72d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf43c3da72caaa60b17c38ab7f89210f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07c1ab97e206343b68c476e3be382580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga183c817bf69b243993ebe610da98ad28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gae09d45cf0a963de650f7c4ace03b0c61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[i]) * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga62290519cc7ebe8d23d6b8c2cd2caa96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd8bc25c9f07f4dd6dc417e4ffe94f60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga00b8bb5f78a06ac2192ed88e648ebb48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga26b32682b3b517b9c52e61dd91a9ca76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9717796d4e29694c1e7b261680461994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga263d882c3f00a96053ca838955ff5d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3101625520eaaf5633ec32f1e88ad22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[i] * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector. </td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab3d3d6cd67f41c72e1eeef761b69ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e59900d4c7a75dc13b83610d1c0fa05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmsc_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and subtract for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = acc[i] - xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fe843aeca1155835ee04b197b78b29e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga139252f25a52ef219639f727bdbd4039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef6e4ca7df669b59e663c5db5ac8ad8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga835915c48a204091cac8d24ad5f5fb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40b9a4d59a4aa20f9ad25066f842d021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3064b16102c89b644eadf61853e68e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ff7b0cbd53c325912b0496294322635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga01218efe1647c71a21a78c62c53a57f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa503b32381bbe29d31f1736abb32e0b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06e227b979aba4c06ee90aaa73c2dd9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79fa774a15884fda26cf5ec390db2d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc71fc8ca2fb42b277e8cece0407bf44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ed6eb2d8a76e056a34a352f8659842b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gac63be461209dfd01f27fe5bda4cb5bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0623cbfefba2f406c172ebf78cc8c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga43f9740ca63154db10d7748e234879cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b696862928c431e495ef6e5113c9926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga99cd596be05760a5e5831ddf2b850f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c5a78fc3c73315049db5bff3f8f1126"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[i] * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga665ec0814aaf7cdac43bd3e5068e3e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91f1f8d8fcf8d00446ecf799b9883800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ae0c48377d6fcc432b66273a2256bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb7a23ed440b11dc6b3bd61577de35d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3f36771a35e37c75e36e435441127d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63abe47a977aeb61f433a8ae3c81b2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[i] * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5667db6d3983eea7aa56032f0cef9f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51ba933fa567fa779f588e475070024d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab871b3b22bb58b789f6a911b3b4680d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d40a65b597942289cb1672819583400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[i]) * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga529fd90984651a9e0e421e1dff5498b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_c </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20a6d4fce38258a9778885b7856b19ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b656e2a1cbfd65130ecce72f5a0ac48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a28ff1b7a6e615b2abd3f7a98444e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga18be7dabebe81f2a06fce883fbdfbfca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga190dbe4ae3f96249b8f4532c0d1d6b82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[i]) * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf1747c817d90b172bb78e79f04e5d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb08d9f26584c6f7a5fa791271d30504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e736c3978ee671e795fcb64c4c42649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04d52132dd98f920e42f47e8d6710fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga347652212313d8295d1c3135fca7543e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50d1fb83e860c21ab1d906b3fe741537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3123782776a2c672592fce679b36698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[i]) * zbuf[i]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef6f31632d50692b9a13cd83b825271e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga088dd249cd3d0c431190e2dec4cbecb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_cn </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]]
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8817e518861808d8471bbe660d7c08d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b5646f302d9fc0a4904a438b77123df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa8afe0abe5f3a3ba74ffb6b18aa89a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d8abcefe23f74594f601cc675900219"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0de18900613e0272f6ac920f8ccef9b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b881ba5c318239e070143f3c65a0517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b7d35cdb3c698d342aa625827c085a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacea8f1855b08cea6cf96a26dd1376751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2700e0f68cad3751c0670b4799e674b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17d5d98e6bb51fa0cf8e8b1492653a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3bd3a3c6e6d74bd75e064d6f2f1175ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30d6e2a16d63a97464038d1e8fc70eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20e9e9fcd47151968c33a9374ca4c467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafbf5c992722b320d02e3d1f0a918de70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1099b4410e8f84c7af1518c740ab437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga869745c907faf2171d869ecdebba676e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd9d4d3e1f4697909c09910608736ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadb018ddbebbb5f7eb80cd8bc6b776509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb2d3900511ea498196c46893d1023fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bb9dc04dc4e3d66bb0eb40a7baefabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf5ad1ec2d24249fecb1b07762d4e80ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga44f708ddfd2968f21a4804861c56c7d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga935db197f922a0db6b42f0bfe8430222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab98234f63c4eaf04e9b1ab399acc7fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8e0d44cb23159974ff487ae1adcc6097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga665272a82dd053ce671ae28db33ba7bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga62e090062933d16c1753285763a50e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad58850c0179b60e60f76ecf55308d979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae715d9690aac3f88784ca2414b3b74f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2199bc6d5389a86e31843d5589d4cd78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga134dd2770e84c1ec768de42e1c394f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41c8c929e6f022ef735e3ca22051814d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a4b185fd15f9215581a3ca6696215d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : zbuf[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f039649eb3e694153aae0640a4081da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] = ~signbit(o[i])</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab28a10c8a3de173bb0a390d76ad09e5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_conf </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable multiply for single precision floating point vectors. </p>
<p>The output can be considered to always have 8 lanes beause each real and imaginary part of the complex float is handled as a separate lane.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (addmode == fpadd_add   ) neg = addmask ^ 0x00;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;</div>
<div class="line"><span class="keywordflow">if</span> (addmode == fpadd_mixsub) neg = addmask ^ 0x55;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 8; i++)</div>
<div class="line">  m[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[xstart + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga5ad7eecdb5ec5e6699e8eeb86f460d50">xoffs</a>[i]] * (ones ? 1.0 : <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaf67e3f9554aef4f85780b73e537405ab">xbuf</a>[zstart + zoffs[i]])</div>
<div class="line">  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])</div>
<div class="line">  o[i] = 0.0 + n[i]</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span>   cmpmode == fpcmp_nrm :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = o[i]</div>
<div class="line">  elif cmpmode == fpcmp_lt :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
<div class="line">  elif cmpmode == fpcmp_ge :</div>
<div class="line">    <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga76a8dd0231378554a2f10697b90dcb07">ret</a>[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#ga9ed015e48307e5478faeee923de7439b">cmp</a>[i] ? -n[i] : acc[i]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. </td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of second multiplicant. </td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant. </td></tr>
    <tr><td class="paramname">ones</td><td>If true second multiplicant is replaced with 1.0. </td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation. </td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant. </td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulation and multiplication result per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42ff9f143dbcbd87c11a8081edaebbbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad280005472d614e6d5f132984b33f1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga732ac4e7455035cd647d048eeb05b772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0b2a15403e6d93bd413a2727117f093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6f480b83bd3a2067a3b6140498d0f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[i] * conj(zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5e4fdacb0a283a9cccaf165547ede327"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8438bb2171a72aea5ff7462ffc8a8b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpmul_nc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga022119108cc3a3d4bbab689e0b344621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = - abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga87acdde800a7a19e2b59449c059da7bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab71a0b6fb38bf7749602504501aa1498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = - abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace69229c4d8e678144d283689f2a8e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f03c8ade33b723e3724c595247237b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - abs(xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca258d5056d7d097365ed2ab83a92ad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = - abs(xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d2a8f5b81c7572a8f695634979d185b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - abs(xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf7776d97fafce9f1c5a71a60d3f8fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb5b8634b62c072fe4e81a47f5469e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65db77d97f4cf07d5236bdef3d7e64bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3238d3340096b7a9711d6f94ff4a3c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga29a71ff908ea8b3d050f9f3b9e23d29e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad7c4d71ac19a29794662584d72b8e2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - (xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa3e49278ec57725b4e7da150b9074cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16ff50f36c3287fde485c7aa08829ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0218ee177f14aa89eebe5aa3abe596bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 8; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabbde825857ab1970a955710c0017f471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8float fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 8 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X.</td></tr>
    <tr><td class="paramname">zoffs</td><td>8 x 4 bits: Additional lane-dependent offset for second multiplicant in X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadae832f48fbe247e2fc5d5a944210e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae72904deca72ed7cf05479f83c00731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f4236bfb02eaedc8a71b85cf6f4c868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb8c402e8f796de9367a19a7aceeefb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff8e2ad8957c319518044c6d73d12b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf321ccfa5667ec01cf6103a61eda94fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54ccc67806d74d6382b759e45cbfbd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga524d4eede4eac23df19566828212caef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga219011153e65991faaabae1476e63f8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[i] * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36585639e2836b5cfacaa4054e7f5ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13108a5139900aad2cbb55802cdcc9f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88c193b3f46d8196aaec774f1b44c89e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gab12a058edeab9bc05a4388a686b5de8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b15bb97d263d91e4f7aa7668dd7c226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v16float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga21e0c354a6fe3881152a7d2c8ed052e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v4float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[i] * conj(zbuf[i]))
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaffdc93bc950cf17158519fd52efafd06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v32float&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision real times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1262448ad8854e828de795cbe044a65a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f9d7caba912973508dafa2d6cdba7e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd885306169b6f82686ffd49e2e357df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[i]) * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9db5c39978035cdaa50bd6108947acdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_c </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v8float&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times real floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadce1ccfce52a43aa6f9dc814212a2a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa6fd68c9b2477162cb7f9d36917200a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5bd22081c875975377a8e48f41bca932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7da1fad0374286c1c908453d4d0fabc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf01b2987fcbba79fd0f5e8106fdde54f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[i]) * conj(zbuf[i]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab48c7540c1e154e3d56760e2864dba6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gac019fc25d7e7fb150951963a21c7eba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * conj(xbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bafaa9665641cf1f66a64de196ca10c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9c136e929f62cbd0d2829501c5f43ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9cca9ce7f020f943ea039689212e78ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43051cfb14b5f4369350d84d99f42a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gacaf25c5e1d55b378cdca6a8e97e0b685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[i]) * zbuf[i])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga103db4575b5d10667b84f76e3242554e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * zbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gad5a8f4c9e7caab06f8b1a0c934585bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_cn </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex conjugate times complex floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (conj(xbuf[xstart + xoffs[i]]) * xbuf[zstart + zoffs[i]])
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2630906aa61107faddb5ccb6c4991f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d9bcaec0099d38a49a98901b993738d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa05cd938af96f0ca91145b19e5994ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66eb8f4840c43766089718c80b72f236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v8cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35a3122538be25526a7e6da6c02221fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[i] * conj(zbuf[i]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4ad83b60625886f3b13ae44dda602237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v4cfloat&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0; i &lt; 4; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(zbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer. </td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for Z. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85d564d9231aa2c3f07a4983cc562c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v4cfloat fpneg_mul_nc </td>
          <td>(</td>
          <td class="paramtype">v16cfloat&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and negate for single precision complex times complex conjugate floating point vectors. </p>
<pre class="fragment"> ~~~~~~~~~~~~~~~~~~~
 for (i = 0 ; i &lt; 4 ; i++)
   ret[i] = - (xbuf[xstart + xoffs[i]] * conj(xbuf[zstart + zoffs[i]]))
 ~~~~~~~~~~~~~~~~~~~
</pre> <dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Result vector.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. </td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 x 4 bits: Additional lane-dependent offset for X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] <pre class="fragment"> The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value).
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When xoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zstart</td><td>Starting offset for second multiplicant for all lanes of X. The start value refers to complex lanes (lane 0 corresponds to the first real and imaginary value).</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 x 4 bits: Additional lane-dependent offset for second multiplicant in X. Highest (4th) bit in each lane must be 0. Range per lane : [0,7] The offsets are referring to complex lanes (lane 0 corresponds to the first real and imaginary value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offsets manually. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2021 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
