<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: 16 bit Real x 16 bit Real</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__vect__mult__cmp__16x16.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">16 bit Real x 16 bit Real<div class="ingroups"><a class="el" href="group__vect__mult__cmp____16x16.html">16 bit x 16 bit</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>Vector MAC combined with vector comparisons with 16 bit real by 16 bit real </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafaf71ee979530f9aa19b1197c4adde51"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gafaf71ee979530f9aa19b1197c4adde51">mac16_abs</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gafaf71ee979530f9aa19b1197c4adde51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gafaf71ee979530f9aa19b1197c4adde51"></a><br/></td></tr>
<tr class="separator:gafaf71ee979530f9aa19b1197c4adde51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873aca811fdbb9ad904e3515d9bcc349"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga873aca811fdbb9ad904e3515d9bcc349">mac16_abs</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga873aca811fdbb9ad904e3515d9bcc349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga873aca811fdbb9ad904e3515d9bcc349"></a><br/></td></tr>
<tr class="separator:ga873aca811fdbb9ad904e3515d9bcc349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d99b9b46a0c61fffe592162cb2a8d9"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gab9d99b9b46a0c61fffe592162cb2a8d9">mac16_max</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gab9d99b9b46a0c61fffe592162cb2a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gab9d99b9b46a0c61fffe592162cb2a8d9"></a><br/></td></tr>
<tr class="separator:gab9d99b9b46a0c61fffe592162cb2a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac945275fb7f9ed1d364d56b8d109009e"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gac945275fb7f9ed1d364d56b8d109009e">mac16_max</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gac945275fb7f9ed1d364d56b8d109009e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gac945275fb7f9ed1d364d56b8d109009e"></a><br/></td></tr>
<tr class="separator:gac945275fb7f9ed1d364d56b8d109009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104e88b46ffb755ead05ce35d53e505e"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga104e88b46ffb755ead05ce35d53e505e">mac16_max</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga104e88b46ffb755ead05ce35d53e505e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga104e88b46ffb755ead05ce35d53e505e"></a><br/></td></tr>
<tr class="separator:ga104e88b46ffb755ead05ce35d53e505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63b804b7965a65c3859c6182dd7aced2"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga63b804b7965a65c3859c6182dd7aced2">mac16_maxdiff</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga63b804b7965a65c3859c6182dd7aced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#ga63b804b7965a65c3859c6182dd7aced2"></a><br/></td></tr>
<tr class="separator:ga63b804b7965a65c3859c6182dd7aced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40dbe606f08d9690e3130fe406ece7d"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaa40dbe606f08d9690e3130fe406ece7d">mac16_maxdiff</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaa40dbe606f08d9690e3130fe406ece7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaa40dbe606f08d9690e3130fe406ece7d"></a><br/></td></tr>
<tr class="separator:gaa40dbe606f08d9690e3130fe406ece7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3749018a00011aece05f82ecb9ba2b1"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gac3749018a00011aece05f82ecb9ba2b1">mac16_maxdiff</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gac3749018a00011aece05f82ecb9ba2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gac3749018a00011aece05f82ecb9ba2b1"></a><br/></td></tr>
<tr class="separator:gac3749018a00011aece05f82ecb9ba2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a9aaa48b1ccf99b3470b6e88ba63b7"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga09a9aaa48b1ccf99b3470b6e88ba63b7">mac16_min</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga09a9aaa48b1ccf99b3470b6e88ba63b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga09a9aaa48b1ccf99b3470b6e88ba63b7"></a><br/></td></tr>
<tr class="separator:ga09a9aaa48b1ccf99b3470b6e88ba63b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33282ea69021c1d3434e96be86ad1b27"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga33282ea69021c1d3434e96be86ad1b27">mac16_min</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga33282ea69021c1d3434e96be86ad1b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga33282ea69021c1d3434e96be86ad1b27"></a><br/></td></tr>
<tr class="separator:ga33282ea69021c1d3434e96be86ad1b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608e6bf24842b7719a820822440927a8"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga608e6bf24842b7719a820822440927a8">mac16_min</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga608e6bf24842b7719a820822440927a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga608e6bf24842b7719a820822440927a8"></a><br/></td></tr>
<tr class="separator:ga608e6bf24842b7719a820822440927a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38cb0808eb4fd3d0cdb684f28ff7e472"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga38cb0808eb4fd3d0cdb684f28ff7e472">mac8_abs</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga38cb0808eb4fd3d0cdb684f28ff7e472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga38cb0808eb4fd3d0cdb684f28ff7e472"></a><br/></td></tr>
<tr class="separator:ga38cb0808eb4fd3d0cdb684f28ff7e472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fbc0cc020540400cb3f74e1e83964e6"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga4fbc0cc020540400cb3f74e1e83964e6">mac8_abs</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga4fbc0cc020540400cb3f74e1e83964e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga4fbc0cc020540400cb3f74e1e83964e6"></a><br/></td></tr>
<tr class="separator:ga4fbc0cc020540400cb3f74e1e83964e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556cf05c3c292ef30fe0c97f963feaba"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga556cf05c3c292ef30fe0c97f963feaba">mac8_max</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga556cf05c3c292ef30fe0c97f963feaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga556cf05c3c292ef30fe0c97f963feaba"></a><br/></td></tr>
<tr class="separator:ga556cf05c3c292ef30fe0c97f963feaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9a67d1a49ac51966044fdaed423be65"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf9a67d1a49ac51966044fdaed423be65">mac8_max</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf9a67d1a49ac51966044fdaed423be65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf9a67d1a49ac51966044fdaed423be65"></a><br/></td></tr>
<tr class="separator:gaf9a67d1a49ac51966044fdaed423be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858356a7f4a89a3691db2106ffeb392c"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga858356a7f4a89a3691db2106ffeb392c">mac8_max</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga858356a7f4a89a3691db2106ffeb392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga858356a7f4a89a3691db2106ffeb392c"></a><br/></td></tr>
<tr class="separator:ga858356a7f4a89a3691db2106ffeb392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad977e6a1b13ed15d8bcd53a41902899c"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gad977e6a1b13ed15d8bcd53a41902899c">mac8_maxdiff</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gad977e6a1b13ed15d8bcd53a41902899c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gad977e6a1b13ed15d8bcd53a41902899c"></a><br/></td></tr>
<tr class="separator:gad977e6a1b13ed15d8bcd53a41902899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1613e8ae05097322f7a81b94d6ee69"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga7c1613e8ae05097322f7a81b94d6ee69">mac8_maxdiff</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga7c1613e8ae05097322f7a81b94d6ee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga7c1613e8ae05097322f7a81b94d6ee69"></a><br/></td></tr>
<tr class="separator:ga7c1613e8ae05097322f7a81b94d6ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2500961097fee090b5cabcb3d08064c1"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga2500961097fee090b5cabcb3d08064c1">mac8_maxdiff</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga2500961097fee090b5cabcb3d08064c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga2500961097fee090b5cabcb3d08064c1"></a><br/></td></tr>
<tr class="separator:ga2500961097fee090b5cabcb3d08064c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27bcacdd58d5acb49530ea6ae8a33df4"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga27bcacdd58d5acb49530ea6ae8a33df4">mac8_min</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga27bcacdd58d5acb49530ea6ae8a33df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga27bcacdd58d5acb49530ea6ae8a33df4"></a><br/></td></tr>
<tr class="separator:ga27bcacdd58d5acb49530ea6ae8a33df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59e8cf9652923335b484cf0c618620c"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gac59e8cf9652923335b484cf0c618620c">mac8_min</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gac59e8cf9652923335b484cf0c618620c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gac59e8cf9652923335b484cf0c618620c"></a><br/></td></tr>
<tr class="separator:gac59e8cf9652923335b484cf0c618620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da347d074d8d230686bee77c98cddd2"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga1da347d074d8d230686bee77c98cddd2">mac8_min</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga1da347d074d8d230686bee77c98cddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga1da347d074d8d230686bee77c98cddd2"></a><br/></td></tr>
<tr class="separator:ga1da347d074d8d230686bee77c98cddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4f86d77c7b2871c3297ab9a71168df"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaaa4f86d77c7b2871c3297ab9a71168df">msc16_abs</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaaa4f86d77c7b2871c3297ab9a71168df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gaaa4f86d77c7b2871c3297ab9a71168df"></a><br/></td></tr>
<tr class="separator:gaaa4f86d77c7b2871c3297ab9a71168df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7234a9fc4ea15898417b6ec5eb36f161"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga7234a9fc4ea15898417b6ec5eb36f161">msc16_abs</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga7234a9fc4ea15898417b6ec5eb36f161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga7234a9fc4ea15898417b6ec5eb36f161"></a><br/></td></tr>
<tr class="separator:ga7234a9fc4ea15898417b6ec5eb36f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2140f3495d5f1870dcb55bb507bd9ea5"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga2140f3495d5f1870dcb55bb507bd9ea5">msc16_max</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga2140f3495d5f1870dcb55bb507bd9ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#ga2140f3495d5f1870dcb55bb507bd9ea5"></a><br/></td></tr>
<tr class="separator:ga2140f3495d5f1870dcb55bb507bd9ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632da9999d9937908b1b98c02d331ab4"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga632da9999d9937908b1b98c02d331ab4">msc16_max</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga632da9999d9937908b1b98c02d331ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga632da9999d9937908b1b98c02d331ab4"></a><br/></td></tr>
<tr class="separator:ga632da9999d9937908b1b98c02d331ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a9fd212af02a0add61d33c3c935124"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga78a9fd212af02a0add61d33c3c935124">msc16_max</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga78a9fd212af02a0add61d33c3c935124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga78a9fd212af02a0add61d33c3c935124"></a><br/></td></tr>
<tr class="separator:ga78a9fd212af02a0add61d33c3c935124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7ff60d32b9fd3127db302b47eb3735"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga7f7ff60d32b9fd3127db302b47eb3735">msc16_maxdiff</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga7f7ff60d32b9fd3127db302b47eb3735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#ga7f7ff60d32b9fd3127db302b47eb3735"></a><br/></td></tr>
<tr class="separator:ga7f7ff60d32b9fd3127db302b47eb3735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f57013757426014441daa1e6b69ea1f"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga2f57013757426014441daa1e6b69ea1f">msc16_maxdiff</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga2f57013757426014441daa1e6b69ea1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga2f57013757426014441daa1e6b69ea1f"></a><br/></td></tr>
<tr class="separator:ga2f57013757426014441daa1e6b69ea1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7fefb78c95a19e04de66c9f135a63c"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaec7fefb78c95a19e04de66c9f135a63c">msc16_maxdiff</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaec7fefb78c95a19e04de66c9f135a63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaec7fefb78c95a19e04de66c9f135a63c"></a><br/></td></tr>
<tr class="separator:gaec7fefb78c95a19e04de66c9f135a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7482c9e68c56e969c586c94c7e33802a"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga7482c9e68c56e969c586c94c7e33802a">msc16_min</a> (v16acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga7482c9e68c56e969c586c94c7e33802a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga7482c9e68c56e969c586c94c7e33802a"></a><br/></td></tr>
<tr class="separator:ga7482c9e68c56e969c586c94c7e33802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7c67fd4cdca76a7b76d158e31b2af7"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga6c7c67fd4cdca76a7b76d158e31b2af7">msc16_min</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga6c7c67fd4cdca76a7b76d158e31b2af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga6c7c67fd4cdca76a7b76d158e31b2af7"></a><br/></td></tr>
<tr class="separator:ga6c7c67fd4cdca76a7b76d158e31b2af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa331ef508d32fd9e64797de0a6278ce5"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaa331ef508d32fd9e64797de0a6278ce5">msc16_min</a> (v16acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaa331ef508d32fd9e64797de0a6278ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaa331ef508d32fd9e64797de0a6278ce5"></a><br/></td></tr>
<tr class="separator:gaa331ef508d32fd9e64797de0a6278ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d10576959233facdfd11929d32368f"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf6d10576959233facdfd11929d32368f">msc8_abs</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf6d10576959233facdfd11929d32368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gaf6d10576959233facdfd11929d32368f"></a><br/></td></tr>
<tr class="separator:gaf6d10576959233facdfd11929d32368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e01854869037f317adc5c54609f8edd"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga1e01854869037f317adc5c54609f8edd">msc8_abs</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga1e01854869037f317adc5c54609f8edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga1e01854869037f317adc5c54609f8edd"></a><br/></td></tr>
<tr class="separator:ga1e01854869037f317adc5c54609f8edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5a0b1b2214453c9c2b6ad6895f6f48"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaae5a0b1b2214453c9c2b6ad6895f6f48">msc8_max</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaae5a0b1b2214453c9c2b6ad6895f6f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gaae5a0b1b2214453c9c2b6ad6895f6f48"></a><br/></td></tr>
<tr class="separator:gaae5a0b1b2214453c9c2b6ad6895f6f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14eeff6e55c8e2e918d85592805e118c"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga14eeff6e55c8e2e918d85592805e118c">msc8_max</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga14eeff6e55c8e2e918d85592805e118c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga14eeff6e55c8e2e918d85592805e118c"></a><br/></td></tr>
<tr class="separator:ga14eeff6e55c8e2e918d85592805e118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa391ed1eed29a8bb0c57fed0816c9f6e"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaa391ed1eed29a8bb0c57fed0816c9f6e">msc8_max</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaa391ed1eed29a8bb0c57fed0816c9f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaa391ed1eed29a8bb0c57fed0816c9f6e"></a><br/></td></tr>
<tr class="separator:gaa391ed1eed29a8bb0c57fed0816c9f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac956590c1e3c7b4c5111847c20a1d3a6"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gac956590c1e3c7b4c5111847c20a1d3a6">msc8_maxdiff</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gac956590c1e3c7b4c5111847c20a1d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gac956590c1e3c7b4c5111847c20a1d3a6"></a><br/></td></tr>
<tr class="separator:gac956590c1e3c7b4c5111847c20a1d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ef0f2e209a06c2681819a37304288c"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gab8ef0f2e209a06c2681819a37304288c">msc8_maxdiff</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gab8ef0f2e209a06c2681819a37304288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gab8ef0f2e209a06c2681819a37304288c"></a><br/></td></tr>
<tr class="separator:gab8ef0f2e209a06c2681819a37304288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf311375daf501632418e9b111696a866"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf311375daf501632418e9b111696a866">msc8_maxdiff</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf311375daf501632418e9b111696a866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf311375daf501632418e9b111696a866"></a><br/></td></tr>
<tr class="separator:gaf311375daf501632418e9b111696a866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454539f13aab3a121761341b618bc6bc"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga454539f13aab3a121761341b618bc6bc">msc8_min</a> (v8acc48 acc, v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga454539f13aab3a121761341b618bc6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga454539f13aab3a121761341b618bc6bc"></a><br/></td></tr>
<tr class="separator:ga454539f13aab3a121761341b618bc6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a70e6fab4f3ef4262f99dcc56a92b03"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga7a70e6fab4f3ef4262f99dcc56a92b03">msc8_min</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga7a70e6fab4f3ef4262f99dcc56a92b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga7a70e6fab4f3ef4262f99dcc56a92b03"></a><br/></td></tr>
<tr class="separator:ga7a70e6fab4f3ef4262f99dcc56a92b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc051986da45509ba84cdae6f73ec20"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga0fc051986da45509ba84cdae6f73ec20">msc8_min</a> (v8acc48 acc, v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga0fc051986da45509ba84cdae6f73ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0fc051986da45509ba84cdae6f73ec20"></a><br/></td></tr>
<tr class="separator:ga0fc051986da45509ba84cdae6f73ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0356541b205ed0ebe0839a80e8d5f9"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga6a0356541b205ed0ebe0839a80e8d5f9">mul16_abs</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga6a0356541b205ed0ebe0839a80e8d5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga6a0356541b205ed0ebe0839a80e8d5f9"></a><br/></td></tr>
<tr class="separator:ga6a0356541b205ed0ebe0839a80e8d5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24114d0ef2a2f31e07563fe234856456"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga24114d0ef2a2f31e07563fe234856456">mul16_abs</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga24114d0ef2a2f31e07563fe234856456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga24114d0ef2a2f31e07563fe234856456"></a><br/></td></tr>
<tr class="separator:ga24114d0ef2a2f31e07563fe234856456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89dcf9626439a94294a911bcb96a585"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaa89dcf9626439a94294a911bcb96a585">mul16_max</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaa89dcf9626439a94294a911bcb96a585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gaa89dcf9626439a94294a911bcb96a585"></a><br/></td></tr>
<tr class="separator:gaa89dcf9626439a94294a911bcb96a585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0330dd8725dd2999903963dfbc216f5f"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga0330dd8725dd2999903963dfbc216f5f">mul16_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga0330dd8725dd2999903963dfbc216f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0330dd8725dd2999903963dfbc216f5f"></a><br/></td></tr>
<tr class="separator:ga0330dd8725dd2999903963dfbc216f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e46cdce6414db3399314eebf0d34d4"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga70e46cdce6414db3399314eebf0d34d4">mul16_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga70e46cdce6414db3399314eebf0d34d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga70e46cdce6414db3399314eebf0d34d4"></a><br/></td></tr>
<tr class="separator:ga70e46cdce6414db3399314eebf0d34d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58276b775e1cb92d6549530f83f79b8"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaa58276b775e1cb92d6549530f83f79b8">mul16_maxdiff</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaa58276b775e1cb92d6549530f83f79b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gaa58276b775e1cb92d6549530f83f79b8"></a><br/></td></tr>
<tr class="separator:gaa58276b775e1cb92d6549530f83f79b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e9fd1d91b81829ab640c6dc041ff6a"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf4e9fd1d91b81829ab640c6dc041ff6a">mul16_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaf4e9fd1d91b81829ab640c6dc041ff6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf4e9fd1d91b81829ab640c6dc041ff6a"></a><br/></td></tr>
<tr class="separator:gaf4e9fd1d91b81829ab640c6dc041ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73118477af06e175ac3710f4b190c25"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gae73118477af06e175ac3710f4b190c25">mul16_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gae73118477af06e175ac3710f4b190c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gae73118477af06e175ac3710f4b190c25"></a><br/></td></tr>
<tr class="separator:gae73118477af06e175ac3710f4b190c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8a48fe10fd684113993d355634de23"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga2e8a48fe10fd684113993d355634de23">mul16_min</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga2e8a48fe10fd684113993d355634de23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga2e8a48fe10fd684113993d355634de23"></a><br/></td></tr>
<tr class="separator:ga2e8a48fe10fd684113993d355634de23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f96edde88309d8ea0369c9be7b43b7"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf6f96edde88309d8ea0369c9be7b43b7">mul16_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaf6f96edde88309d8ea0369c9be7b43b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf6f96edde88309d8ea0369c9be7b43b7"></a><br/></td></tr>
<tr class="separator:gaf6f96edde88309d8ea0369c9be7b43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0ed79061545c138601e34d5b1a9f80"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga0b0ed79061545c138601e34d5b1a9f80">mul16_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga0b0ed79061545c138601e34d5b1a9f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0b0ed79061545c138601e34d5b1a9f80"></a><br/></td></tr>
<tr class="separator:ga0b0ed79061545c138601e34d5b1a9f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2737dec5ce1c7738679a2d59a327d9"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga7a2737dec5ce1c7738679a2d59a327d9">mul8_abs</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga7a2737dec5ce1c7738679a2d59a327d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#ga7a2737dec5ce1c7738679a2d59a327d9"></a><br/></td></tr>
<tr class="separator:ga7a2737dec5ce1c7738679a2d59a327d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8dbbeeafc04e6868b87dfcd5383088"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga1d8dbbeeafc04e6868b87dfcd5383088">mul8_abs</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga1d8dbbeeafc04e6868b87dfcd5383088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga1d8dbbeeafc04e6868b87dfcd5383088"></a><br/></td></tr>
<tr class="separator:ga1d8dbbeeafc04e6868b87dfcd5383088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec84619467140740a1977fdf6f355c1f"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaec84619467140740a1977fdf6f355c1f">mul8_max</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaec84619467140740a1977fdf6f355c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gaec84619467140740a1977fdf6f355c1f"></a><br/></td></tr>
<tr class="separator:gaec84619467140740a1977fdf6f355c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5aa7e9613dea515480fca34a6e8ceb"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga8a5aa7e9613dea515480fca34a6e8ceb">mul8_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga8a5aa7e9613dea515480fca34a6e8ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga8a5aa7e9613dea515480fca34a6e8ceb"></a><br/></td></tr>
<tr class="separator:ga8a5aa7e9613dea515480fca34a6e8ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37e48040086f5f5297346fe727cfd3c"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf37e48040086f5f5297346fe727cfd3c">mul8_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf37e48040086f5f5297346fe727cfd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf37e48040086f5f5297346fe727cfd3c"></a><br/></td></tr>
<tr class="separator:gaf37e48040086f5f5297346fe727cfd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74b8c40a61727809bffbe4dc995cfcf"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gae74b8c40a61727809bffbe4dc995cfcf">mul8_maxdiff</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gae74b8c40a61727809bffbe4dc995cfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gae74b8c40a61727809bffbe4dc995cfcf"></a><br/></td></tr>
<tr class="separator:gae74b8c40a61727809bffbe4dc995cfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6edaad9054d050a21d45f3cade55822"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gad6edaad9054d050a21d45f3cade55822">mul8_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gad6edaad9054d050a21d45f3cade55822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gad6edaad9054d050a21d45f3cade55822"></a><br/></td></tr>
<tr class="separator:gad6edaad9054d050a21d45f3cade55822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cd67e0ecbd2c0c27ab5f59e88102c5"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga60cd67e0ecbd2c0c27ab5f59e88102c5">mul8_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga60cd67e0ecbd2c0c27ab5f59e88102c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga60cd67e0ecbd2c0c27ab5f59e88102c5"></a><br/></td></tr>
<tr class="separator:ga60cd67e0ecbd2c0c27ab5f59e88102c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2d6460b3e001c6e5c23903eefa5853"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga0a2d6460b3e001c6e5c23903eefa5853">mul8_min</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga0a2d6460b3e001c6e5c23903eefa5853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga0a2d6460b3e001c6e5c23903eefa5853"></a><br/></td></tr>
<tr class="separator:ga0a2d6460b3e001c6e5c23903eefa5853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35142c022d01274e99d48c014656f3e"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf35142c022d01274e99d48c014656f3e">mul8_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf35142c022d01274e99d48c014656f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaf35142c022d01274e99d48c014656f3e"></a><br/></td></tr>
<tr class="separator:gaf35142c022d01274e99d48c014656f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe7289262b24835069b9f5045d09dcc"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga0fe7289262b24835069b9f5045d09dcc">mul8_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga0fe7289262b24835069b9f5045d09dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga0fe7289262b24835069b9f5045d09dcc"></a><br/></td></tr>
<tr class="separator:ga0fe7289262b24835069b9f5045d09dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeffc30977a287a3dd357dc073fd95189"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaeffc30977a287a3dd357dc073fd95189">negmul16_abs</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaeffc30977a287a3dd357dc073fd95189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gaeffc30977a287a3dd357dc073fd95189"></a><br/></td></tr>
<tr class="separator:gaeffc30977a287a3dd357dc073fd95189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43050077cb4be9666017874cbb019fe7"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga43050077cb4be9666017874cbb019fe7">negmul16_abs</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga43050077cb4be9666017874cbb019fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#ga43050077cb4be9666017874cbb019fe7"></a><br/></td></tr>
<tr class="separator:ga43050077cb4be9666017874cbb019fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ec7def3ffefd0578398f8fa96fc8c2"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gab2ec7def3ffefd0578398f8fa96fc8c2">negmul16_max</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gab2ec7def3ffefd0578398f8fa96fc8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gab2ec7def3ffefd0578398f8fa96fc8c2"></a><br/></td></tr>
<tr class="separator:gab2ec7def3ffefd0578398f8fa96fc8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89722b419061bb185b338b16564d2b2e"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga89722b419061bb185b338b16564d2b2e">negmul16_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga89722b419061bb185b338b16564d2b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga89722b419061bb185b338b16564d2b2e"></a><br/></td></tr>
<tr class="separator:ga89722b419061bb185b338b16564d2b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47461ec0e591fde1e8bad010ad893e66"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga47461ec0e591fde1e8bad010ad893e66">negmul16_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga47461ec0e591fde1e8bad010ad893e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga47461ec0e591fde1e8bad010ad893e66"></a><br/></td></tr>
<tr class="separator:ga47461ec0e591fde1e8bad010ad893e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e646c54d0c23da3535350d84a0b205b"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga3e646c54d0c23da3535350d84a0b205b">negmul16_maxdiff</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga3e646c54d0c23da3535350d84a0b205b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#ga3e646c54d0c23da3535350d84a0b205b"></a><br/></td></tr>
<tr class="separator:ga3e646c54d0c23da3535350d84a0b205b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9805d14a0c332e2533ffe0a4cd518e8"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gad9805d14a0c332e2533ffe0a4cd518e8">negmul16_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gad9805d14a0c332e2533ffe0a4cd518e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#gad9805d14a0c332e2533ffe0a4cd518e8"></a><br/></td></tr>
<tr class="separator:gad9805d14a0c332e2533ffe0a4cd518e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1c3752936c113b04b5c882ebc16b99"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga5b1c3752936c113b04b5c882ebc16b99">negmul16_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga5b1c3752936c113b04b5c882ebc16b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga5b1c3752936c113b04b5c882ebc16b99"></a><br/></td></tr>
<tr class="separator:ga5b1c3752936c113b04b5c882ebc16b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631615201b1568c516cf9df5afc09e6c"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga631615201b1568c516cf9df5afc09e6c">negmul16_min</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga631615201b1568c516cf9df5afc09e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga631615201b1568c516cf9df5afc09e6c"></a><br/></td></tr>
<tr class="separator:ga631615201b1568c516cf9df5afc09e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba97f59d9d225d6db7601ef7ff22e08"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga5ba97f59d9d225d6db7601ef7ff22e08">negmul16_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:ga5ba97f59d9d225d6db7601ef7ff22e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga5ba97f59d9d225d6db7601ef7ff22e08"></a><br/></td></tr>
<tr class="separator:ga5ba97f59d9d225d6db7601ef7ff22e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d447454a66696c51de95f007a2adfe"><td class="memItemLeft" align="right" valign="top">v16acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaa9d447454a66696c51de95f007a2adfe">negmul16_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, unsigned int zoffsets_hi, int zstep)</td></tr>
<tr class="memdesc:gaa9d447454a66696c51de95f007a2adfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gaa9d447454a66696c51de95f007a2adfe"></a><br/></td></tr>
<tr class="separator:gaa9d447454a66696c51de95f007a2adfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b461511bc029f7fe07a68c21d9fe02"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gaf2b461511bc029f7fe07a68c21d9fe02">negmul8_abs</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gaf2b461511bc029f7fe07a68c21d9fe02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer .  <a href="#gaf2b461511bc029f7fe07a68c21d9fe02"></a><br/></td></tr>
<tr class="separator:gaf2b461511bc029f7fe07a68c21d9fe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdad5d6eac0030856c8f89d4ab71a0ea"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gabdad5d6eac0030856c8f89d4ab71a0ea">negmul8_abs</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gabdad5d6eac0030856c8f89d4ab71a0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer.  <a href="#gabdad5d6eac0030856c8f89d4ab71a0ea"></a><br/></td></tr>
<tr class="separator:gabdad5d6eac0030856c8f89d4ab71a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89f4d7fd33edfa99df9bc201edf0189"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gac89f4d7fd33edfa99df9bc201edf0189">negmul8_max</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gac89f4d7fd33edfa99df9bc201edf0189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer .  <a href="#gac89f4d7fd33edfa99df9bc201edf0189"></a><br/></td></tr>
<tr class="separator:gac89f4d7fd33edfa99df9bc201edf0189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b791d1762d40fd21a535a69bb45dd2"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gab9b791d1762d40fd21a535a69bb45dd2">negmul8_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gab9b791d1762d40fd21a535a69bb45dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#gab9b791d1762d40fd21a535a69bb45dd2"></a><br/></td></tr>
<tr class="separator:gab9b791d1762d40fd21a535a69bb45dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d9a43264428dcfb75b393b7e318be4"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga43d9a43264428dcfb75b393b7e318be4">negmul8_max</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga43d9a43264428dcfb75b393b7e318be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga43d9a43264428dcfb75b393b7e318be4"></a><br/></td></tr>
<tr class="separator:ga43d9a43264428dcfb75b393b7e318be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfac08506108417aff4b31c423e92ee4"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gacfac08506108417aff4b31c423e92ee4">negmul8_maxdiff</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gacfac08506108417aff4b31c423e92ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer .  <a href="#gacfac08506108417aff4b31c423e92ee4"></a><br/></td></tr>
<tr class="separator:gacfac08506108417aff4b31c423e92ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4617d4c4215b614d06069fc5f8f1529b"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga4617d4c4215b614d06069fc5f8f1529b">negmul8_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga4617d4c4215b614d06069fc5f8f1529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga4617d4c4215b614d06069fc5f8f1529b"></a><br/></td></tr>
<tr class="separator:ga4617d4c4215b614d06069fc5f8f1529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a9ae6a87b28424b1e9ba0f31949326"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga64a9ae6a87b28424b1e9ba0f31949326">negmul8_maxdiff</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga64a9ae6a87b28424b1e9ba0f31949326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer.  <a href="#ga64a9ae6a87b28424b1e9ba0f31949326"></a><br/></td></tr>
<tr class="separator:ga64a9ae6a87b28424b1e9ba0f31949326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45769d12f817bf91541be48ffb97df1a"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga45769d12f817bf91541be48ffb97df1a">negmul8_min</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga45769d12f817bf91541be48ffb97df1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer .  <a href="#ga45769d12f817bf91541be48ffb97df1a"></a><br/></td></tr>
<tr class="separator:ga45769d12f817bf91541be48ffb97df1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208d60c7bf5e5d6e0b4b8aadd541765d"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#ga208d60c7bf5e5d6e0b4b8aadd541765d">negmul8_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:ga208d60c7bf5e5d6e0b4b8aadd541765d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#ga208d60c7bf5e5d6e0b4b8aadd541765d"></a><br/></td></tr>
<tr class="separator:ga208d60c7bf5e5d6e0b4b8aadd541765d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a6ea57ee3392c4929aef3c8058d0ef"><td class="memItemLeft" align="right" valign="top">v8acc48&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vect__mult__cmp__16x16.html#gac1a6ea57ee3392c4929aef3c8058d0ef">negmul8_min</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int xstep, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int ysquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)</td></tr>
<tr class="memdesc:gac1a6ea57ee3392c4929aef3c8058d0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer.  <a href="#gac1a6ea57ee3392c4929aef3c8058d0ef"></a><br/></td></tr>
<tr class="separator:gac1a6ea57ee3392c4929aef3c8058d0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafaf71ee979530f9aa19b1197c4adde51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_abs </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mac16_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 += z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 += z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 += z30*abs(x30) + z31*abs(x31)</div>
<div class="line">acc4 += z40*abs(x40) + z41*abs(x41)</div>
<div class="line">acc5 += z50*abs(x50) + z51*abs(x51)</div>
<div class="line">acc6 += z60*abs(x60) + z61*abs(x61)</div>
<div class="line">acc7 += z70*abs(x70) + z71*abs(x71)</div>
<div class="line">acc8 += z80*abs(x80) + z81*abs(x81)</div>
<div class="line">acc9 += z90*abs(x90) + z91*abs(x91)</div>
<div class="line">acc10 += z100*abs(x100) + z101*abs(x101)</div>
<div class="line">acc11 += z110*abs(x110) + z111*abs(x111)</div>
<div class="line">acc12 += z120*abs(x120) + z121*abs(x121)</div>
<div class="line">acc13 += z130*abs(x130) + z131*abs(x131)</div>
<div class="line">acc14 += z140*abs(x140) + z141*abs(x141)</div>
<div class="line">acc15 += z150*abs(x150) + z151*abs(x151)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga873aca811fdbb9ad904e3515d9bcc349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_abs </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 += z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 += z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 += z30*abs(x30) + z31*abs(x31)</div>
<div class="line">acc4 += z40*abs(x40) + z41*abs(x41)</div>
<div class="line">acc5 += z50*abs(x50) + z51*abs(x51)</div>
<div class="line">acc6 += z60*abs(x60) + z61*abs(x61)</div>
<div class="line">acc7 += z70*abs(x70) + z71*abs(x71)</div>
<div class="line">acc8 += z80*abs(x80) + z81*abs(x81)</div>
<div class="line">acc9 += z90*abs(x90) + z91*abs(x91)</div>
<div class="line">acc10 += z100*abs(x100) + z101*abs(x101)</div>
<div class="line">acc11 += z110*abs(x110) + z111*abs(x111)</div>
<div class="line">acc12 += z120*abs(x120) + z121*abs(x121)</div>
<div class="line">acc13 += z130*abs(x130) + z131*abs(x131)</div>
<div class="line">acc14 += z140*abs(x140) + z141*abs(x141)</div>
<div class="line">acc15 += z150*abs(x150) + z151*abs(x151)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab9d99b9b46a0c61fffe592162cb2a8d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_max </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mac16_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 += z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 += z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 += z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 += z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 += z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 += z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 += z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 += z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 += z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 += z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 += z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 += z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac945275fb7f9ed1d364d56b8d109009e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_max </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 += z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 += z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 += z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 += z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 += z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 += z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 += z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 += z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 += z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 += z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 += z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 += z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga104e88b46ffb755ead05ce35d53e505e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_max </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 += z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 += z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 += z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 += z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 += z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 += z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 += z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 += z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 += z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 += z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 += z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 += z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga63b804b7965a65c3859c6182dd7aced2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mac16_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 += z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 += z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 += z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 += z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 += z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 += z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 += z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 += z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa40dbe606f08d9690e3130fe406ece7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 += z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 += z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 += z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 += z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 += z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 += z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 += z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 += z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac3749018a00011aece05f82ecb9ba2b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 += z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 += z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 += z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 += z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 += z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 += z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 += z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 += z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga09a9aaa48b1ccf99b3470b6e88ba63b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_min </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mac16_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 += z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 += z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 += z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 += z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 += z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 += z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 += z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 += z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 += z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 += z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 += z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 += z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga33282ea69021c1d3434e96be86ad1b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_min </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 += z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 += z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 += z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 += z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 += z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 += z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 += z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 += z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 += z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 += z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 += z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 += z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga608e6bf24842b7719a820822440927a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mac16_min </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mac16_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 += z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 += z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 += z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 += z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 += z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 += z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 += z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 += z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 += z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 += z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 += z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 += z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga38cb0808eb4fd3d0cdb684f28ff7e472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mac8_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03)</div>
<div class="line">acc1 += z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13)</div>
<div class="line">acc2 += z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23)</div>
<div class="line">acc3 += z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33)</div>
<div class="line">acc4 += z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43)</div>
<div class="line">acc5 += z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53)</div>
<div class="line">acc6 += z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63)</div>
<div class="line">acc7 += z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4fbc0cc020540400cb3f74e1e83964e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03)</div>
<div class="line">acc1 += z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13)</div>
<div class="line">acc2 += z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23)</div>
<div class="line">acc3 += z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33)</div>
<div class="line">acc4 += z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43)</div>
<div class="line">acc5 += z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53)</div>
<div class="line">acc6 += z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63)</div>
<div class="line">acc7 += z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga556cf05c3c292ef30fe0c97f963feaba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mac8_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 += z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 += z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 += z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 += z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf9a67d1a49ac51966044fdaed423be65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 += z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 += z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 += z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 += z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga858356a7f4a89a3691db2106ffeb392c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 += z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 += z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 += z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 += z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 += z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 += z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 += z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad977e6a1b13ed15d8bcd53a41902899c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mac8_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7c1613e8ae05097322f7a81b94d6ee69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2500961097fee090b5cabcb3d08064c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 += z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 += z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 += z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 += z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 += z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 += z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 += z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga27bcacdd58d5acb49530ea6ae8a33df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mac8_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 += z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 += z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 += z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 += z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac59e8cf9652923335b484cf0c618620c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 += z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 += z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 += z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 += z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1da347d074d8d230686bee77c98cddd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mac8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mac8_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 += z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 += z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 += z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 += z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 += z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 += z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 += z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 += z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaaa4f86d77c7b2871c3297ab9a71168df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_abs </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_msc16_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 -= z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 -= z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 -= z30*abs(x30) + z31*abs(x31)</div>
<div class="line">acc4 -= z40*abs(x40) + z41*abs(x41)</div>
<div class="line">acc5 -= z50*abs(x50) + z51*abs(x51)</div>
<div class="line">acc6 -= z60*abs(x60) + z61*abs(x61)</div>
<div class="line">acc7 -= z70*abs(x70) + z71*abs(x71)</div>
<div class="line">acc8 -= z80*abs(x80) + z81*abs(x81)</div>
<div class="line">acc9 -= z90*abs(x90) + z91*abs(x91)</div>
<div class="line">acc10 -= z100*abs(x100) + z101*abs(x101)</div>
<div class="line">acc11 -= z110*abs(x110) + z111*abs(x111)</div>
<div class="line">acc12 -= z120*abs(x120) + z121*abs(x121)</div>
<div class="line">acc13 -= z130*abs(x130) + z131*abs(x131)</div>
<div class="line">acc14 -= z140*abs(x140) + z141*abs(x141)</div>
<div class="line">acc15 -= z150*abs(x150) + z151*abs(x151)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7234a9fc4ea15898417b6ec5eb36f161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_abs </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 -= z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 -= z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 -= z30*abs(x30) + z31*abs(x31)</div>
<div class="line">acc4 -= z40*abs(x40) + z41*abs(x41)</div>
<div class="line">acc5 -= z50*abs(x50) + z51*abs(x51)</div>
<div class="line">acc6 -= z60*abs(x60) + z61*abs(x61)</div>
<div class="line">acc7 -= z70*abs(x70) + z71*abs(x71)</div>
<div class="line">acc8 -= z80*abs(x80) + z81*abs(x81)</div>
<div class="line">acc9 -= z90*abs(x90) + z91*abs(x91)</div>
<div class="line">acc10 -= z100*abs(x100) + z101*abs(x101)</div>
<div class="line">acc11 -= z110*abs(x110) + z111*abs(x111)</div>
<div class="line">acc12 -= z120*abs(x120) + z121*abs(x121)</div>
<div class="line">acc13 -= z130*abs(x130) + z131*abs(x131)</div>
<div class="line">acc14 -= z140*abs(x140) + z141*abs(x141)</div>
<div class="line">acc15 -= z150*abs(x150) + z151*abs(x151)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2140f3495d5f1870dcb55bb507bd9ea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_max </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_msc16_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 -= z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 -= z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 -= z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 -= z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 -= z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 -= z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 -= z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 -= z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 -= z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 -= z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 -= z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 -= z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga632da9999d9937908b1b98c02d331ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_max </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 -= z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 -= z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 -= z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 -= z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 -= z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 -= z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 -= z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 -= z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 -= z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 -= z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 -= z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 -= z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga78a9fd212af02a0add61d33c3c935124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_max </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 -= z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 -= z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 -= z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 -= z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 -= z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 -= z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 -= z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 -= z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 -= z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 -= z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 -= z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 -= z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7f7ff60d32b9fd3127db302b47eb3735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_msc16_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 -= z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 -= z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 -= z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 -= z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 -= z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 -= z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 -= z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 -= z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2f57013757426014441daa1e6b69ea1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 -= z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 -= z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 -= z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 -= z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 -= z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 -= z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 -= z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 -= z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaec7fefb78c95a19e04de66c9f135a63c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 -= z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 -= z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 -= z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 -= z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 -= z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 -= z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 -= z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 -= z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7482c9e68c56e969c586c94c7e33802a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_min </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_msc16_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 -= z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 -= z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 -= z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 -= z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 -= z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 -= z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 -= z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 -= z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 -= z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 -= z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 -= z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 -= z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6c7c67fd4cdca76a7b76d158e31b2af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_min </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 -= z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 -= z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 -= z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 -= z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 -= z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 -= z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 -= z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 -= z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 -= z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 -= z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 -= z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 -= z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa331ef508d32fd9e64797de0a6278ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 msc16_min </td>
          <td>(</td>
          <td class="paramtype">v16acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_msc16_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 -= z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 -= z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 -= z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 -= z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 -= z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 -= z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 -= z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 -= z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 -= z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 -= z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 -= z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 -= z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v16acc48 </td><td>Incoming accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf6d10576959233facdfd11929d32368f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_msc8_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03)</div>
<div class="line">acc1 -= z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13)</div>
<div class="line">acc2 -= z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23)</div>
<div class="line">acc3 -= z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33)</div>
<div class="line">acc4 -= z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43)</div>
<div class="line">acc5 -= z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53)</div>
<div class="line">acc6 -= z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63)</div>
<div class="line">acc7 -= z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1e01854869037f317adc5c54609f8edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_abs </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03)</div>
<div class="line">acc1 -= z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13)</div>
<div class="line">acc2 -= z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23)</div>
<div class="line">acc3 -= z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33)</div>
<div class="line">acc4 -= z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43)</div>
<div class="line">acc5 -= z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53)</div>
<div class="line">acc6 -= z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63)</div>
<div class="line">acc7 -= z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaae5a0b1b2214453c9c2b6ad6895f6f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_msc8_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 -= z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 -= z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 -= z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 -= z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga14eeff6e55c8e2e918d85592805e118c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 -= z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 -= z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 -= z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 -= z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa391ed1eed29a8bb0c57fed0816c9f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_max </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 -= z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 -= z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 -= z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 -= z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 -= z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 -= z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 -= z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac956590c1e3c7b4c5111847c20a1d3a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_msc8_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab8ef0f2e209a06c2681819a37304288c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf311375daf501632418e9b111696a866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 -= z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 -= z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 -= z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 -= z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 -= z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 -= z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 -= z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga454539f13aab3a121761341b618bc6bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_msc8_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 -= z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 -= z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 -= z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 -= z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7a70e6fab4f3ef4262f99dcc56a92b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 -= z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 -= z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 -= z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 -= z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0fc051986da45509ba84cdae6f73ec20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 msc8_min </td>
          <td>(</td>
          <td class="paramtype">v8acc48&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_msc8_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 -= z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 -= z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 -= z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 -= z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 -= z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 -= z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 -= z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 -= z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>acc </td><td>v8acc48 </td><td>Incoming accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6a0356541b205ed0ebe0839a80e8d5f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_abs </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mul16_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 = z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 = z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 = z30*abs(x30) + z31*abs(x31)</div>
<div class="line">acc4 = z40*abs(x40) + z41*abs(x41)</div>
<div class="line">acc5 = z50*abs(x50) + z51*abs(x51)</div>
<div class="line">acc6 = z60*abs(x60) + z61*abs(x61)</div>
<div class="line">acc7 = z70*abs(x70) + z71*abs(x71)</div>
<div class="line">acc8 = z80*abs(x80) + z81*abs(x81)</div>
<div class="line">acc9 = z90*abs(x90) + z91*abs(x91)</div>
<div class="line">acc10 = z100*abs(x100) + z101*abs(x101)</div>
<div class="line">acc11 = z110*abs(x110) + z111*abs(x111)</div>
<div class="line">acc12 = z120*abs(x120) + z121*abs(x121)</div>
<div class="line">acc13 = z130*abs(x130) + z131*abs(x131)</div>
<div class="line">acc14 = z140*abs(x140) + z141*abs(x141)</div>
<div class="line">acc15 = z150*abs(x150) + z151*abs(x151)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga24114d0ef2a2f31e07563fe234856456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_abs </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00) + z01*abs(x01)</div>
<div class="line">acc1 = z10*abs(x10) + z11*abs(x11)</div>
<div class="line">acc2 = z20*abs(x20) + z21*abs(x21)</div>
<div class="line">acc3 = z30*abs(x30) + z31*abs(x31)</div>
<div class="line">acc4 = z40*abs(x40) + z41*abs(x41)</div>
<div class="line">acc5 = z50*abs(x50) + z51*abs(x51)</div>
<div class="line">acc6 = z60*abs(x60) + z61*abs(x61)</div>
<div class="line">acc7 = z70*abs(x70) + z71*abs(x71)</div>
<div class="line">acc8 = z80*abs(x80) + z81*abs(x81)</div>
<div class="line">acc9 = z90*abs(x90) + z91*abs(x91)</div>
<div class="line">acc10 = z100*abs(x100) + z101*abs(x101)</div>
<div class="line">acc11 = z110*abs(x110) + z111*abs(x111)</div>
<div class="line">acc12 = z120*abs(x120) + z121*abs(x121)</div>
<div class="line">acc13 = z130*abs(x130) + z131*abs(x131)</div>
<div class="line">acc14 = z140*abs(x140) + z141*abs(x141)</div>
<div class="line">acc15 = z150*abs(x150) + z151*abs(x151)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa89dcf9626439a94294a911bcb96a585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_max </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mul16_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 = z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 = z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 = z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 = z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 = z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 = z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 = z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 = z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 = z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 = z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 = z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 = z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0330dd8725dd2999903963dfbc216f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 = z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 = z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 = z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 = z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 = z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 = z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 = z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 = z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 = z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 = z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 = z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 = z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga70e46cdce6414db3399314eebf0d34d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31))</div>
<div class="line">acc4 = z40*(max(x40 , y40)) + z41*(max(x41 , y41))</div>
<div class="line">acc5 = z50*(max(x50 , y50)) + z51*(max(x51 , y51))</div>
<div class="line">acc6 = z60*(max(x60 , y60)) + z61*(max(x61 , y61))</div>
<div class="line">acc7 = z70*(max(x70 , y70)) + z71*(max(x71 , y71))</div>
<div class="line">acc8 = z80*(max(x80 , y80)) + z81*(max(x81 , y81))</div>
<div class="line">acc9 = z90*(max(x90 , y90)) + z91*(max(x91 , y91))</div>
<div class="line">acc10 = z100*(max(x100 , y100)) + z101*(max(x101 , y101))</div>
<div class="line">acc11 = z110*(max(x110 , y110)) + z111*(max(x111 , y111))</div>
<div class="line">acc12 = z120*(max(x120 , y120)) + z121*(max(x121 , y121))</div>
<div class="line">acc13 = z130*(max(x130 , y130)) + z131*(max(x131 , y131))</div>
<div class="line">acc14 = z140*(max(x140 , y140)) + z141*(max(x141 , y141))</div>
<div class="line">acc15 = z150*(max(x150 , y150)) + z151*(max(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa58276b775e1cb92d6549530f83f79b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mul16_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 = z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 = z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 = z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 = z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 = z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 = z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 = z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 = z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf4e9fd1d91b81829ab640c6dc041ff6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 = z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 = z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 = z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 = z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 = z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 = z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 = z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 = z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae73118477af06e175ac3710f4b190c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0)</div>
<div class="line">acc8 = z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0)</div>
<div class="line">acc9 = z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0)</div>
<div class="line">acc10 = z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0)</div>
<div class="line">acc11 = z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0)</div>
<div class="line">acc12 = z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0)</div>
<div class="line">acc13 = z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0)</div>
<div class="line">acc14 = z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0)</div>
<div class="line">acc15 = z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga2e8a48fe10fd684113993d355634de23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_min </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_mul16_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 = z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 = z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 = z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 = z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 = z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 = z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 = z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 = z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 = z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 = z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 = z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 = z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf6f96edde88309d8ea0369c9be7b43b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 = z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 = z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 = z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 = z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 = z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 = z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 = z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 = z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 = z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 = z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 = z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 = z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0b0ed79061545c138601e34d5b1a9f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 mul16_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_mul16_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31))</div>
<div class="line">acc4 = z40*(min(x40 , y40)) + z41*(min(x41 , y41))</div>
<div class="line">acc5 = z50*(min(x50 , y50)) + z51*(min(x51 , y51))</div>
<div class="line">acc6 = z60*(min(x60 , y60)) + z61*(min(x61 , y61))</div>
<div class="line">acc7 = z70*(min(x70 , y70)) + z71*(min(x71 , y71))</div>
<div class="line">acc8 = z80*(min(x80 , y80)) + z81*(min(x81 , y81))</div>
<div class="line">acc9 = z90*(min(x90 , y90)) + z91*(min(x91 , y91))</div>
<div class="line">acc10 = z100*(min(x100 , y100)) + z101*(min(x101 , y101))</div>
<div class="line">acc11 = z110*(min(x110 , y110)) + z111*(min(x111 , y111))</div>
<div class="line">acc12 = z120*(min(x120 , y120)) + z121*(min(x121 , y121))</div>
<div class="line">acc13 = z130*(min(x130 , y130)) + z131*(min(x131 , y131))</div>
<div class="line">acc14 = z140*(min(x140 , y140)) + z141*(min(x141 , y141))</div>
<div class="line">acc15 = z150*(min(x150 , y150)) + z151*(min(x151 , y151))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7a2737dec5ce1c7738679a2d59a327d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_abs </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mul8_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03)</div>
<div class="line">acc1 = z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13)</div>
<div class="line">acc2 = z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23)</div>
<div class="line">acc3 = z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33)</div>
<div class="line">acc4 = z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43)</div>
<div class="line">acc5 = z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53)</div>
<div class="line">acc6 = z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63)</div>
<div class="line">acc7 = z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1d8dbbeeafc04e6868b87dfcd5383088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_abs </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03)</div>
<div class="line">acc1 = z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13)</div>
<div class="line">acc2 = z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23)</div>
<div class="line">acc3 = z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33)</div>
<div class="line">acc4 = z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43)</div>
<div class="line">acc5 = z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53)</div>
<div class="line">acc6 = z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63)</div>
<div class="line">acc7 = z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaec84619467140740a1977fdf6f355c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_max </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mul8_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 = z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 = z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 = z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 = z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga8a5aa7e9613dea515480fca34a6e8ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 = z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 = z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 = z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 = z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf37e48040086f5f5297346fe727cfd3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03))</div>
<div class="line">acc1 = z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13))</div>
<div class="line">acc2 = z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23))</div>
<div class="line">acc3 = z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33))</div>
<div class="line">acc4 = z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43))</div>
<div class="line">acc5 = z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53))</div>
<div class="line">acc6 = z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63))</div>
<div class="line">acc7 = z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae74b8c40a61727809bffbe4dc995cfcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mul8_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad6edaad9054d050a21d45f3cade55822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga60cd67e0ecbd2c0c27ab5f59e88102c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0)</div>
<div class="line">acc1 = z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0)</div>
<div class="line">acc2 = z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0)</div>
<div class="line">acc3 = z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0)</div>
<div class="line">acc4 = z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0)</div>
<div class="line">acc5 = z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0)</div>
<div class="line">acc6 = z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0)</div>
<div class="line">acc7 = z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0)</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0a2d6460b3e001c6e5c23903eefa5853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_min </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_mul8_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 = z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 = z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 = z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 = z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf35142c022d01274e99d48c014656f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 = z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 = z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 = z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 = z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0fe7289262b24835069b9f5045d09dcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 mul8_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_mul8_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03))</div>
<div class="line">acc1 = z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13))</div>
<div class="line">acc2 = z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23))</div>
<div class="line">acc3 = z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33))</div>
<div class="line">acc4 = z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43))</div>
<div class="line">acc5 = z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53))</div>
<div class="line">acc6 = z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63))</div>
<div class="line">acc7 = z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73))</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaeffc30977a287a3dd357dc073fd95189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_abs </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_negmul16_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) + z01*abs(x01) )</div>
<div class="line">acc1 = -( z10*abs(x10) + z11*abs(x11) )</div>
<div class="line">acc2 = -( z20*abs(x20) + z21*abs(x21) )</div>
<div class="line">acc3 = -( z30*abs(x30) + z31*abs(x31) )</div>
<div class="line">acc4 = -( z40*abs(x40) + z41*abs(x41) )</div>
<div class="line">acc5 = -( z50*abs(x50) + z51*abs(x51) )</div>
<div class="line">acc6 = -( z60*abs(x60) + z61*abs(x61) )</div>
<div class="line">acc7 = -( z70*abs(x70) + z71*abs(x71) )</div>
<div class="line">acc8 = -( z80*abs(x80) + z81*abs(x81) )</div>
<div class="line">acc9 = -( z90*abs(x90) + z91*abs(x91) )</div>
<div class="line">acc10 = -( z100*abs(x100) + z101*abs(x101) )</div>
<div class="line">acc11 = -( z110*abs(x110) + z111*abs(x111) )</div>
<div class="line">acc12 = -( z120*abs(x120) + z121*abs(x121) )</div>
<div class="line">acc13 = -( z130*abs(x130) + z131*abs(x131) )</div>
<div class="line">acc14 = -( z140*abs(x140) + z141*abs(x141) )</div>
<div class="line">acc15 = -( z150*abs(x150) + z151*abs(x151) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga43050077cb4be9666017874cbb019fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_abs </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) + z01*abs(x01) )</div>
<div class="line">acc1 = -( z10*abs(x10) + z11*abs(x11) )</div>
<div class="line">acc2 = -( z20*abs(x20) + z21*abs(x21) )</div>
<div class="line">acc3 = -( z30*abs(x30) + z31*abs(x31) )</div>
<div class="line">acc4 = -( z40*abs(x40) + z41*abs(x41) )</div>
<div class="line">acc5 = -( z50*abs(x50) + z51*abs(x51) )</div>
<div class="line">acc6 = -( z60*abs(x60) + z61*abs(x61) )</div>
<div class="line">acc7 = -( z70*abs(x70) + z71*abs(x71) )</div>
<div class="line">acc8 = -( z80*abs(x80) + z81*abs(x81) )</div>
<div class="line">acc9 = -( z90*abs(x90) + z91*abs(x91) )</div>
<div class="line">acc10 = -( z100*abs(x100) + z101*abs(x101) )</div>
<div class="line">acc11 = -( z110*abs(x110) + z111*abs(x111) )</div>
<div class="line">acc12 = -( z120*abs(x120) + z121*abs(x121) )</div>
<div class="line">acc13 = -( z130*abs(x130) + z131*abs(x131) )</div>
<div class="line">acc14 = -( z140*abs(x140) + z141*abs(x141) )</div>
<div class="line">acc15 = -( z150*abs(x150) + z151*abs(x151) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab2ec7def3ffefd0578398f8fa96fc8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_max </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_negmul16_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) + z41*(max(x41 , y41)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) + z51*(max(x51 , y51)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) + z61*(max(x61 , y61)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) + z71*(max(x71 , y71)) )</div>
<div class="line">acc8 = -( z80*(max(x80 , y80)) + z81*(max(x81 , y81)) )</div>
<div class="line">acc9 = -( z90*(max(x90 , y90)) + z91*(max(x91 , y91)) )</div>
<div class="line">acc10 = -( z100*(max(x100 , y100)) + z101*(max(x101 , y101)) )</div>
<div class="line">acc11 = -( z110*(max(x110 , y110)) + z111*(max(x111 , y111)) )</div>
<div class="line">acc12 = -( z120*(max(x120 , y120)) + z121*(max(x121 , y121)) )</div>
<div class="line">acc13 = -( z130*(max(x130 , y130)) + z131*(max(x131 , y131)) )</div>
<div class="line">acc14 = -( z140*(max(x140 , y140)) + z141*(max(x141 , y141)) )</div>
<div class="line">acc15 = -( z150*(max(x150 , y150)) + z151*(max(x151 , y151)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga89722b419061bb185b338b16564d2b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) + z41*(max(x41 , y41)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) + z51*(max(x51 , y51)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) + z61*(max(x61 , y61)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) + z71*(max(x71 , y71)) )</div>
<div class="line">acc8 = -( z80*(max(x80 , y80)) + z81*(max(x81 , y81)) )</div>
<div class="line">acc9 = -( z90*(max(x90 , y90)) + z91*(max(x91 , y91)) )</div>
<div class="line">acc10 = -( z100*(max(x100 , y100)) + z101*(max(x101 , y101)) )</div>
<div class="line">acc11 = -( z110*(max(x110 , y110)) + z111*(max(x111 , y111)) )</div>
<div class="line">acc12 = -( z120*(max(x120 , y120)) + z121*(max(x121 , y121)) )</div>
<div class="line">acc13 = -( z130*(max(x130 , y130)) + z131*(max(x131 , y131)) )</div>
<div class="line">acc14 = -( z140*(max(x140 , y140)) + z141*(max(x141 , y141)) )</div>
<div class="line">acc15 = -( z150*(max(x150 , y150)) + z151*(max(x151 , y151)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga47461ec0e591fde1e8bad010ad893e66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) + z41*(max(x41 , y41)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) + z51*(max(x51 , y51)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) + z61*(max(x61 , y61)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) + z71*(max(x71 , y71)) )</div>
<div class="line">acc8 = -( z80*(max(x80 , y80)) + z81*(max(x81 , y81)) )</div>
<div class="line">acc9 = -( z90*(max(x90 , y90)) + z91*(max(x91 , y91)) )</div>
<div class="line">acc10 = -( z100*(max(x100 , y100)) + z101*(max(x101 , y101)) )</div>
<div class="line">acc11 = -( z110*(max(x110 , y110)) + z111*(max(x111 , y111)) )</div>
<div class="line">acc12 = -( z120*(max(x120 , y120)) + z121*(max(x121 , y121)) )</div>
<div class="line">acc13 = -( z130*(max(x130 , y130)) + z131*(max(x131 , y131)) )</div>
<div class="line">acc14 = -( z140*(max(x140 , y140)) + z141*(max(x141 , y141)) )</div>
<div class="line">acc15 = -( z150*(max(x150 , y150)) + z151*(max(x151 , y151)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3e646c54d0c23da3535350d84a0b205b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_negmul16_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) )</div>
<div class="line">acc8 = -( z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0) )</div>
<div class="line">acc9 = -( z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0) )</div>
<div class="line">acc10 = -( z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0) )</div>
<div class="line">acc11 = -( z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0) )</div>
<div class="line">acc12 = -( z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0) )</div>
<div class="line">acc13 = -( z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0) )</div>
<div class="line">acc14 = -( z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0) )</div>
<div class="line">acc15 = -( z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad9805d14a0c332e2533ffe0a4cd518e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) )</div>
<div class="line">acc8 = -( z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0) )</div>
<div class="line">acc9 = -( z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0) )</div>
<div class="line">acc10 = -( z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0) )</div>
<div class="line">acc11 = -( z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0) )</div>
<div class="line">acc12 = -( z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0) )</div>
<div class="line">acc13 = -( z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0) )</div>
<div class="line">acc14 = -( z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0) )</div>
<div class="line">acc15 = -( z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5b1c3752936c113b04b5c882ebc16b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) )</div>
<div class="line">acc8 = -( z80*((x80 - y80 &gt; 0) ? (x80 - y80):0) + z81*((x81 - y81 &gt; 0) ? (x81 - y81):0) )</div>
<div class="line">acc9 = -( z90*((x90 - y90 &gt; 0) ? (x90 - y90):0) + z91*((x91 - y91 &gt; 0) ? (x91 - y91):0) )</div>
<div class="line">acc10 = -( z100*((x100 - y100 &gt; 0) ? (x100 - y100):0) + z101*((x101 - y101 &gt; 0) ? (x101 - y101):0) )</div>
<div class="line">acc11 = -( z110*((x110 - y110 &gt; 0) ? (x110 - y110):0) + z111*((x111 - y111 &gt; 0) ? (x111 - y111):0) )</div>
<div class="line">acc12 = -( z120*((x120 - y120 &gt; 0) ? (x120 - y120):0) + z121*((x121 - y121 &gt; 0) ? (x121 - y121):0) )</div>
<div class="line">acc13 = -( z130*((x130 - y130 &gt; 0) ? (x130 - y130):0) + z131*((x131 - y131 &gt; 0) ? (x131 - y131):0) )</div>
<div class="line">acc14 = -( z140*((x140 - y140 &gt; 0) ? (x140 - y140):0) + z141*((x141 - y141 &gt; 0) ? (x141 - y141):0) )</div>
<div class="line">acc15 = -( z150*((x150 - y150 &gt; 0) ? (x150 - y150):0) + z151*((x151 - y151 &gt; 0) ? (x151 - y151):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga631615201b1568c516cf9df5afc09e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_min </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v16acc48_negmul16_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) + z41*(min(x41 , y41)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) + z51*(min(x51 , y51)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) + z61*(min(x61 , y61)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) + z71*(min(x71 , y71)) )</div>
<div class="line">acc8 = -( z80*(min(x80 , y80)) + z81*(min(x81 , y81)) )</div>
<div class="line">acc9 = -( z90*(min(x90 , y90)) + z91*(min(x91 , y91)) )</div>
<div class="line">acc10 = -( z100*(min(x100 , y100)) + z101*(min(x101 , y101)) )</div>
<div class="line">acc11 = -( z110*(min(x110 , y110)) + z111*(min(x111 , y111)) )</div>
<div class="line">acc12 = -( z120*(min(x120 , y120)) + z121*(min(x121 , y121)) )</div>
<div class="line">acc13 = -( z130*(min(x130 , y130)) + z131*(min(x131 , y131)) )</div>
<div class="line">acc14 = -( z140*(min(x140 , y140)) + z141*(min(x141 , y141)) )</div>
<div class="line">acc15 = -( z150*(min(x150 , y150)) + z151*(min(x151 , y151)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5ba97f59d9d225d6db7601ef7ff22e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) + z41*(min(x41 , y41)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) + z51*(min(x51 , y51)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) + z61*(min(x61 , y61)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) + z71*(min(x71 , y71)) )</div>
<div class="line">acc8 = -( z80*(min(x80 , y80)) + z81*(min(x81 , y81)) )</div>
<div class="line">acc9 = -( z90*(min(x90 , y90)) + z91*(min(x91 , y91)) )</div>
<div class="line">acc10 = -( z100*(min(x100 , y100)) + z101*(min(x101 , y101)) )</div>
<div class="line">acc11 = -( z110*(min(x110 , y110)) + z111*(min(x111 , y111)) )</div>
<div class="line">acc12 = -( z120*(min(x120 , y120)) + z121*(min(x121 , y121)) )</div>
<div class="line">acc13 = -( z130*(min(x130 , y130)) + z131*(min(x131 , y131)) )</div>
<div class="line">acc14 = -( z140*(min(x140 , y140)) + z141*(min(x141 , y141)) )</div>
<div class="line">acc15 = -( z150*(min(x150 , y150)) + z151*(min(x151 , y151)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa9d447454a66696c51de95f007a2adfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v16acc48 negmul16_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v16acc48_negmul16_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) + z41*(min(x41 , y41)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) + z51*(min(x51 , y51)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) + z61*(min(x61 , y61)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) + z71*(min(x71 , y71)) )</div>
<div class="line">acc8 = -( z80*(min(x80 , y80)) + z81*(min(x81 , y81)) )</div>
<div class="line">acc9 = -( z90*(min(x90 , y90)) + z91*(min(x91 , y91)) )</div>
<div class="line">acc10 = -( z100*(min(x100 , y100)) + z101*(min(x101 , y101)) )</div>
<div class="line">acc11 = -( z110*(min(x110 , y110)) + z111*(min(x111 , y111)) )</div>
<div class="line">acc12 = -( z120*(min(x120 , y120)) + z121*(min(x121 , y121)) )</div>
<div class="line">acc13 = -( z130*(min(x130 , y130)) + z131*(min(x131 , y131)) )</div>
<div class="line">acc14 = -( z140*(min(x140 , y140)) + z141*(min(x141 , y141)) )</div>
<div class="line">acc15 = -( z150*(min(x150 , y150)) + z151*(min(x151 , y151)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v16acc48 </td><td>Returned accumulation vector (16 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to first lane </td></tr>
<tr>
<td>xoffsets_hi </td><td>unsigned int </td><td>4b offset for each lane, corresponds to 2x the lane number and each second lane is an offset to the lane before + 1. LSB apply to 8th lane </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zoffsets_hi</td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to 8th lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf2b461511bc029f7fe07a68c21d9fe02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_abs </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_negmul8_abs_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03) )</div>
<div class="line">acc1 = -( z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13) )</div>
<div class="line">acc2 = -( z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23) )</div>
<div class="line">acc3 = -( z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33) )</div>
<div class="line">acc4 = -( z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43) )</div>
<div class="line">acc5 = -( z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53) )</div>
<div class="line">acc6 = -( z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63) )</div>
<div class="line">acc7 = -( z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabdad5d6eac0030856c8f89d4ab71a0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_abs </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the absolute value in the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_abs_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*abs(x00) + z01*abs(x01) + z02*abs(x02) + z03*abs(x03) )</div>
<div class="line">acc1 = -( z10*abs(x10) + z11*abs(x11) + z12*abs(x12) + z13*abs(x13) )</div>
<div class="line">acc2 = -( z20*abs(x20) + z21*abs(x21) + z22*abs(x22) + z23*abs(x23) )</div>
<div class="line">acc3 = -( z30*abs(x30) + z31*abs(x31) + z32*abs(x32) + z33*abs(x33) )</div>
<div class="line">acc4 = -( z40*abs(x40) + z41*abs(x41) + z42*abs(x42) + z43*abs(x43) )</div>
<div class="line">acc5 = -( z50*abs(x50) + z51*abs(x51) + z52*abs(x52) + z53*abs(x53) )</div>
<div class="line">acc6 = -( z60*abs(x60) + z61*abs(x61) + z62*abs(x62) + z63*abs(x63) )</div>
<div class="line">acc7 = -( z70*abs(x70) + z71*abs(x71) + z72*abs(x72) + z73*abs(x73) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to the x buffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the xbuffer. <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac89f4d7fd33edfa99df9bc201edf0189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_max </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_negmul8_max_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab9b791d1762d40fd21a535a69bb45dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_max_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga43d9a43264428dcfb75b393b7e318be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_max </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_max_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(max(x00 , y00)) + z01*(max(x01 , y01)) + z02*(max(x02 , y02)) + z03*(max(x03 , y03)) )</div>
<div class="line">acc1 = -( z10*(max(x10 , y10)) + z11*(max(x11 , y11)) + z12*(max(x12 , y12)) + z13*(max(x13 , y13)) )</div>
<div class="line">acc2 = -( z20*(max(x20 , y20)) + z21*(max(x21 , y21)) + z22*(max(x22 , y22)) + z23*(max(x23 , y23)) )</div>
<div class="line">acc3 = -( z30*(max(x30 , y30)) + z31*(max(x31 , y31)) + z32*(max(x32 , y32)) + z33*(max(x33 , y33)) )</div>
<div class="line">acc4 = -( z40*(max(x40 , y40)) + z41*(max(x41 , y41)) + z42*(max(x42 , y42)) + z43*(max(x43 , y43)) )</div>
<div class="line">acc5 = -( z50*(max(x50 , y50)) + z51*(max(x51 , y51)) + z52*(max(x52 , y52)) + z53*(max(x53 , y53)) )</div>
<div class="line">acc6 = -( z60*(max(x60 , y60)) + z61*(max(x61 , y61)) + z62*(max(x62 , y62)) + z63*(max(x63 , y63)) )</div>
<div class="line">acc7 = -( z70*(max(x70 , y70)) + z71*(max(x71 , y71)) + z72*(max(x72 , y72)) + z73*(max(x73 , y73)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacfac08506108417aff4b31c423e92ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_negmul8_maxdiff_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4617d4c4215b614d06069fc5f8f1529b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_maxdiff_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga64a9ae6a87b28424b1e9ba0f31949326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_maxdiff </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the maximum difference between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_maxdiff_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*((x00 - y00 &gt; 0) ? (x00 - y00):0) + z01*((x01 - y01 &gt; 0) ? (x01 - y01):0) + z02*((x02 - y02 &gt; 0) ? (x02 - y02):0) + z03*((x03 - y03 &gt; 0) ? (x03 - y03):0) )</div>
<div class="line">acc1 = -( z10*((x10 - y10 &gt; 0) ? (x10 - y10):0) + z11*((x11 - y11 &gt; 0) ? (x11 - y11):0) + z12*((x12 - y12 &gt; 0) ? (x12 - y12):0) + z13*((x13 - y13 &gt; 0) ? (x13 - y13):0) )</div>
<div class="line">acc2 = -( z20*((x20 - y20 &gt; 0) ? (x20 - y20):0) + z21*((x21 - y21 &gt; 0) ? (x21 - y21):0) + z22*((x22 - y22 &gt; 0) ? (x22 - y22):0) + z23*((x23 - y23 &gt; 0) ? (x23 - y23):0) )</div>
<div class="line">acc3 = -( z30*((x30 - y30 &gt; 0) ? (x30 - y30):0) + z31*((x31 - y31 &gt; 0) ? (x31 - y31):0) + z32*((x32 - y32 &gt; 0) ? (x32 - y32):0) + z33*((x33 - y33 &gt; 0) ? (x33 - y33):0) )</div>
<div class="line">acc4 = -( z40*((x40 - y40 &gt; 0) ? (x40 - y40):0) + z41*((x41 - y41 &gt; 0) ? (x41 - y41):0) + z42*((x42 - y42 &gt; 0) ? (x42 - y42):0) + z43*((x43 - y43 &gt; 0) ? (x43 - y43):0) )</div>
<div class="line">acc5 = -( z50*((x50 - y50 &gt; 0) ? (x50 - y50):0) + z51*((x51 - y51 &gt; 0) ? (x51 - y51):0) + z52*((x52 - y52 &gt; 0) ? (x52 - y52):0) + z53*((x53 - y53 &gt; 0) ? (x53 - y53):0) )</div>
<div class="line">acc6 = -( z60*((x60 - y60 &gt; 0) ? (x60 - y60):0) + z61*((x61 - y61 &gt; 0) ? (x61 - y61):0) + z62*((x62 - y62 &gt; 0) ? (x62 - y62):0) + z63*((x63 - y63 &gt; 0) ? (x63 - y63):0) )</div>
<div class="line">acc7 = -( z70*((x70 - y70 &gt; 0) ? (x70 - y70):0) + z71*((x71 - y71 &gt; 0) ? (x71 - y71):0) + z72*((x72 - y72 &gt; 0) ? (x72 - y72):0) + z73*((x73 - y73 &gt; 0) ? (x73 - y73):0) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga45769d12f817bf91541be48ffb97df1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_min </td>
          <td>(</td>
          <td class="paramtype">v64int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer . </p>
<p><a class="anchor" id="v8acc48_negmul8_min_v64int16_v16int16_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v64int16</td><td>Input buffer of 64 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga208d60c7bf5e5d6e0b4b8aadd541765d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_min_v32int16_v16int16_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac1a6ea57ee3392c4929aef3c8058d0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">v8acc48 negmul8_min </td>
          <td>(</td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>xbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xsquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v32int16&#160;</td>
          <td class="paramname"><em>ybuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ystart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ysquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v16int16&#160;</td>
          <td class="paramname"><em>zbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate intrinsic function after computing the minimum between the selected lanes from the input buffer using small X input buffer. </p>
<p><a class="anchor" id="v8acc48_negmul8_min_v32int16_v16int16_twobuf_smallbuf_16_16"></a></p>
<div class="fragment"><div class="line">acc0 = -( z00*(min(x00 , y00)) + z01*(min(x01 , y01)) + z02*(min(x02 , y02)) + z03*(min(x03 , y03)) )</div>
<div class="line">acc1 = -( z10*(min(x10 , y10)) + z11*(min(x11 , y11)) + z12*(min(x12 , y12)) + z13*(min(x13 , y13)) )</div>
<div class="line">acc2 = -( z20*(min(x20 , y20)) + z21*(min(x21 , y21)) + z22*(min(x22 , y22)) + z23*(min(x23 , y23)) )</div>
<div class="line">acc3 = -( z30*(min(x30 , y30)) + z31*(min(x31 , y31)) + z32*(min(x32 , y32)) + z33*(min(x33 , y33)) )</div>
<div class="line">acc4 = -( z40*(min(x40 , y40)) + z41*(min(x41 , y41)) + z42*(min(x42 , y42)) + z43*(min(x43 , y43)) )</div>
<div class="line">acc5 = -( z50*(min(x50 , y50)) + z51*(min(x51 , y51)) + z52*(min(x52 , y52)) + z53*(min(x53 , y53)) )</div>
<div class="line">acc6 = -( z60*(min(x60 , y60)) + z61*(min(x61 , y61)) + z62*(min(x62 , y62)) + z63*(min(x63 , y63)) )</div>
<div class="line">acc7 = -( z70*(min(x70 , y70)) + z71*(min(x71 , y71)) + z72*(min(x72 , y72)) + z73*(min(x73 , y73)) )</div>
</div><!-- fragment --> <h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Comments</th></tr>
<tr>
<td>return </td><td>v8acc48 </td><td>Returned accumulation vector (8 x int48 lanes) </td></tr>
<tr>
<td>xbuff </td><td>v32int16</td><td>Input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>Starting position offset applied to all lanes of input from X buffer. <em>xstart</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xoffsets </td><td>unsigned int </td><td>4b offset for each lane, while each second lane is an offset to the lane before + 1, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>unsigned int </td><td>Step between each column for selection in the x and y buffers. Ystep is symmetric to xstep (ystep advances by -xstep). <em>xstep</em> is restricted to multiples of 2 as granularity for xbuff is 32-bit. </td></tr>
<tr>
<td>xsquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>ybuff </td><td>v32int16</td><td>Right input buffer of 32 elements of type int16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>Starting position offset applied to all lanes for input from Y buffer. <em>ystart</em> is restricted to multiples of 2 as granularity for ybuff is 32-bit. </td></tr>
<tr>
<td>ysquare </td><td>unsigned int </td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element </td></tr>
<tr>
<td>zbuff </td><td>v16int16</td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>Starting position offset applied to all lanes for input from Z buffer. This <em>must</em> be a compile time constant. Only the 4 LSB of the argument are used. </td></tr>
<tr>
<td>zoffsets </td><td>unsigned int </td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>Step between each column for selection in the zbuffer. </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how data selection works from the buffers go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a>. For this intrinsic, the data buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b scheme</a> and the coefficient buffer uses the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>.</li>
<li>Parameter 'zstart' <em>must</em> be a compile time constant. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2021 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
