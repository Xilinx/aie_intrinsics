<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: Peak Cancellation Crest Factor Reduction (PC-CFR)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p15.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intr__cfr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Peak Cancellation Crest Factor Reduction (PC-CFR)<div class="ingroups"><a class="el" href="group__intr__apps.html">Application Specific Intrinsics</a> &#124; <a class="el" href="group__intr__scalarop__int.html">Integer Operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>These are the intrinsic functions used for implementing a peak cancellation based crest factor reduction (PC-CFR) application. The functionality for this application is split between AIE and programmable logic (PL), where the PL carries out the peak detections and AIE computes the aggregate cancellation signal for the detected peaks. The cancellation signal samples computed by the AIE are subtracted in the PL from the delayed original signal, to cancel the peaks.</p>
<p>The AIE computes the cancellation signal samples by scaling the cancellation pulse (CP) coefficients (which are stored in the AIE memory) for different peaks and summing them up. The two input stream interfaces of the AI Engine are used to receive the following information from the PL: 1) Metadata for LUT indices to read CP coefficients + configuration information for the vectorized mul/mac operations, 2) Complex scaling factors for the detected peaks. The output stream interface of the AI Engine is employed to send the computed cancellation signal samples to the PL.</p>
<p>Typically the AIE program computing the aggregate cancellation signal for N detected peaks comprises the following steps :</p>
<ul>
<li>Read the input streams:<ul>
<li>Split the metadata from input stream port 0 into CP lut index (idx) and configuration information (ci) to be used by mul or mac intrinsics</li>
<li>Get the scaling factors from input stream port 1 and write them into a scaling factor buffer</li>
</ul>
</li>
<li>Load CP_LUT(idx) and CP_LUT(idx+1) from memory into CP buffer</li>
<li>Pass ci as a parameter to configure the mul intrinsic, which multiplies CP coefficients selected from the CP buffer with</li>
<li>the scaling factor for the first peak from the scaling factor buffer</li>
<li>Repeat the above steps N-1 times by using the mac intrinsic (instead of mul) to find the accumulated result for N peaks</li>
<li>Move the accumulated result through the SRS unit to the output stream. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf7c4c00854e6afb9f3871587a9c8448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__cfr.html#gaaf7c4c00854e6afb9f3871587a9c8448">split</a> (int a, unsigned n, int &amp;d0, unsigned &amp;d1)</td></tr>
<tr class="memdesc:gaaf7c4c00854e6afb9f3871587a9c8448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrinsic used to split the 32 bit input data into two resulting variables at the n-th bit.  <a href="#gaaf7c4c00854e6afb9f3871587a9c8448"></a><br/></td></tr>
<tr class="separator:gaaf7c4c00854e6afb9f3871587a9c8448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CFR Multiplication Intrinsics</h2></td></tr>
<tr class="memitem:ga0e571d53cff038bd43f2595bc7e87066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__cfr.html#ga0e571d53cff038bd43f2595bc7e87066">mul8_cfr</a> (<a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a> xbufa, <a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a> xbufb, int rev_xstart, int xrot, <a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a> zbuf, int zstart)</td></tr>
<tr class="memdesc:ga0e571d53cff038bd43f2595bc7e87066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex multiply intrinsic function for cancellation signal calculations in peak-cancellation crest factor reduction algorithm.  <a href="#ga0e571d53cff038bd43f2595bc7e87066"></a><br/></td></tr>
<tr class="separator:ga0e571d53cff038bd43f2595bc7e87066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb7cdff05030ee2a6c217d43eb43c34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__cfr.html#ga7bb7cdff05030ee2a6c217d43eb43c34">mac8_cfr</a> (<a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> acc, <a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a> xbufa, <a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a> xbufb, int rev_xstart, int xrot, <a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a> zbuf, int zstart)</td></tr>
<tr class="memdesc:ga7bb7cdff05030ee2a6c217d43eb43c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex multiply intrinsic function for cancellation signal calculations in peak-cancellation crest factor reduction algorithm.  <a href="#ga7bb7cdff05030ee2a6c217d43eb43c34"></a><br/></td></tr>
<tr class="separator:ga7bb7cdff05030ee2a6c217d43eb43c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7bb7cdff05030ee2a6c217d43eb43c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> mac8_cfr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a>&#160;</td>
          <td class="paramname"><em>xbufa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a>&#160;</td>
          <td class="paramname"><em>xbufb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rev_xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex multiply intrinsic function for cancellation signal calculations in peak-cancellation crest factor reduction algorithm. </p>
<h2>PARAMETERS</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Valid bits</th><th>Comments</th></tr>
<tr>
<td>acc </td><td><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> </td><td>All </td><td>Running accumulation vector (8 x cint48 lanes). Only in mac variant. </td></tr>
<tr>
<td>xbufa </td><td><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a></td><td>All </td><td>First input buffer of 16 complex samples of type cint16 </td></tr>
<tr>
<td>xbufb </td><td><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a></td><td>All </td><td>Second input buffer of 16 complex samples of type cint16 </td></tr>
<tr>
<td>rev_xstart </td><td>int </td><td>5b LSB </td><td>MSB : Flag for backwards input selection / 4b LSB : select starting point within input data. </td></tr>
<tr>
<td>xrot </td><td>int </td><td>2b LSB </td><td>Selects which 256b lanes of 8 complex samples from bufa and bufb to use. This <em>must</em> be a compile time constant. </td></tr>
<tr>
<td>zbuf </td><td><a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a> </td><td>All </td><td>Buffer of scaling factors for each qualified peak </td></tr>
<tr>
<td>zstart </td><td>int </td><td>3b LSB </td><td>Selects which of the 8 scaling factor values is used. This <em>must</em> be a compile time constant. </td></tr>
<tr>
<td>return value</td><td><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> </td><td>All </td><td>Resulting accumulation vector (8 x cint48 lanes) </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Parameters 'xrot' and 'zstart' <em>must</em> be compile time constants.</dd></dl>
<p>The input data provided by xbufa and xbufb can be seen as a concatenation of 8 cancellation pulse (CP) coefficients of type cint16 from xbufa followed by the next 8 coefficients from xbufb as selected by xrot. The resulting 16 samples will be referred to as "CP" in this document. The CP coefficients are loaded to xbufa and xbufb from memory. zbuf contains the 8 scaling factor values, one for each qualified peak. The zstart parameter is used to select the scaling factor for each mul operation.</p>
<h2>DATA SELECTORS</h2>
<h4>xrot:</h4>
<p>Selects the first or second set of 8 values to be used from both buffers A and B :</p>
<table class="doxtable">
<tr>
<th>xrot value </th><th>selection in xbufa </th><th>selection in xbufb </th></tr>
<tr>
<td>0x0 </td><td>coefficients 0 to 7 </td><td>coefficients 0 to 7 </td></tr>
<tr>
<td>0x1 </td><td>coefficients 8 to 15</td><td>coefficients 0 to 7 </td></tr>
<tr>
<td>0x2 </td><td>coefficients 0 to 7 </td><td>coefficients 8 to 15 </td></tr>
<tr>
<td>0x3 </td><td>coefficients 8 to 15</td><td>coefficients 8 to 15 </td></tr>
</table>
<p>Examples :</p>
<p>If you have updated previously updated xbufa with upd_w(0) (values 0 to 7 have been replaced), and xbufb with upd_w(1) (values 8 to 15), you would chose xrot=0x2</p>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td>xbufa(0)</td><td>xbufa(1)</td><td>xbufa(2)</td><td>xbufa(3)</td><td>xbufa(4)</td><td>xbufa(5)</td><td>xbufa(6)</td><td>xbufa(7)</td><td>xbufb(8)</td><td>xbufb(9)</td><td>xbufb(10)</td><td>xbufb(11)</td><td>xbufb(12)</td><td>xbufb(13)</td><td>xbufb(14)</td><td>xbufb(15) </td></tr>
</table>
<p>If you have xrot=0x1 :</p>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td>xbufa(8)</td><td>xbufa(9)</td><td>xbufa(10)</td><td>xbufa(11)</td><td>xbufa(12)</td><td>xbufa(13)</td><td>xbufa(14)</td><td>xbufa(15)</td><td>xbufb(0)</td><td>xbufb(1)</td><td>xbufb(2) </td><td>xbufb(3) </td><td>xbufb(4) </td><td>xbufb(5) </td><td>xbufb(6) </td><td>xbufb(7) </td></tr>
</table>
<p>It is standard practice to use only upd_w(0) and leave xrot at 0x0 unless your application can benefit from this option.</p>
<h4>zstart:</h4>
<p>Selects which of the 8 scaling factor values in zbuf will be used for the multiply operation, simply varies between 0x0 and 0x7</p>
<h4>rev_xstart:</h4>
<p>The 4 LSB select the starting point within the 16 CP values, since only 8 input CP values will be used for a mac operation.</p>
<p>Once the starting point is selected, the remaining MSB of rev_xstart determines which direction the operation will take place. The use of this flag improves the memory efficiency for conjugate-symmetric CPs since only half of the CP coefficients need to be present in the memory.</p>
<p>Example :</p>
<p>If the 4 bits are set to 0x7, CP(7) will be selected as the starting point. Then the MSB of rev_xstart will influence the way the operation works :</p>
<ul>
<li>Set to 0 : CP(7) up to CP(14) will be used</li>
</ul>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>start </td><td>---&mdash;&gt;</td><td>---&mdash;&gt;</td><td>----&mdash;&gt;</td><td>----&mdash;&gt;</td><td>----&mdash;&gt;</td><td>----&mdash;&gt;</td><td>end </td><td></td></tr>
</table>
<ul>
<li>Set to 1 : The complex conjugates of CP(7) down to CP(0) will be used</li>
</ul>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td>end </td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>start </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p><br/>
<br/>
</p>
<h2>FULL EXAMPLES</h2>
<p>For both examples, the CP values will have been loaded into the lower half of xbufa and xbufb before they are passed to the function, and xrot can be left at 0x0.</p>
<p>The mac variant of this intrinsic is similar, but accumulates into acc instead of assignment.</p>
<h4>Example 1 (MSB of rev_xstart=0)</h4>
<p>Command : mul8_cfr(xbufa, xbufb, 0x04, 0x0, zbuf, 0x2)</p>
<ul>
<li>zstart is at 0x2, the third scaling factor value of zbuf will be used.</li>
</ul>
<ul>
<li>The 4 LSB of rev_xstart are set to 0x4, the starting point within the 16 available CP values will be 4.</li>
</ul>
<p>Resulting operation :</p>
<div class="fragment"><div class="line">acc(0) = zbuf(2) * CP(4)</div>
<div class="line">acc(1) = zbuf(2) * CP(5)</div>
<div class="line">acc(2) = zbuf(2) * CP(6)</div>
<div class="line">acc(3) = zbuf(2) * CP(7)</div>
<div class="line">acc(4) = zbuf(2) * CP(8)</div>
<div class="line">acc(5) = zbuf(2) * CP(9)</div>
<div class="line">acc(6) = zbuf(2) * CP(10)</div>
<div class="line">acc(7) = zbuf(2) * CP(11)</div>
</div><!-- fragment --><h4>Example 2 (MSB of rev_xstart=1)</h4>
<p>Command : mul8_cfr(xbufa, xbufb, 0x09, 0x0, zbuf, 0x3)</p>
<ul>
<li>zstart is at 0x3, the fourth scaling factor value of zbuf will be used.</li>
</ul>
<ul>
<li>The 4 LSB of rev_xstart are set to 0x9, the starting point within the 16 available CP values will be 9.</li>
</ul>
<ul>
<li>The MSB of rev_xstart is set to 1, so the CP values will go from CP(9) down to CP(2) and use the complex conjugates</li>
</ul>
<p>Resulting operation :</p>
<div class="fragment"><div class="line">acc(0) = zbuf(3) * conj(CP(9))</div>
<div class="line">acc(1) = zbuf(3) * conj(CP(8))</div>
<div class="line">acc(2) = zbuf(3) * conj(CP(7))</div>
<div class="line">acc(3) = zbuf(3) * conj(CP(6))</div>
<div class="line">acc(4) = zbuf(3) * conj(CP(5))</div>
<div class="line">acc(5) = zbuf(3) * conj(CP(4))</div>
<div class="line">acc(6) = zbuf(3) * conj(CP(3))</div>
<div class="line">acc(7) = zbuf(3) * conj(CP(2))</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga0e571d53cff038bd43f2595bc7e87066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> mul8_cfr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a>&#160;</td>
          <td class="paramname"><em>xbufa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a>&#160;</td>
          <td class="paramname"><em>xbufb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rev_xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complex multiply intrinsic function for cancellation signal calculations in peak-cancellation crest factor reduction algorithm. </p>
<h2>PARAMETERS</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Valid bits</th><th>Comments</th></tr>
<tr>
<td>acc </td><td><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> </td><td>All </td><td>Running accumulation vector (8 x cint48 lanes). Only in mac variant. </td></tr>
<tr>
<td>xbufa </td><td><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a></td><td>All </td><td>First input buffer of 16 complex samples of type cint16 </td></tr>
<tr>
<td>xbufb </td><td><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a></td><td>All </td><td>Second input buffer of 16 complex samples of type cint16 </td></tr>
<tr>
<td>rev_xstart </td><td>int </td><td>5b LSB </td><td>MSB : Flag for backwards input selection / 4b LSB : select starting point within input data. </td></tr>
<tr>
<td>xrot </td><td>int </td><td>2b LSB </td><td>Selects which 256b lanes of 8 complex samples from bufa and bufb to use. This <em>must</em> be a compile time constant. </td></tr>
<tr>
<td>zbuf </td><td><a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a> </td><td>All </td><td>Buffer of scaling factors for each qualified peak </td></tr>
<tr>
<td>zstart </td><td>int </td><td>3b LSB </td><td>Selects which of the 8 scaling factor values is used. This <em>must</em> be a compile time constant. </td></tr>
<tr>
<td>return value</td><td><a class="el" href="group__dt__gpvector__daccum.html#classv8cacc48">v8cacc48</a> </td><td>All </td><td>Resulting accumulation vector (8 x cint48 lanes) </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Parameters 'xrot' and 'zstart' <em>must</em> be compile time constants.</dd></dl>
<p>The input data provided by xbufa and xbufb can be seen as a concatenation of 8 cancellation pulse (CP) coefficients of type cint16 from xbufa followed by the next 8 coefficients from xbufb as selected by xrot. The resulting 16 samples will be referred to as "CP" in this document. The CP coefficients are loaded to xbufa and xbufb from memory. zbuf contains the 8 scaling factor values, one for each qualified peak. The zstart parameter is used to select the scaling factor for each mul operation.</p>
<h2>DATA SELECTORS</h2>
<h4>xrot:</h4>
<p>Selects the first or second set of 8 values to be used from both buffers A and B :</p>
<table class="doxtable">
<tr>
<th>xrot value </th><th>selection in xbufa </th><th>selection in xbufb </th></tr>
<tr>
<td>0x0 </td><td>coefficients 0 to 7 </td><td>coefficients 0 to 7 </td></tr>
<tr>
<td>0x1 </td><td>coefficients 8 to 15</td><td>coefficients 0 to 7 </td></tr>
<tr>
<td>0x2 </td><td>coefficients 0 to 7 </td><td>coefficients 8 to 15 </td></tr>
<tr>
<td>0x3 </td><td>coefficients 8 to 15</td><td>coefficients 8 to 15 </td></tr>
</table>
<p>Examples :</p>
<p>If you have updated previously updated xbufa with upd_w(0) (values 0 to 7 have been replaced), and xbufb with upd_w(1) (values 8 to 15), you would chose xrot=0x2</p>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td>xbufa(0)</td><td>xbufa(1)</td><td>xbufa(2)</td><td>xbufa(3)</td><td>xbufa(4)</td><td>xbufa(5)</td><td>xbufa(6)</td><td>xbufa(7)</td><td>xbufb(8)</td><td>xbufb(9)</td><td>xbufb(10)</td><td>xbufb(11)</td><td>xbufb(12)</td><td>xbufb(13)</td><td>xbufb(14)</td><td>xbufb(15) </td></tr>
</table>
<p>If you have xrot=0x1 :</p>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td>xbufa(8)</td><td>xbufa(9)</td><td>xbufa(10)</td><td>xbufa(11)</td><td>xbufa(12)</td><td>xbufa(13)</td><td>xbufa(14)</td><td>xbufa(15)</td><td>xbufb(0)</td><td>xbufb(1)</td><td>xbufb(2) </td><td>xbufb(3) </td><td>xbufb(4) </td><td>xbufb(5) </td><td>xbufb(6) </td><td>xbufb(7) </td></tr>
</table>
<p>It is standard practice to use only upd_w(0) and leave xrot at 0x0 unless your application can benefit from this option.</p>
<h4>zstart:</h4>
<p>Selects which of the 8 scaling factor values in zbuf will be used for the multiply operation, simply varies between 0x0 and 0x7</p>
<h4>rev_xstart:</h4>
<p>The 4 LSB select the starting point within the 16 CP values, since only 8 input CP values will be used for a mac operation.</p>
<p>Once the starting point is selected, the remaining MSB of rev_xstart determines which direction the operation will take place. The use of this flag improves the memory efficiency for conjugate-symmetric CPs since only half of the CP coefficients need to be present in the memory.</p>
<p>Example :</p>
<p>If the 4 bits are set to 0x7, CP(7) will be selected as the starting point. Then the MSB of rev_xstart will influence the way the operation works :</p>
<ul>
<li>Set to 0 : CP(7) up to CP(14) will be used</li>
</ul>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>start </td><td>---&mdash;&gt;</td><td>---&mdash;&gt;</td><td>----&mdash;&gt;</td><td>----&mdash;&gt;</td><td>----&mdash;&gt;</td><td>----&mdash;&gt;</td><td>end </td><td></td></tr>
</table>
<ul>
<li>Set to 1 : The complex conjugates of CP(7) down to CP(0) will be used</li>
</ul>
<table class="doxtable">
<tr>
<th>CP(0) </th><th>CP(1) </th><th>CP(2) </th><th>CP(3) </th><th>CP(4) </th><th>CP(5) </th><th>CP(6) </th><th>CP(7) </th><th>CP(8) </th><th>CP(9) </th><th>CP(10) </th><th>CP(11) </th><th>CP(12) </th><th>CP(13) </th><th>CP(14) </th><th>CP(15) </th></tr>
<tr>
<td>end </td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>&lt;---&mdash;</td><td>start </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p><br/>
<br/>
</p>
<h2>FULL EXAMPLES</h2>
<p>For both examples, the CP values will have been loaded into the lower half of xbufa and xbufb before they are passed to the function, and xrot can be left at 0x0.</p>
<p>The mac variant of this intrinsic is similar, but accumulates into acc instead of assignment.</p>
<h4>Example 1 (MSB of rev_xstart=0)</h4>
<p>Command : mul8_cfr(xbufa, xbufb, 0x04, 0x0, zbuf, 0x2)</p>
<ul>
<li>zstart is at 0x2, the third scaling factor value of zbuf will be used.</li>
</ul>
<ul>
<li>The 4 LSB of rev_xstart are set to 0x4, the starting point within the 16 available CP values will be 4.</li>
</ul>
<p>Resulting operation :</p>
<div class="fragment"><div class="line">acc(0) = zbuf(2) * CP(4)</div>
<div class="line">acc(1) = zbuf(2) * CP(5)</div>
<div class="line">acc(2) = zbuf(2) * CP(6)</div>
<div class="line">acc(3) = zbuf(2) * CP(7)</div>
<div class="line">acc(4) = zbuf(2) * CP(8)</div>
<div class="line">acc(5) = zbuf(2) * CP(9)</div>
<div class="line">acc(6) = zbuf(2) * CP(10)</div>
<div class="line">acc(7) = zbuf(2) * CP(11)</div>
</div><!-- fragment --><h4>Example 2 (MSB of rev_xstart=1)</h4>
<p>Command : mul8_cfr(xbufa, xbufb, 0x09, 0x0, zbuf, 0x3)</p>
<ul>
<li>zstart is at 0x3, the fourth scaling factor value of zbuf will be used.</li>
</ul>
<ul>
<li>The 4 LSB of rev_xstart are set to 0x9, the starting point within the 16 available CP values will be 9.</li>
</ul>
<ul>
<li>The MSB of rev_xstart is set to 1, so the CP values will go from CP(9) down to CP(2) and use the complex conjugates</li>
</ul>
<p>Resulting operation :</p>
<div class="fragment"><div class="line">acc(0) = zbuf(3) * conj(CP(9))</div>
<div class="line">acc(1) = zbuf(3) * conj(CP(8))</div>
<div class="line">acc(2) = zbuf(3) * conj(CP(7))</div>
<div class="line">acc(3) = zbuf(3) * conj(CP(6))</div>
<div class="line">acc(4) = zbuf(3) * conj(CP(5))</div>
<div class="line">acc(5) = zbuf(3) * conj(CP(4))</div>
<div class="line">acc(6) = zbuf(3) * conj(CP(3))</div>
<div class="line">acc(7) = zbuf(3) * conj(CP(2))</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaaf7c4c00854e6afb9f3871587a9c8448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>d1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intrinsic used to split the 32 bit input data into two resulting variables at the n-th bit. </p>
<p>The split separates the 32 bits of into index info to update CP LUT pointers and intrinsic prepares the magnitude values for further processing in the DPD. The parameters are the following:</p>
<h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Type </th><th>Comments</th></tr>
<tr>
<td>a </td><td>int </td><td>Input data as a 32bit signed integer. </td></tr>
<tr>
<td>n </td><td>unsigned </td><td>Number of LSBs that shall end up in d1. This must be a compile-time constant </td></tr>
<tr>
<td>d0 </td><td>int&amp; </td><td>Output variable that will contain bits n to 31 of the input. Intended as an index and is a signed number (sign extended). </td></tr>
<tr>
<td>d1 </td><td>unsigned&amp;</td><td>Output variable that will contain bits 0 to n-1 of the input. </td></tr>
</table>
<h4>Example :</h4>
<p>Command : split(data, 6, out1, out2)</p>
<p>We will imagine that data = 0x44FA, which gives the following operation :</p>
<p>data = 0100 0100 11|11 1010 (split after the n-th LSB, which is 6 in this example)</p>
<p>This gives :</p>
<p>out0 = 0000 0001 0001 0011 out1 = 0000 0000 0011 1010</p>
<h2>Crest Factor Reduction Application</h2>
<p>For Peak Cancellation CFR, one of the two input streams into an AI Engine is dedicated to communicate 32 bit metadata samples. The 27 MSB of a metadata sample are used for Cancellation Pulse (CP) LUT indexing, and the 5 LSB provide configuration information for the subsequent mul or mac operation.</p>
<p>See below for more information on how 5 LSB are used for configuring mul and mac operation:</p>
<p><a class="el" href="group__intr__cfr.html#ga0e571d53cff038bd43f2595bc7e87066">v8cacc48 mul8_cfr(v16cint16 xbufa,v16cint16 xbufb, int rev_xstart, int xrot, v8cint16 zbuf, int zstart)</a></p>
<p><a class="el" href="group__intr__cfr.html#ga7bb7cdff05030ee2a6c217d43eb43c34">v8cacc48 mac8_cfr(v8cacc48 acc, v16cint16 xbufa,v16cint16 xbufb, int rev_xstart, int xrot, v8cint16 zbuf, int zstart)</a></p>
<h2>Digital Pre-Distortion Appliction</h2>
<p>The split intrinsic used in DPD applications is slightly different and has an additional parameter:</p>
<p><a class="el" href="group__intr__dpd.html#split_dpd">void split(int mag, int frac_bits, int lut_width, int&amp; idx, unsigned&amp; frac)</a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2020 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
