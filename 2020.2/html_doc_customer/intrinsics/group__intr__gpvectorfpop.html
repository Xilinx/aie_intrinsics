<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: Float</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p15.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intr__gpvectorfpop.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Float<div class="ingroups"><a class="el" href="group__intr__gpvectorop__mul__adv.html">Advanced</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p><a class="anchor" id="fpops_explained"></a> Advanced Float Vector Operations. This page contains the fully configurable fpmac_conf and some convenient wrappers to it. The lane selection scheme is explained after each intrinsic definition.</p>
<p>Some of this floating point operations can generate exceptions, for more information you can go <a class="el" href="group__intr__gpvectorop__mode__status.html#floating_point_flags">here</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Fully configurable multiply-accumulate functions</h2></td></tr>
<tr class="memitem:ga0923b0208495c392d1755842dce66d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0923b0208495c392d1755842dce66d47">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga0923b0208495c392d1755842dce66d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga0923b0208495c392d1755842dce66d47"></a><br/></td></tr>
<tr class="separator:ga0923b0208495c392d1755842dce66d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf83ced652673021b09d77a339a2e74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacf83ced652673021b09d77a339a2e74f">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gacf83ced652673021b09d77a339a2e74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gacf83ced652673021b09d77a339a2e74f"></a><br/></td></tr>
<tr class="separator:gacf83ced652673021b09d77a339a2e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389a58e20b6742e9eeea5c1f84d2d821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga389a58e20b6742e9eeea5c1f84d2d821">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga389a58e20b6742e9eeea5c1f84d2d821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga389a58e20b6742e9eeea5c1f84d2d821"></a><br/></td></tr>
<tr class="separator:ga389a58e20b6742e9eeea5c1f84d2d821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6128cbe449b62af09b1255bc20f206a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga6128cbe449b62af09b1255bc20f206a8">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga6128cbe449b62af09b1255bc20f206a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga6128cbe449b62af09b1255bc20f206a8"></a><br/></td></tr>
<tr class="separator:ga6128cbe449b62af09b1255bc20f206a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e5ee227fe6c0dcb06e313d97648844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga34e5ee227fe6c0dcb06e313d97648844">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga34e5ee227fe6c0dcb06e313d97648844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga34e5ee227fe6c0dcb06e313d97648844"></a><br/></td></tr>
<tr class="separator:ga34e5ee227fe6c0dcb06e313d97648844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bcd9c467a30cb5447174c847d68eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga94bcd9c467a30cb5447174c847d68eeb">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga94bcd9c467a30cb5447174c847d68eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga94bcd9c467a30cb5447174c847d68eeb"></a><br/></td></tr>
<tr class="separator:ga94bcd9c467a30cb5447174c847d68eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9140d5d5bcf84ee494fc35dd1c4ca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaeb9140d5d5bcf84ee494fc35dd1c4ca1">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:gaeb9140d5d5bcf84ee494fc35dd1c4ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gaeb9140d5d5bcf84ee494fc35dd1c4ca1"></a><br/></td></tr>
<tr class="separator:gaeb9140d5d5bcf84ee494fc35dd1c4ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga798f830b91f7a141a41998eeadc705b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga798f830b91f7a141a41998eeadc705b3">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga798f830b91f7a141a41998eeadc705b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga798f830b91f7a141a41998eeadc705b3"></a><br/></td></tr>
<tr class="separator:ga798f830b91f7a141a41998eeadc705b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82a218e4dd42b2179f3444359601b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab82a218e4dd42b2179f3444359601b3f">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab82a218e4dd42b2179f3444359601b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gab82a218e4dd42b2179f3444359601b3f"></a><br/></td></tr>
<tr class="separator:gab82a218e4dd42b2179f3444359601b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936851c57b3cc0add42bdd22d91c44b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga936851c57b3cc0add42bdd22d91c44b6">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga936851c57b3cc0add42bdd22d91c44b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga936851c57b3cc0add42bdd22d91c44b6"></a><br/></td></tr>
<tr class="separator:ga936851c57b3cc0add42bdd22d91c44b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9266dd0cd9a703f4cc0256e59b61463c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9266dd0cd9a703f4cc0256e59b61463c">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga9266dd0cd9a703f4cc0256e59b61463c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga9266dd0cd9a703f4cc0256e59b61463c"></a><br/></td></tr>
<tr class="separator:ga9266dd0cd9a703f4cc0256e59b61463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e724a7a2ce34cbd3a6534c75f7f9e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9e724a7a2ce34cbd3a6534c75f7f9e79">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga9e724a7a2ce34cbd3a6534c75f7f9e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga9e724a7a2ce34cbd3a6534c75f7f9e79"></a><br/></td></tr>
<tr class="separator:ga9e724a7a2ce34cbd3a6534c75f7f9e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529d610c0293b24ed4b51b7a76e3b883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga529d610c0293b24ed4b51b7a76e3b883">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga529d610c0293b24ed4b51b7a76e3b883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga529d610c0293b24ed4b51b7a76e3b883"></a><br/></td></tr>
<tr class="separator:ga529d610c0293b24ed4b51b7a76e3b883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6e690509cf12aba9d1bda9bd8d226d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0e6e690509cf12aba9d1bda9bd8d226d">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga0e6e690509cf12aba9d1bda9bd8d226d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga0e6e690509cf12aba9d1bda9bd8d226d"></a><br/></td></tr>
<tr class="separator:ga0e6e690509cf12aba9d1bda9bd8d226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c105388d2aeb00939deb815546d3fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab0c105388d2aeb00939deb815546d3fe">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:gab0c105388d2aeb00939deb815546d3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gab0c105388d2aeb00939deb815546d3fe"></a><br/></td></tr>
<tr class="separator:gab0c105388d2aeb00939deb815546d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0aa1196dd4e52e44d851c46fd4d210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4b0aa1196dd4e52e44d851c46fd4d210">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga4b0aa1196dd4e52e44d851c46fd4d210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga4b0aa1196dd4e52e44d851c46fd4d210"></a><br/></td></tr>
<tr class="separator:ga4b0aa1196dd4e52e44d851c46fd4d210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e9e9fcd47151968c33a9374ca4c467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga20e9e9fcd47151968c33a9374ca4c467">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga20e9e9fcd47151968c33a9374ca4c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga20e9e9fcd47151968c33a9374ca4c467"></a><br/></td></tr>
<tr class="separator:ga20e9e9fcd47151968c33a9374ca4c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea8f1855b08cea6cf96a26dd1376751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacea8f1855b08cea6cf96a26dd1376751">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gacea8f1855b08cea6cf96a26dd1376751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gacea8f1855b08cea6cf96a26dd1376751"></a><br/></td></tr>
<tr class="separator:gacea8f1855b08cea6cf96a26dd1376751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d6e2a16d63a97464038d1e8fc70eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga30d6e2a16d63a97464038d1e8fc70eeb">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga30d6e2a16d63a97464038d1e8fc70eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga30d6e2a16d63a97464038d1e8fc70eeb"></a><br/></td></tr>
<tr class="separator:ga30d6e2a16d63a97464038d1e8fc70eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7d35cdb3c698d342aa625827c085a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1b7d35cdb3c698d342aa625827c085a7">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga1b7d35cdb3c698d342aa625827c085a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga1b7d35cdb3c698d342aa625827c085a7"></a><br/></td></tr>
<tr class="separator:ga1b7d35cdb3c698d342aa625827c085a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134dd2770e84c1ec768de42e1c394f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga134dd2770e84c1ec768de42e1c394f4d">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga134dd2770e84c1ec768de42e1c394f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga134dd2770e84c1ec768de42e1c394f4d"></a><br/></td></tr>
<tr class="separator:ga134dd2770e84c1ec768de42e1c394f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0d44cb23159974ff487ae1adcc6097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8e0d44cb23159974ff487ae1adcc6097">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga8e0d44cb23159974ff487ae1adcc6097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga8e0d44cb23159974ff487ae1adcc6097"></a><br/></td></tr>
<tr class="separator:ga8e0d44cb23159974ff487ae1adcc6097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2199bc6d5389a86e31843d5589d4cd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2199bc6d5389a86e31843d5589d4cd78">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga2199bc6d5389a86e31843d5589d4cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga2199bc6d5389a86e31843d5589d4cd78"></a><br/></td></tr>
<tr class="separator:ga2199bc6d5389a86e31843d5589d4cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98234f63c4eaf04e9b1ab399acc7fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab98234f63c4eaf04e9b1ab399acc7fce">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:gab98234f63c4eaf04e9b1ab399acc7fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gab98234f63c4eaf04e9b1ab399acc7fce"></a><br/></td></tr>
<tr class="separator:gab98234f63c4eaf04e9b1ab399acc7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9d4d3e1f4697909c09910608736ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gacd9d4d3e1f4697909c09910608736ae6">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gacd9d4d3e1f4697909c09910608736ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gacd9d4d3e1f4697909c09910608736ae6"></a><br/></td></tr>
<tr class="separator:gacd9d4d3e1f4697909c09910608736ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd3a3c6e6d74bd75e064d6f2f1175ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3bd3a3c6e6d74bd75e064d6f2f1175ce">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga3bd3a3c6e6d74bd75e064d6f2f1175ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga3bd3a3c6e6d74bd75e064d6f2f1175ce"></a><br/></td></tr>
<tr class="separator:ga3bd3a3c6e6d74bd75e064d6f2f1175ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga869745c907faf2171d869ecdebba676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga869745c907faf2171d869ecdebba676e">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga869745c907faf2171d869ecdebba676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga869745c907faf2171d869ecdebba676e"></a><br/></td></tr>
<tr class="separator:ga869745c907faf2171d869ecdebba676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8c325c8b8d3c1dcd0f5c7c7450d4bf50">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"></a><br/></td></tr>
<tr class="separator:ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4b185fd15f9215581a3ca6696215d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1a4b185fd15f9215581a3ca6696215d0">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga1a4b185fd15f9215581a3ca6696215d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga1a4b185fd15f9215581a3ca6696215d0"></a><br/></td></tr>
<tr class="separator:ga1a4b185fd15f9215581a3ca6696215d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e090062933d16c1753285763a50e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga62e090062933d16c1753285763a50e02">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga62e090062933d16c1753285763a50e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga62e090062933d16c1753285763a50e02"></a><br/></td></tr>
<tr class="separator:ga62e090062933d16c1753285763a50e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c8c929e6f022ef735e3ca22051814d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga41c8c929e6f022ef735e3ca22051814d">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga41c8c929e6f022ef735e3ca22051814d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga41c8c929e6f022ef735e3ca22051814d"></a><br/></td></tr>
<tr class="separator:ga41c8c929e6f022ef735e3ca22051814d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665272a82dd053ce671ae28db33ba7bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga665272a82dd053ce671ae28db33ba7bc">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga665272a82dd053ce671ae28db33ba7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga665272a82dd053ce671ae28db33ba7bc"></a><br/></td></tr>
<tr class="separator:ga665272a82dd053ce671ae28db33ba7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac410a63472d6fe739d5f141e14f3fe2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac410a63472d6fe739d5f141e14f3fe2d">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gac410a63472d6fe739d5f141e14f3fe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gac410a63472d6fe739d5f141e14f3fe2d"></a><br/></td></tr>
<tr class="separator:gac410a63472d6fe739d5f141e14f3fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga270120a0ebc86049420ed15884a760d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga270120a0ebc86049420ed15884a760d9">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga270120a0ebc86049420ed15884a760d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga270120a0ebc86049420ed15884a760d9"></a><br/></td></tr>
<tr class="separator:ga270120a0ebc86049420ed15884a760d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7f9e9dbc0df75658a1c2fbfb30873b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga7c7f9e9dbc0df75658a1c2fbfb30873b">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga7c7f9e9dbc0df75658a1c2fbfb30873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga7c7f9e9dbc0df75658a1c2fbfb30873b"></a><br/></td></tr>
<tr class="separator:ga7c7f9e9dbc0df75658a1c2fbfb30873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ab721fa840816d803a74d4c8960fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga84ab721fa840816d803a74d4c8960fa1">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga84ab721fa840816d803a74d4c8960fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga84ab721fa840816d803a74d4c8960fa1"></a><br/></td></tr>
<tr class="separator:ga84ab721fa840816d803a74d4c8960fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab406a9c168d3c26062f9cf0f36697d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab406a9c168d3c26062f9cf0f36697d93">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab406a9c168d3c26062f9cf0f36697d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gab406a9c168d3c26062f9cf0f36697d93"></a><br/></td></tr>
<tr class="separator:gab406a9c168d3c26062f9cf0f36697d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f3486a407913c4d7fbacd1f81041e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga22f3486a407913c4d7fbacd1f81041e0">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga22f3486a407913c4d7fbacd1f81041e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga22f3486a407913c4d7fbacd1f81041e0"></a><br/></td></tr>
<tr class="separator:ga22f3486a407913c4d7fbacd1f81041e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9d5eeac4e068b41d99593b412571ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga9e9d5eeac4e068b41d99593b412571ed">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga9e9d5eeac4e068b41d99593b412571ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga9e9d5eeac4e068b41d99593b412571ed"></a><br/></td></tr>
<tr class="separator:ga9e9d5eeac4e068b41d99593b412571ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7827d0fe97053cf7bbaaabeba3bf529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaf7827d0fe97053cf7bbaaabeba3bf529">fpmac_conf</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:gaf7827d0fe97053cf7bbaaabeba3bf529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gaf7827d0fe97053cf7bbaaabeba3bf529"></a><br/></td></tr>
<tr class="separator:gaf7827d0fe97053cf7bbaaabeba3bf529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1099b4410e8f84c7af1518c740ab437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad1099b4410e8f84c7af1518c740ab437">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gad1099b4410e8f84c7af1518c740ab437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gad1099b4410e8f84c7af1518c740ab437"></a><br/></td></tr>
<tr class="separator:gad1099b4410e8f84c7af1518c740ab437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d5d98e6bb51fa0cf8e8b1492653a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga17d5d98e6bb51fa0cf8e8b1492653a7d">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:ga17d5d98e6bb51fa0cf8e8b1492653a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga17d5d98e6bb51fa0cf8e8b1492653a7d"></a><br/></td></tr>
<tr class="separator:ga17d5d98e6bb51fa0cf8e8b1492653a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf5c992722b320d02e3d1f0a918de70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafbf5c992722b320d02e3d1f0a918de70">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:gafbf5c992722b320d02e3d1f0a918de70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gafbf5c992722b320d02e3d1f0a918de70"></a><br/></td></tr>
<tr class="separator:gafbf5c992722b320d02e3d1f0a918de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2700e0f68cad3751c0670b4799e674b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2700e0f68cad3751c0670b4799e674b4">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga2700e0f68cad3751c0670b4799e674b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga2700e0f68cad3751c0670b4799e674b4"></a><br/></td></tr>
<tr class="separator:ga2700e0f68cad3751c0670b4799e674b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28a10c8a3de173bb0a390d76ad09e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab28a10c8a3de173bb0a390d76ad09e5a">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gab28a10c8a3de173bb0a390d76ad09e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gab28a10c8a3de173bb0a390d76ad09e5a"></a><br/></td></tr>
<tr class="separator:gab28a10c8a3de173bb0a390d76ad09e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae715d9690aac3f88784ca2414b3b74f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae715d9690aac3f88784ca2414b3b74f7">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode)</td></tr>
<tr class="memdesc:gae715d9690aac3f88784ca2414b3b74f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gae715d9690aac3f88784ca2414b3b74f7"></a><br/></td></tr>
<tr class="separator:gae715d9690aac3f88784ca2414b3b74f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f039649eb3e694153aae0640a4081da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga2f039649eb3e694153aae0640a4081da">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:ga2f039649eb3e694153aae0640a4081da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#ga2f039649eb3e694153aae0640a4081da"></a><br/></td></tr>
<tr class="separator:ga2f039649eb3e694153aae0640a4081da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58850c0179b60e60f76ecf55308d979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gad58850c0179b60e60f76ecf55308d979">fpmul_conf</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, int zstart, unsigned int zoffs, bool ones, bool abs, unsigned int addmode, unsigned int addmask, unsigned int cmpmode, unsigned int &amp;cmp)</td></tr>
<tr class="memdesc:gad58850c0179b60e60f76ecf55308d979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully configurable real multiply-accumulate for single precision floating point vectors.  <a href="#gad58850c0179b60e60f76ecf55308d979"></a><br/></td></tr>
<tr class="separator:gad58850c0179b60e60f76ecf55308d979"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Multiply-accumulate functions</h2></td></tr>
<tr class="memitem:ga34e5b7f6e2c9d3c54e020f104404fa4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga34e5b7f6e2c9d3c54e020f104404fa4e">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga34e5b7f6e2c9d3c54e020f104404fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for single precision real floating point vectors.  <a href="#ga34e5b7f6e2c9d3c54e020f104404fa4e"></a><br/></td></tr>
<tr class="separator:ga34e5b7f6e2c9d3c54e020f104404fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa737318f7d89f5ab0240fc77efa8ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5aa737318f7d89f5ab0240fc77efa8ca">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5aa737318f7d89f5ab0240fc77efa8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for single precision real floating point vectors.  <a href="#ga5aa737318f7d89f5ab0240fc77efa8ca"></a><br/></td></tr>
<tr class="separator:ga5aa737318f7d89f5ab0240fc77efa8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb63fe3d65e964f38a3c13e979cd9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaddb63fe3d65e964f38a3c13e979cd9fc">fpmac_abs</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaddb63fe3d65e964f38a3c13e979cd9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real floating point vectors.  <a href="#gaddb63fe3d65e964f38a3c13e979cd9fc"></a><br/></td></tr>
<tr class="separator:gaddb63fe3d65e964f38a3c13e979cd9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4a790d518eeee5cd395ddbf43e40b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabf4a790d518eeee5cd395ddbf43e40b7">fpmac_abs</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabf4a790d518eeee5cd395ddbf43e40b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and accumulate for single precision real floating point vectors.  <a href="#gabf4a790d518eeee5cd395ddbf43e40b7"></a><br/></td></tr>
<tr class="separator:gabf4a790d518eeee5cd395ddbf43e40b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447ce0ae232b8df6fe124ebadbc7b5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga447ce0ae232b8df6fe124ebadbc7b5f3">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga447ce0ae232b8df6fe124ebadbc7b5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for complex times real single precision floating point vectors.  <a href="#ga447ce0ae232b8df6fe124ebadbc7b5f3"></a><br/></td></tr>
<tr class="separator:ga447ce0ae232b8df6fe124ebadbc7b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78806c429af07ed08f3e85397ce4aed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab78806c429af07ed08f3e85397ce4aed">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab78806c429af07ed08f3e85397ce4aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for complex times real single precision floating point vectors.  <a href="#gab78806c429af07ed08f3e85397ce4aed"></a><br/></td></tr>
<tr class="separator:gab78806c429af07ed08f3e85397ce4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a9599d9840ab31ab0df46a5926d088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac1a9599d9840ab31ab0df46a5926d088">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac1a9599d9840ab31ab0df46a5926d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for real times complex single precision floating point vectors.  <a href="#gac1a9599d9840ab31ab0df46a5926d088"></a><br/></td></tr>
<tr class="separator:gac1a9599d9840ab31ab0df46a5926d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a9e43a73c1816ce9a54413226e1770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga59a9e43a73c1816ce9a54413226e1770">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga59a9e43a73c1816ce9a54413226e1770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for real times complex single precision floating point vectors.  <a href="#ga59a9e43a73c1816ce9a54413226e1770"></a><br/></td></tr>
<tr class="separator:ga59a9e43a73c1816ce9a54413226e1770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6f5aa4a861dfa2e84f4ba264428e54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gafe6f5aa4a861dfa2e84f4ba264428e54">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gafe6f5aa4a861dfa2e84f4ba264428e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for complex single precision floating point vectors.  <a href="#gafe6f5aa4a861dfa2e84f4ba264428e54"></a><br/></td></tr>
<tr class="separator:gafe6f5aa4a861dfa2e84f4ba264428e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89424178e1749cea4e414fe07325c15d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga89424178e1749cea4e414fe07325c15d">fpmac</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga89424178e1749cea4e414fe07325c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-accumulate for complex single precision floating point vectors.  <a href="#ga89424178e1749cea4e414fe07325c15d"></a><br/></td></tr>
<tr class="separator:ga89424178e1749cea4e414fe07325c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Multiply-subtract functions</h2></td></tr>
<tr class="memitem:ga4ea70bc03ebc2fd4ff397e095a2528b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4ea70bc03ebc2fd4ff397e095a2528b0">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4ea70bc03ebc2fd4ff397e095a2528b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for single precision real floating point vectors.  <a href="#ga4ea70bc03ebc2fd4ff397e095a2528b0"></a><br/></td></tr>
<tr class="separator:ga4ea70bc03ebc2fd4ff397e095a2528b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc06cd24132d7178bcee30ba717dbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaffc06cd24132d7178bcee30ba717dbb0">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaffc06cd24132d7178bcee30ba717dbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for single precision real floating point vectors.  <a href="#gaffc06cd24132d7178bcee30ba717dbb0"></a><br/></td></tr>
<tr class="separator:gaffc06cd24132d7178bcee30ba717dbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd25f74812fbb2f218fe18fb785afafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gabd25f74812fbb2f218fe18fb785afafb">fpmsc_abs</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gabd25f74812fbb2f218fe18fb785afafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real floating point vectors.  <a href="#gabd25f74812fbb2f218fe18fb785afafb"></a><br/></td></tr>
<tr class="separator:gabd25f74812fbb2f218fe18fb785afafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1834f7ab3e7ce47ecba4a1c202926223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1834f7ab3e7ce47ecba4a1c202926223">fpmsc_abs</a> (<a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1834f7ab3e7ce47ecba4a1c202926223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and subtract for single precision real floating point vectors.  <a href="#ga1834f7ab3e7ce47ecba4a1c202926223"></a><br/></td></tr>
<tr class="separator:ga1834f7ab3e7ce47ecba4a1c202926223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5580c5ce689b602cfb1fb8ab936f7868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga5580c5ce689b602cfb1fb8ab936f7868">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga5580c5ce689b602cfb1fb8ab936f7868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for complex times real single precision floating point vectors.  <a href="#ga5580c5ce689b602cfb1fb8ab936f7868"></a><br/></td></tr>
<tr class="separator:ga5580c5ce689b602cfb1fb8ab936f7868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b8559a1f5d33420744d544afda4b27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga91b8559a1f5d33420744d544afda4b27">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga91b8559a1f5d33420744d544afda4b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for complex times real single precision floating point vectors.  <a href="#ga91b8559a1f5d33420744d544afda4b27"></a><br/></td></tr>
<tr class="separator:ga91b8559a1f5d33420744d544afda4b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1284de74f1c922f34f367d934c911703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1284de74f1c922f34f367d934c911703">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1284de74f1c922f34f367d934c911703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for real times complex single precision floating point vectors.  <a href="#ga1284de74f1c922f34f367d934c911703"></a><br/></td></tr>
<tr class="separator:ga1284de74f1c922f34f367d934c911703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30263502d587d2642577bdd0b8f572a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab30263502d587d2642577bdd0b8f572a">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab30263502d587d2642577bdd0b8f572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for real times complex single precision floating point vectors.  <a href="#gab30263502d587d2642577bdd0b8f572a"></a><br/></td></tr>
<tr class="separator:gab30263502d587d2642577bdd0b8f572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9d17eae5bea8a3783d6f2f18c1ba20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gada9d17eae5bea8a3783d6f2f18c1ba20">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gada9d17eae5bea8a3783d6f2f18c1ba20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for complex single precision floating point vectors.  <a href="#gada9d17eae5bea8a3783d6f2f18c1ba20"></a><br/></td></tr>
<tr class="separator:gada9d17eae5bea8a3783d6f2f18c1ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b25bc373baf18db70e4ae639b913565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga1b25bc373baf18db70e4ae639b913565">fpmsc</a> (<a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> acc, <a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga1b25bc373baf18db70e4ae639b913565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-subtract for complex single precision floating point vectors.  <a href="#ga1b25bc373baf18db70e4ae639b913565"></a><br/></td></tr>
<tr class="separator:ga1b25bc373baf18db70e4ae639b913565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Multiplication functions</h2></td></tr>
<tr class="memitem:gaa503b32381bbe29d31f1736abb32e0b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa503b32381bbe29d31f1736abb32e0b6">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa503b32381bbe29d31f1736abb32e0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for single precision real floating point vectors.  <a href="#gaa503b32381bbe29d31f1736abb32e0b6"></a><br/></td></tr>
<tr class="separator:gaa503b32381bbe29d31f1736abb32e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835915c48a204091cac8d24ad5f5fb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga835915c48a204091cac8d24ad5f5fb7d">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga835915c48a204091cac8d24ad5f5fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for single precision real floating point vectors.  <a href="#ga835915c48a204091cac8d24ad5f5fb7d"></a><br/></td></tr>
<tr class="separator:ga835915c48a204091cac8d24ad5f5fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665ec0814aaf7cdac43bd3e5068e3e8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga665ec0814aaf7cdac43bd3e5068e3e8e">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga665ec0814aaf7cdac43bd3e5068e3e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for complex times real single precision floating point vectors.  <a href="#ga665ec0814aaf7cdac43bd3e5068e3e8e"></a><br/></td></tr>
<tr class="separator:ga665ec0814aaf7cdac43bd3e5068e3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0623cbfefba2f406c172ebf78cc8c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gae0623cbfefba2f406c172ebf78cc8c3a">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gae0623cbfefba2f406c172ebf78cc8c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for complex times real single precision floating point vectors.  <a href="#gae0623cbfefba2f406c172ebf78cc8c3a"></a><br/></td></tr>
<tr class="separator:gae0623cbfefba2f406c172ebf78cc8c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79fa774a15884fda26cf5ec390db2d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga79fa774a15884fda26cf5ec390db2d31">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga79fa774a15884fda26cf5ec390db2d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for real times complex single precision floating point vectors.  <a href="#ga79fa774a15884fda26cf5ec390db2d31"></a><br/></td></tr>
<tr class="separator:ga79fa774a15884fda26cf5ec390db2d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff7b0cbd53c325912b0496294322635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga4ff7b0cbd53c325912b0496294322635">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga4ff7b0cbd53c325912b0496294322635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for real times complex single precision floating point vectors.  <a href="#ga4ff7b0cbd53c325912b0496294322635"></a><br/></td></tr>
<tr class="separator:ga4ff7b0cbd53c325912b0496294322635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91f1f8d8fcf8d00446ecf799b9883800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga91f1f8d8fcf8d00446ecf799b9883800">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga91f1f8d8fcf8d00446ecf799b9883800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for complex single precision floating point vectors.  <a href="#ga91f1f8d8fcf8d00446ecf799b9883800"></a><br/></td></tr>
<tr class="separator:ga91f1f8d8fcf8d00446ecf799b9883800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b696862928c431e495ef6e5113c9926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga8b696862928c431e495ef6e5113c9926">fpmul</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga8b696862928c431e495ef6e5113c9926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication for complex single precision floating point vectors.  <a href="#ga8b696862928c431e495ef6e5113c9926"></a><br/></td></tr>
<tr class="separator:ga8b696862928c431e495ef6e5113c9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02d3ed06bfd2b655c8c4c1be66e4c08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gac02d3ed06bfd2b655c8c4c1be66e4c08">fpabs_mul</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gac02d3ed06bfd2b655c8c4c1be66e4c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real floating point vectors.  <a href="#gac02d3ed06bfd2b655c8c4c1be66e4c08"></a><br/></td></tr>
<tr class="separator:gac02d3ed06bfd2b655c8c4c1be66e4c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0facea1eeaf1520c4c167420a49a2431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0facea1eeaf1520c4c167420a49a2431">fpabs_mul</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0facea1eeaf1520c4c167420a49a2431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and take absolute value for single precision real floating point vectors.  <a href="#ga0facea1eeaf1520c4c167420a49a2431"></a><br/></td></tr>
<tr class="separator:ga0facea1eeaf1520c4c167420a49a2431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0218ee177f14aa89eebe5aa3abe596bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga0218ee177f14aa89eebe5aa3abe596bf">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga0218ee177f14aa89eebe5aa3abe596bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for single precision real floating point vectors.  <a href="#ga0218ee177f14aa89eebe5aa3abe596bf"></a><br/></td></tr>
<tr class="separator:ga0218ee177f14aa89eebe5aa3abe596bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3238d3340096b7a9711d6f94ff4a3c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga3238d3340096b7a9711d6f94ff4a3c5c">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga3238d3340096b7a9711d6f94ff4a3c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for single precision real floating point vectors.  <a href="#ga3238d3340096b7a9711d6f94ff4a3c5c"></a><br/></td></tr>
<tr class="separator:ga3238d3340096b7a9711d6f94ff4a3c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36585639e2836b5cfacaa4054e7f5ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga36585639e2836b5cfacaa4054e7f5ac0">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga36585639e2836b5cfacaa4054e7f5ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for complex times real single precision floating point vectors.  <a href="#ga36585639e2836b5cfacaa4054e7f5ac0"></a><br/></td></tr>
<tr class="separator:ga36585639e2836b5cfacaa4054e7f5ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8e2ad8957c319518044c6d73d12b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaff8e2ad8957c319518044c6d73d12b3e">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaff8e2ad8957c319518044c6d73d12b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for complex times real single precision floating point vectors.  <a href="#gaff8e2ad8957c319518044c6d73d12b3e"></a><br/></td></tr>
<tr class="separator:gaff8e2ad8957c319518044c6d73d12b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae832f48fbe247e2fc5d5a944210e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gadae832f48fbe247e2fc5d5a944210e21">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gadae832f48fbe247e2fc5d5a944210e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for real times complex single precision floating point vectors.  <a href="#gadae832f48fbe247e2fc5d5a944210e21"></a><br/></td></tr>
<tr class="separator:gadae832f48fbe247e2fc5d5a944210e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e49278ec57725b4e7da150b9074cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaa3e49278ec57725b4e7da150b9074cf8">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaa3e49278ec57725b4e7da150b9074cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for real times complex single precision floating point vectors.  <a href="#gaa3e49278ec57725b4e7da150b9074cf8"></a><br/></td></tr>
<tr class="separator:gaa3e49278ec57725b4e7da150b9074cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13108a5139900aad2cbb55802cdcc9f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga13108a5139900aad2cbb55802cdcc9f5">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga13108a5139900aad2cbb55802cdcc9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for complex single precision floating point vectors.  <a href="#ga13108a5139900aad2cbb55802cdcc9f5"></a><br/></td></tr>
<tr class="separator:ga13108a5139900aad2cbb55802cdcc9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ccc67806d74d6382b759e45cbfbd4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#ga54ccc67806d74d6382b759e45cbfbd4f">fpneg_mul</a> (<a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:ga54ccc67806d74d6382b759e45cbfbd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-negate for complex single precision floating point vectors.  <a href="#ga54ccc67806d74d6382b759e45cbfbd4f"></a><br/></td></tr>
<tr class="separator:ga54ccc67806d74d6382b759e45cbfbd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca258d5056d7d097365ed2ab83a92ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gaca258d5056d7d097365ed2ab83a92ad9">fpneg_abs_mul</a> (<a class="el" href="group__dt__fpoint.html#classv32float">v32float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gaca258d5056d7d097365ed2ab83a92ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real floating point vectors.  <a href="#gaca258d5056d7d097365ed2ab83a92ad9"></a><br/></td></tr>
<tr class="separator:gaca258d5056d7d097365ed2ab83a92ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71a0b6fb38bf7749602504501aa1498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorfpop.html#gab71a0b6fb38bf7749602504501aa1498">fpneg_abs_mul</a> (<a class="el" href="group__dt__fpoint.html#classv16float">v16float</a> <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a>, unsigned int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>, <a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> zbuf, int zstart, unsigned int zoffs)</td></tr>
<tr class="memdesc:gab71a0b6fb38bf7749602504501aa1498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply, take absolute value and negate for single precision real floating point vectors.  <a href="#gab71a0b6fb38bf7749602504501aa1498"></a><br/></td></tr>
<tr class="separator:gab71a0b6fb38bf7749602504501aa1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac02d3ed06bfd2b655c8c4c1be66e4c08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpabs_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] =  abs(<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]])</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0facea1eeaf1520c4c167420a49a2431"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpabs_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and take absolute value for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] =  abs(<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]])</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34e5b7f6e2c9d3c54e020f104404fa4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5aa737318f7d89f5ab0240fc77efa8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>8 x 4 bits: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga447ce0ae232b8df6fe124ebadbc7b5f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gab78806c429af07ed08f3e85397ce4aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gac1a9599d9840ab31ab0df46a5926d088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga59a9e43a73c1816ce9a54413226e1770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gafe6f5aa4a861dfa2e84f4ba264428e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga89424178e1749cea4e414fe07325c15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-accumulate for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gaddb63fe3d65e964f38a3c13e979cd9fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] + abs(<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]])</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf4a790d518eeee5cd395ddbf43e40b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and accumulate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] + abs(<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]])</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga798f830b91f7a141a41998eeadc705b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b0aa1196dd4e52e44d851c46fd4d210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gac410a63472d6fe739d5f141e14f3fe2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga270120a0ebc86049420ed15884a760d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c7f9e9dbc0df75658a1c2fbfb30873b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf83ced652673021b09d77a339a2e74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga84ab721fa840816d803a74d4c8960fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gab406a9c168d3c26062f9cf0f36697d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6128cbe449b62af09b1255bc20f206a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22f3486a407913c4d7fbacd1f81041e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gab82a218e4dd42b2179f3444359601b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34e5ee227fe6c0dcb06e313d97648844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga936851c57b3cc0add42bdd22d91c44b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7827d0fe97053cf7bbaaabeba3bf529"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9266dd0cd9a703f4cc0256e59b61463c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e9d5eeac4e068b41d99593b412571ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0923b0208495c392d1755842dce66d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e724a7a2ce34cbd3a6534c75f7f9e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga389a58e20b6742e9eeea5c1f84d2d821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94bcd9c467a30cb5447174c847d68eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga529d610c0293b24ed4b51b7a76e3b883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb9140d5d5bcf84ee494fc35dd1c4ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e6e690509cf12aba9d1bda9bd8d226d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gab0c105388d2aeb00939deb815546d3fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmac_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ea70bc03ebc2fd4ff397e095a2528b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaffc06cd24132d7178bcee30ba717dbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5580c5ce689b602cfb1fb8ab936f7868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga91b8559a1f5d33420744d544afda4b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga1284de74f1c922f34f367d934c911703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gab30263502d587d2642577bdd0b8f572a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gada9d17eae5bea8a3783d6f2f18c1ba20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-subtract intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b25bc373baf18db70e4ae639b913565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmsc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-subtract for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = acc[i] - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-subtract intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gabd25f74812fbb2f218fe18fb785afafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] - abs(<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]])</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1834f7ab3e7ce47ecba4a1c202926223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmsc_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and subtract for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = acc[i] - abs(<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]])</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs-subtract result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa503b32381bbe29d31f1736abb32e0b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] =  <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga835915c48a204091cac8d24ad5f5fb7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] =  <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga665ec0814aaf7cdac43bd3e5068e3e8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gae0623cbfefba2f406c172ebf78cc8c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga79fa774a15884fda26cf5ec390db2d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga4ff7b0cbd53c325912b0496294322635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga91f1f8d8fcf8d00446ecf799b9883800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b696862928c431e495ef6e5113c9926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiplication result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f039649eb3e694153aae0640a4081da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gab98234f63c4eaf04e9b1ab399acc7fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga17d5d98e6bb51fa0cf8e8b1492653a7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30d6e2a16d63a97464038d1e8fc70eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gacd9d4d3e1f4697909c09910608736ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gae715d9690aac3f88784ca2414b3b74f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1099b4410e8f84c7af1518c740ab437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gafbf5c992722b320d02e3d1f0a918de70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga869745c907faf2171d869ecdebba676e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gacea8f1855b08cea6cf96a26dd1376751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62e090062933d16c1753285763a50e02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gad58850c0179b60e60f76ecf55308d979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2199bc6d5389a86e31843d5589d4cd78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2700e0f68cad3751c0670b4799e674b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga134dd2770e84c1ec768de42e1c394f4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga665272a82dd053ce671ae28db33ba7bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20e9e9fcd47151968c33a9374ca4c467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b7d35cdb3c698d342aa625827c085a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e0d44cb23159974ff487ae1adcc6097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gab28a10c8a3de173bb0a390d76ad09e5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41c8c929e6f022ef735e3ca22051814d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a4b185fd15f9215581a3ca6696215d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3bd3a3c6e6d74bd75e064d6f2f1175ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c325c8b8d3c1dcd0f5c7c7450d4bf50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpmul_conf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmpmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully configurable real multiply-accumulate for single precision floating point vectors. </p>
<pre class="fragment">~~~~~~~~~~~~~~~~~~~
if (addmode == fpadd_add   ) neg = addmask ^ 0x00;
if (addmode == fpadd_sub   ) neg = addmask ^ 0xFF;
if (addmode == fpadd_mixadd) neg = addmask ^ 0xAA;
if (addmode == fpadd_mixsub) neg = addmask ^ 0x55;
</pre><p>The output can be considered to always have 8 values beause each part of the complex float is treated differently A <a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> will have the loop interating over real0 - complex0 - real1 - complex1 ...</p>
<p>This capability is introduced to allow flexibility and implement operations on conjugates. </p>
<pre class="fragment">osz = 8;

for (i = 0 ; i &lt; osz ; i++)
  m[i] = xbuf[xstart + xoffs[i]] * (ones ? 1.0 : (zbuf exists ? zbuf : xbuf)[zstart + zoffs[i]])
  n[i] = (-1)^neg[i] * (abs ? |m[i]| : m[i])
  o[i] = acc[i] + n[i]

  if   cmpmode == fpcmp_nrm :
    cmp[i] = sgn(o[i])
    ret[i] = o[i]
  elif cmpmode == fpcmp_lt :
    cmp[i] = sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
  elif cmpmode == fpcmp_ge :
    cmp[i] = ~sgn(o[i])
    ret[i] = cmp[i] ? -n[i] : acc[i]
~~~~~~~~~~~~~~~~~~~
&lt;em&gt;If cmp is not a parameter then it get's discarded.&lt;/em&gt;

Note that the return value of the cmp operation (less than/great equal than) is related to the acc value.

To make a less-than / minimum operation a user could do :
~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_ge
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):

~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = ~sgn(o[i]) = (o[i] &gt; 0) = (acc[i] &gt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = min(acc[i],m[i])
~~~~~~~~~~~~~~~~~~

Similarly a greater-or-equal / maximum operation would take the same inputs with the different mode (fpcmp_lt)

~~~~~~~~~~~~~~~~~~~
abs  = 0
addmode = fpadd_sub
addmask = 0
cmpmode = fpcmp_lt
~~~~~~~~~~~~~~~~~~~

Which would then result in (for a given lane i):
~~~~~~~~~~~~~~~~~~~
n[i]   = -1 * m[i]
o[i]   = acc[i] - m[i]
cmp[i] = sgn(o[i]) = (o[i] &lt; 0) = (acc[i] &lt; m[i])
ret[i] = cmp[i] ? -n[i] : acc[i] = max(acc[i],m[i])
~~~~~~~~~~~~~~~~~~~
</pre><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-accumulate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Incoming accumulation vector.</td></tr>
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
    <tr><td class="paramname">ones</td><td>If true all lanes from Z are replaced with 1.0.</td></tr>
    <tr><td class="paramname">abs</td><td>If true the absolute value is taken before accumulation.</td></tr>
    <tr><td class="paramname">addmode</td><td>Select one of fpadd_add, fpadd_sub, fpadd_mixadd or fpadd_mixsub. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">addmask</td><td>8 x 1 LSB bits: Corresponding lane is negated if bit is set (depending on addmode).</td></tr>
    <tr><td class="paramname">cmpmode</td><td>Use "fpcmp_lt" to select the minimum between accumulator and result of multiplication per lane, "fpcmp_ge" for the maximum and "fpcmp_nrm" for the usual sum.</td></tr>
    <tr><td class="paramname">cmp</td><td>8 x 1 LSB bits: When using fpcmp_ge or fpcmp_lt in "cmpmode", it sets a bit if accumulator was chosen (per lane). This parameter is optional.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameters 'zstart' and 'addmask' <em>must</em> be a compile time constants. </dd></dl>

</div>
</div>
<a class="anchor" id="gaca258d5056d7d097365ed2ab83a92ad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = - abs( <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]] )</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="gab71a0b6fb38bf7749602504501aa1498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpneg_abs_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply, take absolute value and negate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = - abs( <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]] )</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-abs-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0218ee177f14aa89eebe5aa3abe596bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3238d3340096b7a9711d6f94ff4a3c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for single precision real floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 8 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36585639e2836b5cfacaa4054e7f5ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gaff8e2ad8957c319518044c6d73d12b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8float">v8float</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for complex times real single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * z</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gadae832f48fbe247e2fc5d5a944210e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv32float">v32float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3e49278ec57725b4e7da150b9074cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16float">v16float</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for real times complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to x * (z.re + j(z.im))</p>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X.</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga13108a5139900aad2cbb55802cdcc9f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv16cfloat">v16cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
<a class="anchor" id="ga54ccc67806d74d6382b759e45cbfbd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a> fpneg_mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv8cfloat">v8cfloat</a>&#160;</td>
          <td class="paramname"><em>xbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>xoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__dt__fpoint.html#classv4cfloat">v4cfloat</a>&#160;</td>
          <td class="paramname"><em>zbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>zoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-negate for complex single precision floating point vectors. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = 0 ; i &lt; 4 ; i++)</div>
<div class="line">  ret[i] = - <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gadcec3cf7786292043de491471e3752d7">xbuf</a>[<a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaeb20c6002d5be39c3bd8ec6774788469">xstart</a> + <a class="code" href="group__intr__gpvectorop__bit__cmp__flt.html#gaa1e150d3657600a60f89e32f0427412e">xoffs</a>[i]] * zbuf[zstart + zoffs[i]]</div>
</div><!-- fragment --><p> Where the product corresponds to (x.re + j(x.im)) * (z.re + j(z.im))</p>
<dl class="section note"><dt>Note</dt><dd>This is a two-cycle intrinsic which will result in two microcode instructions to be scheduled. The same behavior can be achieved by calling the fully configurable multiply-accumulate intrinsic twice in order to add the two terms of the complex multiplication.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with the multiply-negate result.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xbuf</td><td>First multiplication input buffer. Small buffer variant.</td></tr>
    <tr><td class="paramname">xstart</td><td>Starting offset for all lanes of X. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values).</td></tr>
    <tr><td class="paramname">xoffs</td><td>4 bits per lane: Additional lane-dependent offset for X. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
    <tr><td class="paramname">zbuf</td><td>Second multiplication input buffer.</td></tr>
    <tr><td class="paramname">zstart</td><td>Starting offset for all lanes of Z. The offsets are referring to complex lanes (lane 0 corresponds to the first real and complex values). This <em>must</em> be a compile time constant.</td></tr>
    <tr><td class="paramname">zoffs</td><td>4 bits per lane: Additional lane-dependent offset for Z. The offsets are referring to complex lanes. For optimized code should be compile time constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Parameter 'zstart' <em>must</em> be a compile time constant. </dd>
<dd>
When xoffs or zoffs is a runtime parameter, it might be more efficient to use fpmac_conf and calculate the offests manually </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2020 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
