<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>AI Engine: Full Lane Addresssing Scheme</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xilinx.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AI Engine
   &#160;<span id="projectnumber">(AIE)             r2p15.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__vect__mult__intrinsics__explained.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Full Lane Addresssing Scheme<div class="ingroups"><a class="el" href="group__intr__gpvectorop.html">Vector Operations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p><a class="anchor" id="full_lane_explained"></a>The basic functionality of these intrinsics performs vector multiply and accumulate operations between data from two buffers, the X and Z buffers, with the other parameters and options allowing flexibility (data selection within the vectors, number of output lanes) and optional features (different input data sizes, pre-adding, etc). There is an additional input buffer, the Y buffer, whose values can be pre-added with those from the X buffer before the multiplication occurs. The result from the intrinsic is added to an accumulator.</p>
<div class="image">
<img src="diagram.PNG" alt="diagram.PNG"/>
</div>
<p>This diagram gives a functional overview of how these intrinsics work. For users who are familiar with FIR filters, in this scheme X and Y can be used for data and symmetric data respectively and Z for the coefficients when implementing a symmetric FIR filter for example.</p>
<p>The operation can be described using "lanes" and "columns". The number of lanes corresponds to the number of output values that will be generated from the intrinsic call. The number of columns is the number of multiplications that will be done per output lane, with each of the multiplication results being added together.</p>
<p>Example :</p>
<pre class="fragment">acc0 += z00*(x00 + y00) + z01*(x01 + y01) + z02*(x02 + y02) + z03*(x03 + y03)
acc1 += z10*(x10 + y10) + z11*(x11 + y11) + z12*(x12 + y12) + z13*(x13 + y13)
acc2 += z20*(x20 + y20) + z21*(x21 + y21) + z22*(x22 + y22) + z23*(x23 + y23)
acc3 += z30*(x30 + y30) + z31*(x31 + y31) + z32*(x32 + y32) + z33*(x33 + y33)
</pre><p>In this case, we are generating 4 outputs, so 4 lanes, and 4 columns for each with pre-adding from the X and Y buffers.</p>
<h1>Intrinsic naming convention</h1>
<p>The general naming convention for the vector MAC intrinsics is shown below. Optional caracteristics are shown with [] and mandatory ones with {} :</p>
<pre class="fragment">  [l]{mac|msc|mul|negmul}{2|4|8|16}[_abs|_max|_min|_maxdiff][_conj][{_sym|_antisym}[_ct|_uct]][_c|_cc|_cn|_nc]
</pre><p>Every operation will either be a multiplication, intitializing an accumulator, or a mac operation which accumulates to a running accumulator, of 2/4/8/16 lanes.</p>
<p>Optional specifications :</p>
<ul>
<li>'l' denotes that an accumulator with 80 bit lanes is used for the operation</li>
<li>'sym' and 'antisym' indicates the use of pre-adding and pre-subtraction respectively</li>
<li>'max','min' and 'maxdiff' indicates the pre-selection of lanes in the xbuff based on the maximum, minimum or maximum difference value</li>
<li>'abs' indicates the pre-computation of the absolute value in the xbuff</li>
<li>'ct' is used for partial pre-adding and pre-subtraction (seperate selection for the data input from X for the final column)</li>
<li>'uct' is used for upshifting, returning a wide accumulator. The first four lanes are the expected output of the intrinsic, and the next four are a column of data selected from the Y buffer and upshifted</li>
<li>'n' and 'c' are used to indicate that the complex conjugate will be used for one of the input buffers with complex values<ul>
<li>'c' : the only complex input buffer will be conjugated</li>
<li>'cn' : complex conjugate of X (or XY if pre-adding is used) buffer</li>
<li>'nc' : complex conjugate of Z buffer</li>
<li>'cc' : complex conjugate of both X (or XY if pre-adding is used) and Z buffers</li>
</ul>
</li>
<li>'conj' indicates that the complex conjugate of Z will be used when multiplying the data input from Y</li>
</ul>
<p><a class="anchor" id="data_selection_adv"></a></p>
<h1>Data selection</h1>
<p>The parameters of the intrinsics allow for flexible data selection from the different input buffers for each lane and column, all following the same pattern of parameters. A starting point in the buffer is given by the (x/y/z)start parameter which selects the first element for the first row and first column. To allow flexibility for each lane, (x/y/z)offsets provides an offset value for each lane that will be added to the starting point. Finally, the (x/y/z)step parameter defines the step in data selection between each column based on the previous position. It is worth noticing that when the ystep is not specified in the intrinsic it will be the symmetric of the xstep.</p>
<p>If pre-adding or pre-subtraction is used (including with conjugation/upshifting or partial), the Y buffer is used for the needed input data. In this case, the selection is done in the same way except it is minus the step. This also applies to when <a class="el" href="group__vect__mult__cmp.html">Vector MAC operations are combined with comparisons</a>. In the case of partial pre-adding or pre-subtraction, the final column is without pre-adding and data is selected from the X buffer with the ctap parameter.</p>
<h3>Data offsetting for more than 8 output lanes</h3>
<p>When the output has more than 8 lanes (e.g. 16) there are extra offset parameters. Apart from the usual 'offsets' parameter there is an additional 'offsets_hi' parameter for the extra lanes. This extra parameter allows selecting the data that will be placed into the upper input lanes (8-16) of the multiplier.</p>
<p><a class="anchor" id="start_value_rest"></a></p>
<h3>xstart/zstart restrictions</h3>
<p>Permute granularity for x/y and z buffers is 32b and 16b, respectively. The start and step values which are in sample granularity have to conform to the permute granularity (e.g., xstart for int16 data samples cannot take odd values and int8 data samples need to be multiple of 4). The lower level selection of the data samples are carried out of by the mini permute which is controlled by the square parameter.</p>
<h3>Square parameters</h3>
<p>When both input buffers are 16bit real buffers, or less there are extra selection parameters. Apart from the usual offsets parameters there is an additional 'square' parameter to select between elements of the input buffer. Additionally if the coefficient buffer (usually called zbuff) is a 8bit real buffer it too will possess a square parameter.</p>
<h2>Offset computation </h2>
<table class="doxtable">
<tr>
<th>Data </th><th>Coefficient </th><th>Complex Data </th><th>Complex Coefficient </th><th>has xysquare </th><th>has zsquare </th><th>xstart restrictions </th><th>xstep restrictions </th><th>zstart restrictions </th><th>zstep restrictions </th><th>Data scheme </th><th>Coefficient scheme</th></tr>
<tr>
<td>all others</td><td>all others </td><td>any </td><td>any </td><td>no </td><td>no </td><td>signed 32b </td><td>signed 6b </td><td>signed 4b </td><td>signed 6b </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">General</a> </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">General</a> </td></tr>
<tr>
<td>16-bit </td><td>16-bit </td><td>no </td><td>no </td><td>yes </td><td>no </td><td>multiple of 2 / signed 32b </td><td>multiple of 2 / signed 6b </td><td>signed 4b </td><td>signed 6b </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16b x 16b data</a> </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">General</a> </td></tr>
<tr>
<td>16-bit </td><td>8-bit </td><td>no </td><td>no </td><td>yes </td><td>yes </td><td>multiple of 2 / signed 32b </td><td>multiple of 2 / signed 6b </td><td>multiple of 2 / signed 4b </td><td>multiple of 2 / signed 6b </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16b x 16b data</a> </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_coeff_16bx8b">16b x8b coefficient</a> </td></tr>
<tr>
<td>8-bit </td><td>8-bit </td><td>no </td><td>no </td><td>yes </td><td>yes </td><td>multiple of 4 / signed 32b </td><td>multiple of 4 / signed 6b </td><td>multiple of 2 / signed 4b </td><td>multiple of 2 / signed 6b </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_8bx8b">8b x 8b data</a> </td><td><a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_coeff_8bx8b">8b x 8b coefficient</a> </td></tr>
</table>
<p><b>Converting from an index to a row and column pair</b> <br/>
 For any given pair of c (column) and r (row) where c can go from 0 to cols and r can go from 0 to rows(number of lanes) in the output vector: </p>
<pre class="fragment">    for i = 0 ; i &lt; rows * cols ; i++
      c = i % cols
      r = i / cols</pre><p> <em>r</em> and <em>c</em> can be used to compute the offset for the corresponding index <em>i</em> </p>
<dl class="section note"><dt>Note</dt><dd>If you want to do the opposite of the above and convert from a row and col pair to an index then you can do: <em>i = c + (r * cols)</em></dd></dl>
<h2>Schemes </h2>
<pre class="fragment">    //lanes
    lanes = (number of elements in output vector)

    //multiplications
    int m=1;
    if (data_size  == 32) m*=2;
    if (coeff_size == 32) m*=2;
    if (data_complex)     m*=2;
    if (coeff_complex)    m*=2;

    //rows and cols
    rows = lanes
    cols = 32/(m*lanes)</pre><p><a class="anchor" id="scheme_general"></a><b>General scheme</b> </p>
<pre class="fragment">    for i = 0 ; i &lt; rows * cols ; i++
      c = i % cols
      r = i / cols

      idx[i] = ( start + offs[r] + step*c ) % (#samples in buffer)</pre><dl class="section note"><dt>Note</dt><dd>For a <a class="el" href="group__dt__gpvector__1024.html#classv64int16">v64int16</a> vector the number of samples would be 64. Whereas for a <a class="el" href="group__dt__gpvector__128.html#classv4cint16">v4cint16</a> vector the number of samples would be 4.</dd></dl>
<p><a class="anchor" id="scheme_data_16bx16b"></a><b>16b x 16b data scheme</b></p>
<pre class="fragment">    for i = 0 ; i &lt; rows * cols ; i++
      c = i % cols
      r = i / cols

      if (r % 2 == 0):
        offset = offs[r]*2
      else:
        offset = offs[r]*2 + (offs[r-1] + 1)*2

      xstep =   c/2*xstep + c%2
      ystep = -(c/2*xstep - c%2)

      idx[i] = ( xstart + offset + xstep ) % (#samples in buffer)</pre><dl class="section note"><dt>Note</dt><dd>Please note how the offset for the odd rows are relative to the previous even row offset. </dd>
<dd>
If an Y buffer exists then the index computation is the same but uses the ystep computation above.</dd></dl>
<p>Once all indexes have been computed the square parameter is applied to each 2x2 matrix where the square parameter chooses the index from 0 to 3 - read as 4b parameters - ( increasing left to right, top to bottom ):</p>
<pre class="fragment">    idx[x  ][y]  idx[x  ][y+1]   &lt; = &gt; 0 1
    idx[x+1][y]  idx[x+1][y+1]   &lt; = &gt; 2 3</pre><p>The 4 LSB for the square parameter corresponds to the first lane. The above would be represented by 0x3210. Any combination is allowed. For instance, square = 0x2130 would result in:</p>
<pre class="fragment">    idx[x  ][y]   idx[x+1][y+1]   &lt; = &gt; 0 3
    idx[x  ][y+1] idx[x+1][y  ]   &lt; = &gt; 1 2</pre><p><a class="anchor" id="scheme_coeff_16bx8b"></a><b>16b x 8b coefficient scheme</b></p>
<pre class="fragment">    cols = 64/(m*lanes)

    for i = 0 ; i &lt; rows * cols ; i++
      c = i % cols
      r = i / cols

      offset = offs[r]*2

      step = c/2*zstep + c%2

      idx[i] = ( xstart + offset + step ) % (#samples in buffer)</pre><p>Once all indexes have been computed the square parameter is applied to each 2x2 matrix where the square parameter chooses the index from 0 to 3 - read as 4b parameters - ( increasing left to right, top to bottom ):</p>
<pre class="fragment">    idx[x  ][y]  idx[x  ][y+1]   &lt; = &gt; 0 1
    idx[x+1][y]  idx[x+1][y+1]   &lt; = &gt; 2 3</pre><p>The 4 LSB for the square parameter corresponds to the first lane. The above would be represented by 0x3210. Any combination is allowed. For instance, square = 0x2130 would result in:</p>
<pre class="fragment">    idx[x  ][y]   idx[x+1][y+1]   &lt; = &gt; 0 3
    idx[x  ][y+1] idx[x+1][y  ]   &lt; = &gt; 1 2</pre><p><a class="anchor" id="scheme_data_8bx8b"></a><b>8b x 8b data scheme</b></p>
<pre class="fragment">    cols = 128/(m*lanes)

    for i = 0 ; i &lt; rows * cols ; i++
      c = i % cols
      r = i / cols

      rx = r / 2
      rr = r % 4
      if      rr == 0:
        offset = offs[rx]*4
      else if rr == 1:
        offset = offs[rx]*4 + 1
      else if rr == 2:
        offset = offs[rx]*4 + ( offs[rx-1] + 1 ) * 4
      else if rr == 3:
        offset = offs[rx]*4 + ( offs[rx-1] + 1 ) * 4 + 1

      xstep =     c/2*xstep + (c%2)*2
      ystep = - ( c/2*xstep - (c%2)*2 )

      idx[i] = ( xstart + offset + xstep ) % (#samples in buffer)</pre><dl class="section note"><dt>Note</dt><dd>If an Y buffer exists then the index computation is the same but uses the ystep computation above.</dd></dl>
<p>Once all indexes have been computed the square parameter is applied to each 4x2 matrix where the square parameter chooses the index from 0 to 3 - read as 4b parameters - ( increasing left to right, top to bottom ). In this case, because the matrix is 4x2 and only 4 indexes exist, the indexes from the even rows are duplicated for each odd row:</p>
<pre class="fragment">    idx[x  ][y]  idx[x  ][y+1]   &lt; = &gt; 0 1
    idx[x+1][y]  idx[x+1][y+1]   &lt; = &gt; 0 1
    idx[x+2][y]  idx[x+2][y+1]   &lt; = &gt; 2 3
    idx[x+3][y]  idx[x+3][y+1]   &lt; = &gt; 2 3</pre><p>The 4 LSB for the square parameter corresponds to the first lane, first column and second lane, first column. The above would be represented by 0x3210. Any combination is allowed. For instance, square = 0x2130 would result in:</p>
<pre class="fragment">    idx[x  ][y]   idx[x+2][y+1]   &lt; = &gt; 0 3
    idx[x+1][y]   idx[x+3][y+1]   &lt; = &gt; 0 3
    idx[x  ][y+1] idx[x+2][y  ]   &lt; = &gt; 1 2
    idx[x+1][y+1] idx[x+3][y  ]   &lt; = &gt; 1 2</pre><p><a class="anchor" id="scheme_coeff_8bx8b"></a><b>8b x 8b coefficient scheme</b></p>
<pre class="fragment">    for i = 0 ; i &lt; rows * cols ; i++
      c = i % cols
      r = i / cols

      rz = ( row / 4 ) * 2 + ( row % 2 )
      offset = offs[rz]*2

      step = c/2*zstep + (c%2)

      idx[i] = ( xstart + offset + step ) % (#samples in buffer)</pre><p> Square parameter is applied in the same way as for the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_coeff_16bx8b">16b x 8b coefficient scheme</a>.</p>
<h2>Example:</h2>
<p>An example on the use of the 'square' parameter can be the broadcasting of data to multiple multiplier input lanes. One such practical case would be 16bit real x real FIR application where we would require the following pattern:</p>
<pre class="fragment">    acc[0] = xbuff[0]*coef[0] + xbuff[1]*coef[1]
    acc[1] = xbuff[1]*coef[0] + xbuff[2]*coef[1]</pre><p>We will consider for this example this mul intrinsic: </p>
<pre class="fragment">v16acc48 mul16 (v32int16 xbuff, int xstart, unsigned int xoffsets, int xoffsets_hi, int xysquare, v16int16 zbuff, int zstart, int zoffsets, int zoffsets_hi, int zstep)
</pre><p>To obtain the required pattern we would load lanes 0, 1, 2 and 3 in the lowest byte of the 'offsets' parameter by setting it to '0x00' and set the square parameter to '0x2110'. Additionally, the coefficient buffer needs to be accessed in the offset '0x00' for the first two lanes and have a step parameter of 1 (to place the coefficient one in the second column). Thus we would call the intrinsic in the following way:</p>
<pre class="fragment">acc = mul16 (xbuff, 0, 0x03020100, 0x47362514 , 0x2110, coef, 0, 0x00000000, 0x00000000, 1)
</pre><p>The call would then result in the following: </p>
<pre class="fragment">    acc[0]  = xbuff[0]  * coef[0] + xbuff[1]  * coef[1]
    acc[1]  = xbuff[1]  * coef[0] + xbuff[2]  * coef[1]
    acc[2]  = xbuff[2]  * coef[0] + xbuff[3]  * coef[1]
    acc[3]  = xbuff[3]  * coef[0] + xbuff[4]  * coef[1]
    acc[4]  = xbuff[4]  * coef[0] + xbuff[5]  * coef[1]
    acc[5]  = xbuff[5]  * coef[0] + xbuff[6]  * coef[1]
    acc[6]  = xbuff[6]  * coef[0] + xbuff[7]  * coef[1]
    acc[7]  = xbuff[7]  * coef[0] + xbuff[8]  * coef[1]
    acc[8]  = xbuff[8]  * coef[0] + xbuff[9]  * coef[1]
    acc[9]  = xbuff[9]  * coef[0] + xbuff[12] * coef[1]
    acc[10] = xbuff[10] * coef[0] + xbuff[11] * coef[1]
    acc[11] = xbuff[11] * coef[0] + xbuff[16] * coef[1]
    acc[12] = xbuff[12] * coef[0] + xbuff[13] * coef[1]
    acc[13] = xbuff[13] * coef[0] + xbuff[20] * coef[1]
    acc[14] = xbuff[14] * coef[0] + xbuff[15] * coef[1]
    acc[15] = xbuff[15] * coef[0] + xbuff[24] * coef[1]</pre><h2>Example, square parameter with more than 2 columns:</h2>
<p>If we extend the previous example with 4 tap filter, and keep the same data precision (16bit real x real FIR) we would require the following pattern:</p>
<pre class="fragment">    acc[0] = xbuff[0]*coef[0] + xbuff[1]*coef[1] + xbuff[2]*coef[2] + xbuff[3]*coef[3]
    acc[1] = xbuff[1]*coef[0] + xbuff[2]*coef[1] + xbuff[3]*coef[2] + xbuff[4]*coef[3]
    ...</pre><p>In order to know which multiplication we can use we need to calculate the output lanes, using the inverse formula for calculating cols.</p>
<pre class="fragment">  m=1
  if (data_size  == 32) m*=2;
  if (coeff_size == 32) m*=2;
  if (data_complex)     m*=2;
  if (coeff_complex)    m*=2;

  cols = 32/(m*lanes)

  We already know that we want 4 columns, so, with m=1, lanes has to be 8.</pre><p>We will therefore consider this mul intrinsic: </p>
<pre class="fragment">v8acc48   mul8 (v64int16 xbuff, int xstart, unsigned int xoffsets, int xstep, unsigned int xsquare, v16int16 zbuff, int zstart, unsigned int zoffsets, int zstep)
</pre><h3>Selecting parameters for x buffer</h3>
<p>We will use the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b data selection scheme</a>. In the next table we show the indexes of the x vector that we want. Our aim is now to find a combination of xstart, xoffset, xstep and xsquare to get this addressing.</p>
<table class="doxtable">
<tr>
<th></th><th>col </th><th>0 </th><th>1 </th><th>2 </th><th>3 </th></tr>
<tr>
<td>lane </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>acc[0] </td><td></td><td>x[0] </td><td>x[1] </td><td>x[2] </td><td>x[3] </td></tr>
<tr>
<td>acc[1] </td><td></td><td>x[1] </td><td>x[2] </td><td>x[3] </td><td>x[4] </td></tr>
<tr>
<td>acc[2] </td><td></td><td>x[2] </td><td>x[3] </td><td>x[4] </td><td>x[5] </td></tr>
<tr>
<td>acc[3] </td><td></td><td>x[3] </td><td>x[4] </td><td>x[5] </td><td>x[6] </td></tr>
<tr>
<td>acc[4] </td><td></td><td>x[4] </td><td>x[5] </td><td>x[6] </td><td>x[7] </td></tr>
<tr>
<td>acc[5] </td><td></td><td>x[5] </td><td>x[6] </td><td>x[7] </td><td>x[8] </td></tr>
<tr>
<td>acc[6] </td><td></td><td>x[6] </td><td>x[7] </td><td>x[8] </td><td>x[9] </td></tr>
<tr>
<td>acc[7] </td><td></td><td>x[7] </td><td>x[8] </td><td>x[9] </td><td>x[10] </td></tr>
</table>
<p>We realize that we need an "x_start" of 0 because it's the only way to have a 0 at the cell of coordinates (acc_0,col_0).</p>
<p>If we take a closer look we see that the cell with coordinates (acc_1,col_0) requires a "1". By inspecting the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b data selection scheme</a> we find that this is not possible because</p>
<pre class="fragment">  Formula is:

  if (r % 2 == 0):
        offset = offs[r]*2
      else:
        offset = offs[r]*2 + (offs[r-1] + 1)*2

  idx[r,c] = start + offset + c/2*xstep + c%2

  By substituting start = 0, c = 0, r=1
  
  idx[r,c] = offs[r]*2 + (offs[r-1] + 1)*2 </pre><p>And we realize that since everything is multiplied by 2, we will never get a 1 in this cell.</p>
<p>Thankfully we can correct this by using the xsquare parameter, which permutes 4 elements at a time as explained again in <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b data selection scheme</a>, and works in blocks of 2x2 matrixes, starting at the corner (acc_0,col_0) and moving with a stride of 2 in x and y directions.</p>
<p>With this idea in mind we try to achieve the following pattern using xstart,xoffsets and xstep:</p>
<table class="doxtable">
<tr>
<th></th><th>col </th><th>0 </th><th>1 </th><th>2 </th><th>3 </th></tr>
<tr>
<td>lane </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>acc[0] </td><td></td><td>x[0] </td><td>x[1] </td><td>x[2] </td><td>x[3] </td></tr>
<tr>
<td>acc[1] </td><td></td><td>x[2] </td><td>x[3] </td><td>x[4] </td><td>x[5] </td></tr>
<tr>
<td>acc[2] </td><td></td><td>x[2] </td><td>x[3] </td><td>x[4] </td><td>x[5] </td></tr>
<tr>
<td>acc[3] </td><td></td><td>x[4] </td><td>x[5] </td><td>x[6] </td><td>x[7] </td></tr>
<tr>
<td>acc[4] </td><td></td><td>x[4] </td><td>x[5] </td><td>x[6] </td><td>x[7] </td></tr>
<tr>
<td>acc[5] </td><td></td><td>x[6] </td><td>x[7] </td><td>x[8] </td><td>x[9] </td></tr>
<tr>
<td>acc[6] </td><td></td><td>x[6] </td><td>x[7] </td><td>x[8] </td><td>x[9] </td></tr>
<tr>
<td>acc[7] </td><td></td><td>x[8] </td><td>x[9] </td><td>x[10] </td><td>x[11] </td></tr>
</table>
<p>And then we apply a square of 0x2110 such that</p>
<table class="doxtable">
<tr>
<th></th><th></th></tr>
<tr>
<td>A </td><td>B </td></tr>
<tr>
<td>C </td><td>D </td></tr>
</table>
<p>Becomes this:</p>
<table class="doxtable">
<tr>
<th></th><th></th></tr>
<tr>
<td>A </td><td>B </td></tr>
<tr>
<td>B </td><td>C </td></tr>
</table>
<p>Thus achieving the following index addresssing:</p>
<table class="doxtable">
<tr>
<th></th><th>col </th><th>0 </th><th>1 </th><th>2 </th><th>3 </th></tr>
<tr>
<td>lane </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>acc[0] </td><td></td><td>x[0] </td><td>x[1] </td><td>x[2] </td><td>x[3] </td></tr>
<tr>
<td>acc[1] </td><td></td><td>x[1] </td><td>x[2] </td><td>x[3] </td><td>x[4] </td></tr>
<tr>
<td>acc[2] </td><td></td><td>x[2] </td><td>x[3] </td><td>x[4] </td><td>x[5] </td></tr>
<tr>
<td>acc[3] </td><td></td><td>x[3] </td><td>x[4] </td><td>x[5] </td><td>x[6] </td></tr>
<tr>
<td>acc[4] </td><td></td><td>x[4] </td><td>x[5] </td><td>x[6] </td><td>x[7] </td></tr>
<tr>
<td>acc[5] </td><td></td><td>x[5] </td><td>x[6] </td><td>x[7] </td><td>x[8] </td></tr>
<tr>
<td>acc[6] </td><td></td><td>x[6] </td><td>x[7] </td><td>x[8] </td><td>x[9] </td></tr>
<tr>
<td>acc[7] </td><td></td><td>x[7] </td><td>x[8] </td><td>x[9] </td><td>x[10] </td></tr>
</table>
<p>Remember that xoffset,xstart and xstep participate only in the first permutation, hence we choose them to create the first table. The chosen ones are:</p>
<pre class="fragment">    xstart = 0
    xstep = 2
    xoffset = 0x03020100</pre><p>I suggest to try substituting those parameters into the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_data_16bx16b">16bx16b data selection scheme</a> and see that you get the same result as in the example.</p>
<h3>Selecting parameters for z buffer</h3>
<p>Z buffer follows the <a class="el" href="group__vect__mult__intrinsics__explained.html#scheme_general">general scheme</a>. What we want is the following addressing:</p>
<table class="doxtable">
<tr>
<th></th><th>col </th><th>0 </th><th>1 </th><th>2 </th><th>3 </th></tr>
<tr>
<td>lane </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>acc[0] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[1] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[2] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[3] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[4] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[5] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[6] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
<tr>
<td>acc[7] </td><td></td><td>z[0] </td><td>z[1] </td><td>z[2] </td><td>z[3] </td></tr>
</table>
<p>And hence we will choose</p>
<pre class="fragment">    zstart = 0
    zstep = 1
    zoffset = 0x0</pre><h3>The intrinsic call</h3>
<pre class="fragment">acc = mul8 (xbuff, 0, 0x03020100, 0x2110, coef, 0, 0x00000000, 1)
</pre><p>The call would then result in the following: </p>
<pre class="fragment">    acc[0]  = xbuff[0]  * coef[0] + xbuff[1]  * coef[1] + xbuff[2]  * coef[2] + xbuff[3]   * coef[3]
    acc[1]  = xbuff[1]  * coef[0] + xbuff[2]  * coef[1] + xbuff[3]  * coef[2] + xbuff[4]   * coef[3]
    acc[2]  = xbuff[2]  * coef[0] + xbuff[3]  * coef[1] + xbuff[4]  * coef[2] + xbuff[5]   * coef[3]
    acc[3]  = xbuff[3]  * coef[0] + xbuff[4]  * coef[1] + xbuff[5]  * coef[2] + xbuff[6]   * coef[3]
    acc[4]  = xbuff[4]  * coef[0] + xbuff[5]  * coef[1] + xbuff[6]  * coef[2] + xbuff[7]   * coef[3]
    acc[5]  = xbuff[5]  * coef[0] + xbuff[6]  * coef[1] + xbuff[7]  * coef[2] + xbuff[8]   * coef[3]
    acc[6]  = xbuff[6]  * coef[0] + xbuff[7]  * coef[1] + xbuff[8]  * coef[2] + xbuff[9]   * coef[3]
    acc[7]  = xbuff[7]  * coef[0] + xbuff[8]  * coef[1] + xbuff[9]  * coef[2] + xbuff[10]  * coef[3]</pre><h1>Center-Tap Modes</h1>
<p>For symmetric FIR filter implementations that need to compute symmetric terms and a center tap in the same instruction, a special mode where the uct_col variable is used is required. The center tap terms will be selected from the pre-computed column offsets in the Y buffer using the uct_col parameter (immediate parameter). For instance, if a given intrinsic takes 4 columns of the X and Y buffers:</p>
<ul>
<li>The data selection using the start and offset parameters will occur;</li>
<li>The uct_col will select one of this columns (between 0-3 in this case, where 0 is the first column);</li>
<li>The data selected with uct_col will be fed to the up-shifting hardware which will place the result on the upper accumulator lanesa.</li>
</ul>
<h1>Optional parameters</h1>
<p>Besides the distinctions above, there are also a few other variations of the intrinsics which don't change their functionality but allow for more flexibility with buffer sizes, types and data selection.</p>
<p>There are two version of the intrinsics without pre-adding/subtraction, using two different sized vectors for the X buffer, for example for this intrinsic in <a class="el" href="group__vect__mult__32cx16c__nn.html#v4cacc48_mac4_v8cint32_v8cint16_smallbuf_32c_16c">small</a> and <a class="el" href="group__vect__mult__32cx16c__nn.html#v4cacc48_mac4_v16cint32_v8cint16_32c_16c">large</a> X buffer.</p>
<p>For intrinsics using input from both an X and Y buffer, there is also a second version using just an X buffer with twice the size. In this case the data selection for X and Y are done from this single buffer.</p>
<h1>Full examples</h1>
<p>Here are a few detailed examples with increasing complexity using the intrinsics :</p>
<p><a class="el" href="group__vect__mult__intrinsics__explained.html#mul_example">16 bit complex by 16 bit complex multiplication</a> <br/>
 <a class="el" href="group__vect__mult__intrinsics__explained.html#mul_sym_example">16 bit complex by 16 bit real multiplication with pre-adding from X and Y buffers</a> <br/>
 <a class="el" href="group__vect__mult__intrinsics__explained.html#mul_sym_ct_example">16 bit complex by 16 bit real multiplication with partial pre-adding from Y buffer with X buffer conjugation</a> <br/>
</p>
<p><a class="anchor" id="mul_example"></a></p>


<h3><a class="anchor" id="ex1"></a>Lane selection example 1: 16 bit complex by 16 bit complex multiplication</h3><div class="textblock">The basic <a class="el" href="group__vect__mult__16cx16c__nn.html#v4cacc48_mul4_v32cint16_v8cint16_16c_16c">mul4</a> carries out the following operations and generates 4 complex outputs in parallel:<div class="fragment"><div class="line">acc0 = z00*x00 + z01*x01</div>
<div class="line">acc1 = z10*x10 + z11*x11</div>
<div class="line">acc2 = z20*x20 + z21*x21</div>
<div class="line">acc3 = z30*x30 + z31*x31</div>
</div><!-- fragment -->This equation shows the way data is selected from the X and Z buffers, where xN,M denotes the Mth X buffer term in output lane N (N=0,...,3 and M=0,1). The same format applies to input from the Z buffer. The input/output parameters of the intrinsic function are as follows.<h4>Parameters</h4>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Valid bits</th><th>Comments</th></tr>
<tr>
<td>acc </td><td><a class="el" href="group__dt__gpvector__accum.html#classv4cacc48">v4cacc48</a> </td><td>All </td><td>Running accumulation vector (4 x cint48 lanes) </td></tr>
<tr>
<td>xbuff </td><td><a class="el" href="group__dt__gpvector__1024.html#classv32cint16">v32cint16</a></td><td>All </td><td>Input buffer of 32 elements of type cint16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>5b LSB</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr>
<td>xoffsets </td><td>int </td><td>16b LSB </td><td>4b offset for each lane in the xbuffer. LSB apply to first lane </td></tr>
<tr>
<td>xstep </td><td>int </td><td>4b LSB </td><td>Step between each column for selection in the xbuffer </td></tr>
<tr>
<td>zbuff </td><td><a class="el" href="group__dt__gpvector__256.html#classv8cint16">v8cint16</a></td><td>All </td><td>Input buffer of 8 elements of type cint16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>3b LSB</td><td>Starting position offset applied to all lanes for input from Z buffer </td></tr>
<tr>
<td>zoffsets</td><td>int </td><td>16b LSB</td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>4b LSB </td><td>Step between each column for selection in the zbuffer </td></tr>
</table>
The input data is read from the X and Z buffers. The indices to access the X buffer are determined based on xstart, xoffsets and xstep. Assuming that IN,M denotes the buffer indices for xN,M in (Eq.1):<h4>BUFFER SELECTORS:</h4>
xoffsets = x3x2x1x0<table class="doxtable">
<tr>
<th align="center">l0,0 </th><th align="center">l0,1</th></tr>
<tr>
<td align="center">(x0+xstart) mod 32 </td><td align="center">(x0+xstart+xstep) mod 32 </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="center">l1,0 </th><th align="center">l1,1</th></tr>
<tr>
<td align="center">(x1+xstart) mod 32 </td><td align="center">(x1+xstart+xstep) mod 32 </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="center">l2,0 </th><th align="center">l2,1</th></tr>
<tr>
<td align="center">(x2+xstart) mod 32 </td><td align="center">(x2+xstart+xstep) mod 32 </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="center">l3,0 </th><th align="center">l3,1</th></tr>
<tr>
<td align="center">(x3+xstart) mod 32 </td><td align="center">(x3+xstart+xstep) mod 32 </td></tr>
</table>
The same selection method applies to the Z buffer with zstart/zoffsets/zsteps and a modulo 8.<h4>Example: 6-tap complex FIR filter</h4>
For implementing a filter, xbuff can be used to store the data while zbuff stores the coefficientsxbuff (contains DXs of type cint16)<table class="doxtable">
<tr>
<th align="left">buffer </th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center">.</th></tr>
<tr>
<td align="left">xbuff (HI)</td><td align="center">D16</td><td align="center">D17</td><td align="center">D18</td><td align="center">D19</td><td align="center">D20</td><td align="center">D21</td><td align="center">D22</td><td align="center">D23</td><td align="center">D24</td><td align="center">D25</td><td align="center">D26</td><td align="center">D27</td><td align="center">D28</td><td align="center">D29</td><td align="center">D30</td><td align="center">D31 </td></tr>
<tr>
<td align="left">xbuff (LO)</td><td align="center">D0 </td><td align="center">D1 </td><td align="center">D2 </td><td align="center">D3 </td><td align="center">D4 </td><td align="center">D5 </td><td align="center">D6 </td><td align="center">D7 </td><td align="center">D8 </td><td align="center">D9 </td><td align="center">D10</td><td align="center">D11</td><td align="center">D12</td><td align="center">D13</td><td align="center">D14</td><td align="center">D15 </td></tr>
</table>
zbuff (contains CXs of type cint16)<table class="doxtable">
<tr>
<th align="left">coeffs</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td align="left">zbuff </td><td align="center">C0 </td><td align="center">C1 </td><td align="center">C2 </td><td align="center">C3 </td><td align="center">C4 </td><td align="center">C5 </td><td align="center">0 </td><td align="center">0 </td></tr>
</table>
<br/>
acc = mul4(xbuff, 0, 0x3210, 1, zbuff, 0, 0x0000, 1) <br/>
 According to the configuration above, the data and coefficient parameters are set as follows:<table class="doxtable">
<tr>
<th align="center">xstart</th><th align="center">x3</th><th align="center">x2</th><th align="center">x1</th><th align="center">x0</th><th align="center">xstep</th><th align="center">zstart</th><th align="center">z3</th><th align="center">z2</th><th align="center">z1</th><th align="center">z0</th><th align="center">zstep</th></tr>
<tr>
<td align="center">0 </td><td align="center">3 </td><td align="center">2 </td><td align="center">1 </td><td align="center">0 </td><td align="center">1 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">1 </td></tr>
</table>
<br/>
In this case mul4 calculates the following data selectors for the X buffer:<table class="doxtable">
<tr>
<th align="center">l0,0</th><th align="center">l0,1</th></tr>
<tr>
<td align="center">0 </td><td align="center">1 </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="center">l1,0</th><th align="center">l1,1</th></tr>
<tr>
<td align="center">1 </td><td align="center">2 </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="center">l2,0</th><th align="center">l2,1</th></tr>
<tr>
<td align="center">2 </td><td align="center">3 </td></tr>
</table>
<table class="doxtable">
<tr>
<th align="center">l3,0</th><th align="center">l3,1</th></tr>
<tr>
<td align="center">3 </td><td align="center">4 </td></tr>
</table>
Using the buffer selectors, mul4 accesses the data terms and coefficients in xbuff and zbuff buffers, respectively, and generates the contribution of the first two complex coefficients for the output :<div class="fragment"><div class="line">acc0 = C0*D0 + C1*D1</div>
<div class="line">acc1 = C0*D1 + C1*D2</div>
<div class="line">acc2 = C0*D2 + C1*D3</div>
<div class="line">acc3 = C0*D3 + C1*D4</div>
</div><!-- fragment -->We could then perform the following operations with the corresponding <a class="el" href="group__vect__mult__16cx16__nn.html#v4cacc48_mac4_v32cint16_v16int16_16c_16">mac4</a> operation to accumulate to the returned register and compute the following operations of this filter for the first 4 output lanes :acc = mac4(acc, xbuff, 2, 0x3210, 1, zbuff, 2, 0x0000, 1) :<div class="fragment"><div class="line">acc0 += C2*D2 + C3*D3</div>
<div class="line">acc1 += C2*D3 + C3*D4</div>
<div class="line">acc2 += C2*D4 + C3*D5</div>
<div class="line">acc3 += C2*D5 + C3*D6</div>
</div><!-- fragment -->acc = mac4(acc, xbuff, 4, 0x3210, 1, zbuff, 4, 0x0000, 1) :<div class="fragment"><div class="line">acc0 += C4*D4 + C5*D5</div>
<div class="line">acc1 += C4*D5 + C5*D6</div>
<div class="line">acc2 += C4*D6 + C5*D7</div>
<div class="line">acc3 += C4*D7 + C5*D8</div>
</div><!-- fragment --> </div>

<h3><a class="anchor" id="ex2"></a>Lane selection example 2: 16 bit complex by 16 bit real multiplication with pre-adding from X and Y buffers</h3><div class="textblock"><a class="anchor" id="mul_sym_example"></a>The <a class="el" href="group__vect__mult__sym__16cx16__nn.html#v4cacc48_mul4_sym_v16cint16_v16int16_twobuf_smallbuf_16c_16">mul4_sym</a> intrinsic carries out the following operations and generates 4 complex outputs in parallel:<div class="fragment"><div class="line">acc0 = z00*(x00 + y00) + z01*(x01 + y01) + z02*(x02 + y02) + z03*(x03 + y03)</div>
<div class="line">acc1 = z10*(x10 + y10) + z11*(x11 + y11) + z12*(x12 + y12) + z13*(x13 + y13)</div>
<div class="line">acc2 = z20*(x20 + y20) + z21*(x21 + y21) + z22*(x22 + y22) + z23*(x23 + y23)</div>
<div class="line">acc3 = z30*(x30 + y30) + z31*(x31 + y31) + z32*(x32 + y32) + z33*(x33 + y33)</div>
</div><!-- fragment --><h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Valid bits</th><th>Comments</th></tr>
<tr>
<td>acc </td><td><a class="el" href="group__dt__gpvector__accum.html#classv4cacc48">v4cacc48</a> </td><td>All </td><td>Running accumulation vector (4 x cint48 lanes) </td></tr>
<tr>
<td>xbuff </td><td><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a></td><td>All </td><td>Input buffer of 16 elements of type cint16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>4b LSB</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr>
<td>xyoffsets </td><td>int </td><td>16b LSB</td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xystep </td><td>int </td><td>4b LSB </td><td>Step between each column for selection in the x and y buffers </td></tr>
<tr>
<td>ybuff </td><td><a class="el" href="group__dt__gpvector__512.html#classv16cint16">v16cint16</a></td><td>All </td><td>Right input buffer of 16 elements of type cint16 </td></tr>
<tr>
<td>ystart </td><td>int </td><td>4b LSB</td><td>Starting position offset applied to all lanes for input from Y buffer </td></tr>
<tr>
<td>zbuff </td><td><a class="el" href="group__dt__gpvector__256.html#classv16int16">v16int16</a></td><td>All </td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>4b LSB</td><td>Starting position offset applied to all lanes for input from Z buffer </td></tr>
<tr>
<td>zoffsets</td><td>int </td><td>16b LSB</td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>4b LSB </td><td>Step between each column for selection in the zbuffer </td></tr>
</table>
<h4>Example:16-tap symetric FIR filter with real coefficients</h4>
For implementing a symetric filter, pre-adding can be used to select data from the X and Y input buffers, with the Z buffer holding the coefficients.Xbuff and Ybuff(contains DXs of type cint16)<table class="doxtable">
<tr>
<th align="left">buffer </th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td align="left">xbuff </td><td align="center">D0 </td><td align="center">D1 </td><td align="center">D2 </td><td align="center">D3 </td><td align="center">D4 </td><td align="center">D5 </td><td align="center">D6 </td><td align="center">D7 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td></tr>
<tr>
<td align="left">ybuff </td><td align="center">D8 </td><td align="center">D9 </td><td align="center">D10</td><td align="center">D11</td><td align="center">D12</td><td align="center">D13</td><td align="center">D14</td><td align="center">D15</td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td></tr>
</table>
zbuff (contains CXs of type cint16)<table class="doxtable">
<tr>
<th align="left">coeffs</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td align="left">zbuff </td><td align="center">C0 </td><td align="center">C1 </td><td align="center">C2 </td><td align="center">C3 </td><td align="center">C4 </td><td align="center">C5 </td><td align="center">C6 </td><td align="center">C7 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td></tr>
</table>
<br/>
acc = mul4_sym(xbuff, 0, 0x3210, 1, ybuff, 7, zbuff, 0, 0x0000, 1) <br/>
 According to the configuration above, the data and coefficient parameters are set as follows:<table class="doxtable">
<tr>
<th align="center">xstart</th><th align="center">xy3</th><th align="center">xy2</th><th align="center">xy1</th><th align="center">xy0</th><th align="center">xystep</th><th align="center">ystart </th><th align="center">zstart</th><th align="center">z3</th><th align="center">z2</th><th align="center">z1</th><th align="center">z0</th><th align="center">zstep</th></tr>
<tr>
<td align="center">0 </td><td align="center">3 </td><td align="center">2 </td><td align="center">1 </td><td align="center">0 </td><td align="center">1 </td><td align="center">15 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">1 </td></tr>
</table>
<br/>
Using the data selectors and the coefficient selectors (i.e., c0 to c3), cmul4 accesses the data terms and coefficients in buf and y buffers, respectively, and generates the contribution of the first two complex coefficients in y at the output: Using the buffer selectors mul4_sym pre-adds data from the X and Y buffers, accesses the coefficients in the Z buffer, and generates the contribution of the first 4 real coefficients for the output : </p>
<div class="fragment"><div class="line">acc0 = C0*(D0+D15) + C1*(D1+D14) + C2*(D2+D13) + C3*(D3+D12)</div>
<div class="line">acc1 = C0*(D1+D16) + C1*(D2+D15) + C2*(D3+D14) + C3*(D4+D13)</div>
<div class="line">acc2 = C0*(D2+D17) + C1*(D3+D16) + C2*(D4+D15) + C3*(D5+D14)</div>
<div class="line">acc3 = C0*(D3+D18) + C1*(D4+D17) + C2*(D5+D16) + C3*(D6+D15)</div>
</div><!-- fragment -->We could then perform the remaining operation with the corresponding <a class="el" href="group__vect__mult__sym__16cx16__nn.html#v4cacc48_mac4_sym_v16cint16_v16int16_twobuf_smallbuf_16c_16">mac4_sym</a> operation to accumulate to the returned register and compute the following operations of this filter for the first 4 output lanes :acc = mac4_sym(acc,xbuff, 4, 0x3210, 1, ybuff, 3, zbuff, 0, 0x0000, 1:<div class="fragment"><div class="line">acc0 = C4*(D4+D11) + C5*(D5+D10) + C6*(D6+D9 ) + C7*(D7 +D8 )</div>
<div class="line">acc1 = C4*(D5+D12) + C5*(D6+D11) + C6*(D7+D10) + C7*(D8 +D9 )</div>
<div class="line">acc2 = C4*(D6+D13) + C5*(D7+D12) + C6*(D8+D11) + C7*(D9 +D10)</div>
<div class="line">acc3 = C4*(D7+D14) + C5*(D8+D13) + C6*(D9+D12) + C7*(D10+D11)</div>
</div><!-- fragment -->This same functionality can be found for <a class="el" href="group__vect__mult__antisym.html">pre-subtraction</a>. </div>

<h3><a class="anchor" id="ex3"></a>Lane selection example 3: 16 bit complex by 16 bit real multiplication with partial pre-adding from Y buffer with X buffer conjugation</h3><div class="textblock"><a class="anchor" id="mul_sym_ct_example"></a>This example will illustrate more complex data selection with an intrinsic using partial pre-adding.Desired operation :<div class="fragment"><div class="line">acc0 = C0*( conj(D0)+conj(D25) ) + C2*( conj(D1)+conj(D24) ) + C4*( conj(D2)+conj(D23) ) + C6*conj(D15)</div>
<div class="line">acc1 = C1*( conj(D2)+conj(D27) ) + C3*( conj(D3)+conj(D26) ) + C5*( conj(D4)+conj(D25) ) + C7*conj(D17)</div>
<div class="line">acc2 = C3*( conj(D4)+conj(D29) ) + C5*( conj(D5)+conj(D28) ) + C7*( conj(D6)+conj(D27) ) + C9*conj(D19)</div>
<div class="line">acc3 = C3*( conj(D6)+conj(D31) ) + C5*( conj(D7)+conj(D30) ) + C7*( conj(D8)+conj(D29) ) + C9*conj(D21)</div>
</div><!-- fragment -->The intrinsic used to achieve this will be <a class="el" href="group__vect__mult__sym__ct__16cx16__cn.html#v4cacc48_mul4_sym_ct_c_v32cint16_v16int16_16c_16">mul4_sym_ct_c</a>.<h2>Parameters</h2>
<table class="doxtable">
<tr>
<th>Input/Output</th><th>Type </th><th>Valid bits</th><th>Comments</th></tr>
<tr>
<td>acc </td><td><a class="el" href="group__dt__gpvector__accum.html#classv4cacc48">v4cacc48</a> </td><td>All </td><td>Running accumulation vector (4 x cint48 lanes) </td></tr>
<tr>
<td>xbuff </td><td><a class="el" href="group__dt__gpvector__1024.html#classv32cint16">v32cint16</a></td><td>All </td><td>Input buffer of 32 elements of type cint16 </td></tr>
<tr>
<td>xstart </td><td>int </td><td>5b LSB</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr>
<td>xyoffsets </td><td>int </td><td>16b LSB</td><td>4b offset for each lane, applied to both x and y buffers. LSB apply to first lane </td></tr>
<tr>
<td>xystep </td><td>int </td><td>4b LSB </td><td>Step between each column for selection in the x and y buffers </td></tr>
<tr>
<td>ystart </td><td>int </td><td>5b LSB</td><td>Starting position offset applied to all lanes for input from Y buffer </td></tr>
<tr>
<td>ctap </td><td>int </td><td>4b LSB</td><td>Selector for partial pre-substraction </td></tr>
<tr>
<td>zbuff </td><td><a class="el" href="group__dt__gpvector__256.html#classv16int16">v16int16</a></td><td>All </td><td>Input buffer of 16 elements of type int16 </td></tr>
<tr>
<td>zstart </td><td>int </td><td>4b LSB</td><td>Starting position offset applied to all lanes for input from Z buffer </td></tr>
<tr>
<td>zoffsets</td><td>int </td><td>16b LSB</td><td>4b offset for each lane, applied to input from Z buffer. LSB apply to first lane </td></tr>
<tr>
<td>zstep </td><td>int </td><td>4b LSB </td><td>Step between each column for selection in the zbuffer </td></tr>
</table>
The contents of the input buffers will be considered as follows :xbuff (contains DXs of type cint16)<table class="doxtable">
<tr>
<th align="left">buffer </th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td align="left">xbuff (HI)</td><td align="center">D16</td><td align="center">D17</td><td align="center">D18</td><td align="center">D19</td><td align="center">D20</td><td align="center">D21</td><td align="center">D22</td><td align="center">D23</td><td align="center">D24</td><td align="center">D25</td><td align="center">D26</td><td align="center">D27</td><td align="center">D28</td><td align="center">D29</td><td align="center">D30</td><td align="center">D31 </td></tr>
<tr>
<td align="left">xbuff (LO)</td><td align="center">D0 </td><td align="center">D1 </td><td align="center">D2 </td><td align="center">D3 </td><td align="center">D4 </td><td align="center">D5 </td><td align="center">D6 </td><td align="center">D7 </td><td align="center">D8 </td><td align="center">D9 </td><td align="center">D10</td><td align="center">D11</td><td align="center">D12</td><td align="center">D13</td><td align="center">D14</td><td align="center">D15 </td></tr>
</table>
zbuff (contains CXs of type int16)<table class="doxtable">
<tr>
<th align="left">coeffs</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td align="left">zbuff </td><td align="center">C0 </td><td align="center">C1 </td><td align="center">C2 </td><td align="center">C3 </td><td align="center">C4 </td><td align="center">C5 </td><td align="center">C6 </td><td align="center">C7 </td><td align="center">C8 </td><td align="center">C9 </td><td align="center">C10</td><td align="center">C11</td><td align="center">C12</td><td align="center">C13</td><td align="center">C14</td><td align="center">C15 </td></tr>
</table>
For this given equation : </p>
<pre class="fragment">-The pattern for the coefficients from the Z buffer is 0x3310 so that will be the zoffsets value. Similarly, it will be 0x6420 for the xyoffsets.
-The first value from zbuff is C0 so zstart=0 and similarly xstart=0.
-For the pre-add we start at D25 so ystart=25.
-The step between columns is 2 for zbuf values and 1 for xbuf and ybuf values so zstep=2 and xystep=1.
-Finally, we want to start at D15 for the final column so ctap will be set to 15.
</pre>This gives this usage of the intrinsic :acc = mul4_sym_ct_cn(xbuff, 0, 0x6420, 1, 25, 15, zbuff, 0, 0x3310, 2); </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> UG1078 &copy; 2020 Xilinx, Inc. All rights reserved. 
    </li>
  </ul>
</div>
</body>
</html>
